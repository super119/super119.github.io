
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>DRM memory management - 最好的GEM/TTM/PRIME解释 - Make Things Cool</title>
  <meta name="author" content="Mark Zhang">

  
  <meta name="description" content="本文转载自：https://www.kernel.org/doc/htmldocs/drm/drm-memory-management.html Memory management The Translation Table Manager (TTM)
The Graphics Execution &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.markzhang.cn/blog/2015/03/02/drm-memory-management/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Make Things Cool" type="application/atom+xml">
  <!-- <link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic' rel='stylesheet' type='text/css'> -->
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!-- <link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"> -->
<!-- <link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"> -->

  

</head>

<body   >
  <header role="banner"><hgroup>
  <div id="logo">
  	<div id="logoLeft">{</div>
  	<div id="logoText">s/no/yes/g</div>
  	<div id="logoRight">}</div>
  	<div class="clear"></div>
  </div>
  <h1><a href="/">Make Things Cool</a></h1>
  
    <h2>2015 Jaunty Journal</h2>
  
  <div class="clear"></div>
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:www.markzhang.cn" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About me</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      
        <h1 class="entry-title">DRM Memory Management - 最好的GEM/TTM/PRIME解释</h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2015-03-02T10:37:00+08:00" pubdate data-updated="true">Mar 2<span>nd</span>, 2015</time>
        
      </p>
    
  </header>


<div class="entry-content"><p>本文转载自：<a href="https://www.kernel.org/doc/htmldocs/drm/drm-memory-management.html">https://www.kernel.org/doc/htmldocs/drm/drm-memory-management.html</a></p>

<p><strong>Memory management</strong></p>

<ul>
<li>The Translation Table Manager (TTM)</li>
<li>The Graphics Execution Manager (GEM)</li>
<li>VMA Offset Manager</li>
<li>PRIME Buffer Sharing</li>
<li>PRIME Function References</li>
<li>DRM MM Range Allocator</li>
<li>DRM MM Range Allocator Function References</li>
<li>CMA Helper Functions Reference</li>
</ul>


<!-- more -->


<p>Modern Linux systems require large amount of graphics memory to store frame buffers, textures, vertices and other graphics-related data. Given the very dynamic nature of many of that data, managing graphics memory efficiently is thus crucial for the graphics stack and plays a central role in the DRM infrastructure.</p>

<p>The DRM core includes two memory managers, namely Translation Table Maps (TTM) and Graphics Execution Manager (GEM). TTM was the first DRM memory manager to be developed and tried to be a one-size-fits-them all solution. It provides a single userspace API to accommodate the need of all hardware, supporting both Unified Memory Architecture (UMA) devices and devices with dedicated video RAM (i.e. most discrete video cards). This resulted in a large, complex piece of code that turned out to be hard to use for driver development.</p>

<p>GEM started as an Intel-sponsored project in reaction to TTM&rsquo;s complexity. Its design philosophy is completely different: instead of providing a solution to every graphics memory-related problems, GEM identified common code between drivers and created a support library to share it. GEM has simpler initialization and execution requirements than TTM, but has no video RAM management capabilities and is thus limited to UMA devices.</p>

<p><strong>The Translation Table Manager (TTM)</strong></p>

<p>TTM initialization</p>

<p>Drivers wishing to support TTM must fill out a drm_bo_driver structure. The structure contains several fields with function pointers for initializing the TTM, allocating and freeing memory, waiting for command completion and fence synchronization, and memory migration. See the radeon_ttm.c file for an example of usage.</p>

<p>The ttm_global_reference structure is made up of several fields:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">struct</span> <span class="n">ttm_global_reference</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">enum</span> <span class="n">ttm_global_types</span> <span class="n">global_type</span><span class="p">;</span>
</span><span class='line'>  <span class="n">size_t</span> <span class="n">size</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ttm_global_reference</span> <span class="o">*</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ttm_global_reference</span> <span class="o">*</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>There should be one global reference structure for your memory manager as a whole, and there will be others for each object created by the memory manager at runtime. Your global TTM should have a type of TTM_GLOBAL_TTM_MEM. The size field for the global object should be sizeof(struct ttm_mem_global), and the init and release hooks should point at your driver-specific init and release routines, which probably eventually call ttm_mem_global_init and ttm_mem_global_release, respectively.</p>

<p>Once your global TTM accounting structure is set up and initialized by calling ttm_global_item_ref() on it, you need to create a buffer object TTM to provide a pool for buffer object allocation by clients and the kernel itself. The type of this object should be TTM_GLOBAL_TTM_BO, and its size should be sizeof(struct ttm_bo_global). Again, driver-specific init and release functions may be provided, likely eventually calling ttm_bo_global_init() and ttm_bo_global_release(), respectively. Also, like the previous object, ttm_global_item_ref() is used to create an initial reference count for the TTM, which will call your initialization function.</p>

<p><strong>The Graphics Execution Manager (GEM)</strong></p>

<p>GEM Initialization
GEM Objects Creation
GEM Objects Lifetime
GEM Objects Naming
GEM Objects Mapping
Memory Coherency
Command Execution
GEM Function Reference</p>

<p>The GEM design approach has resulted in a memory manager that doesn&rsquo;t provide full coverage of all (or even all common) use cases in its userspace or kernel API. GEM exposes a set of standard memory-related operations to userspace and a set of helper functions to drivers, and let drivers implement hardware-specific operations with their own private API.</p>

<p>The GEM userspace API is described in the GEM &ndash; the Graphics Execution Manager article on LWN. While slightly outdated, the document provides a good overview of the GEM API principles. Buffer allocation and read and write operations, described as part of the common GEM API, are currently implemented using driver-specific ioctls.</p>

<p>GEM is data-agnostic. It manages abstract buffer objects without knowing what individual buffers contain. APIs that require knowledge of buffer contents or purpose, such as buffer allocation or synchronization primitives, are thus outside of the scope of GEM and must be implemented using driver-specific ioctls.</p>

<p>On a fundamental level, GEM involves several operations:</p>

<ul>
<li>Memory allocation and freeing</li>
<li>Command execution</li>
<li>Aperture management at command execution time</li>
</ul>


<p>Buffer object allocation is relatively straightforward and largely provided by Linux&rsquo;s shmem layer, which provides memory to back each object.</p>

<p>Device-specific operations, such as command execution, pinning, buffer read &amp; write, mapping, and domain ownership transfers are left to driver-specific ioctls.</p>

<p><strong>GEM Initialization</strong></p>

<p>Drivers that use GEM must set the DRIVER_GEM bit in the struct drm_driver driver_features field. The DRM core will then automatically initialize the GEM core before calling the load operation. Behind the scene, this will create a DRM Memory Manager object which provides an address space pool for object allocation.</p>

<p>In a KMS configuration, drivers need to allocate and initialize a command ring buffer following core GEM initialization if required by the hardware. UMA devices usually have what is called a &ldquo;stolen&rdquo; memory region, which provides space for the initial framebuffer and large, contiguous memory regions required by the device. This space is typically not managed by GEM, and must be initialized separately into its own DRM MM object.</p>

<p><strong>GEM Objects Creation</strong></p>

<p>GEM splits creation of GEM objects and allocation of the memory that backs them in two distinct operations.</p>

<p>GEM objects are represented by an instance of struct drm_gem_object. Drivers usually need to extend GEM objects with private information and thus create a driver-specific GEM object structure type that embeds an instance of struct drm_gem_object.</p>

<p>To create a GEM object, a driver allocates memory for an instance of its specific GEM object type and initializes the embedded struct drm_gem_object with a call to drm_gem_object_init. The function takes a pointer to the DRM device, a pointer to the GEM object and the buffer object size in bytes.</p>

<p>GEM uses shmem to allocate anonymous pageable memory. drm_gem_object_init will create an shmfs file of the requested size and store it into the struct drm_gem_object filp field. The memory is used as either main storage for the object when the graphics hardware uses system memory directly or as a backing store otherwise.</p>

<p>Drivers are responsible for the actual physical pages allocation by calling shmem_read_mapping_page_gfp for each page. Note that they can decide to allocate pages when initializing the GEM object, or to delay allocation until the memory is needed (for instance when a page fault occurs as a result of a userspace memory access or when the driver needs to start a DMA transfer involving the memory).</p>

<p>Anonymous pageable memory allocation is not always desired, for instance when the hardware requires physically contiguous system memory as is often the case in embedded devices. Drivers can create GEM objects with no shmfs backing (called private GEM objects) by initializing them with a call to drm_gem_private_object_init instead of drm_gem_object_init. Storage for private GEM objects must be managed by drivers.</p>

<p>Drivers that do not need to extend GEM objects with private information can call the drm_gem_object_alloc function to allocate and initialize a struct drm_gem_object instance. The GEM core will call the optional driver gem_init_object operation after initializing the GEM object with drm_gem_object_init.</p>

<p>int (<em>gem_init_object) (struct drm_gem_object </em>obj);</p>

<p>No alloc-and-init function exists for private GEM objects.</p>

<p><strong>GEM Objects Lifetime</strong></p>

<p>All GEM objects are reference-counted by the GEM core. References can be acquired and release by calling drm_gem_object_reference and drm_gem_object_unreference respectively. The caller must hold the drm_device struct_mutex lock. As a convenience, GEM provides the drm_gem_object_reference_unlocked and drm_gem_object_unreference_unlocked functions that can be called without holding the lock.</p>

<p>When the last reference to a GEM object is released the GEM core calls the drm_driver gem_free_object operation. That operation is mandatory for GEM-enabled drivers and must free the GEM object and all associated resources.</p>

<p>void (<em>gem_free_object) (struct drm_gem_object </em>obj);</p>

<p>Drivers are responsible for freeing all GEM object resources, including the resources created by the GEM core. If an mmap offset has been created for the object (in which case drm_gem_object::map_list::map is not NULL) it must be freed by a call to drm_gem_free_mmap_offset. The shmfs backing store must be released by calling drm_gem_object_release (that function can safely be called if no shmfs backing store has been created).</p>

<p><strong>GEM Objects Naming</strong></p>

<p>Communication between userspace and the kernel refers to GEM objects using local handles, global names or, more recently, file descriptors. All of those are 32-bit integer values; the usual Linux kernel limits apply to the file descriptors.</p>

<p>GEM handles are local to a DRM file. Applications get a handle to a GEM object through a driver-specific ioctl, and can use that handle to refer to the GEM object in other standard or driver-specific ioctls. Closing a DRM file handle frees all its GEM handles and dereferences the associated GEM objects.</p>

<p>To create a handle for a GEM object drivers call drm_gem_handle_create. The function takes a pointer to the DRM file and the GEM object and returns a locally unique handle. When the handle is no longer needed drivers delete it with a call to drm_gem_handle_delete. Finally the GEM object associated with a handle can be retrieved by a call to drm_gem_object_lookup.</p>

<p>Handles don&rsquo;t take ownership of GEM objects, they only take a reference to the object that will be dropped when the handle is destroyed. To avoid leaking GEM objects, drivers must make sure they drop the reference(s) they own (such as the initial reference taken at object creation time) as appropriate, without any special consideration for the handle. For example, in the particular case of combined GEM object and handle creation in the implementation of the dumb_create operation, drivers must drop the initial reference to the GEM object before returning the handle.</p>

<p>GEM names are similar in purpose to handles but are not local to DRM files. They can be passed between processes to reference a GEM object globally. Names can&rsquo;t be used directly to refer to objects in the DRM API, applications must convert handles to names and names to handles using the DRM_IOCTL_GEM_FLINK and DRM_IOCTL_GEM_OPEN ioctls respectively. The conversion is handled by the DRM core without any driver-specific support.</p>

<p>GEM also supports buffer sharing with dma-buf file descriptors through PRIME. GEM-based drivers must use the provided helpers functions to implement the exporting and importing correctly. See the section called “PRIME Buffer Sharing”. Since sharing file descriptors is inherently more secure than the easily guessable and global GEM names it is the preferred buffer sharing mechanism. Sharing buffers through GEM names is only supported for legacy userspace. Furthermore PRIME also allows cross-device buffer sharing since it is based on dma-bufs.</p>

<p><strong>GEM Objects Mapping</strong></p>

<p>Because mapping operations are fairly heavyweight GEM favours read/write-like access to buffers, implemented through driver-specific ioctls, over mapping buffers to userspace. However, when random access to the buffer is needed (to perform software rendering for instance), direct access to the object can be more efficient.</p>

<p>The mmap system call can&rsquo;t be used directly to map GEM objects, as they don&rsquo;t have their own file handle. Two alternative methods currently co-exist to map GEM objects to userspace. The first method uses a driver-specific ioctl to perform the mapping operation, calling do_mmap under the hood. This is often considered dubious, seems to be discouraged for new GEM-enabled drivers, and will thus not be described here.</p>

<p>The second method uses the mmap system call on the DRM file handle.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="n">mmap</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span>
</span><span class='line'>             <span class="n">off_t</span> <span class="n">offset</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>DRM identifies the GEM object to be mapped by a fake offset passed through the mmap offset argument. Prior to being mapped, a GEM object must thus be associated with a fake offset. To do so, drivers must call drm_gem_create_mmap_offset on the object. The function allocates a fake offset range from a pool and stores the offset divided by PAGE_SIZE in obj->map_list.hash.key. Care must be taken not to call drm_gem_create_mmap_offset if a fake offset has already been allocated for the object. This can be tested by obj->map_list.map being non-NULL.</p>

<p>Once allocated, the fake offset value (obj->map_list.hash.key &lt;&lt; PAGE_SHIFT) must be passed to the application in a driver-specific way and can then be used as the mmap offset argument.</p>

<p>The GEM core provides a helper method drm_gem_mmap to handle object mapping. The method can be set directly as the mmap file operation handler. It will look up the GEM object based on the offset value and set the VMA operations to the drm_driver gem_vm_ops field. Note that drm_gem_mmap doesn&rsquo;t map memory to userspace, but relies on the driver-provided fault handler to map pages individually.</p>

<p>To use drm_gem_mmap, drivers must fill the struct drm_driver gem_vm_ops field with a pointer to VM operations.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="o">*</span><span class="n">gem_vm_ops</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="p">{</span>
</span><span class='line'>          <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span> <span class="n">area</span><span class="p">);</span>
</span><span class='line'>          <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">close</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span> <span class="n">area</span><span class="p">);</span>
</span><span class='line'>          <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fault</span><span class="p">)(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">);</span>
</span><span class='line'>  <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>The open and close operations must update the GEM object reference count. Drivers can use the drm_gem_vm_open and drm_gem_vm_close helper functions directly as open and close handlers.</p>

<p>The fault operation handler is responsible for mapping individual pages to userspace when a page fault occurs. Depending on the memory allocation scheme, drivers can allocate pages at fault time, or can decide to allocate memory for the GEM object at the time the object is created.</p>

<p>Drivers that want to map the GEM object upfront instead of handling page faults can implement their own mmap file operation handler.</p>

<p><strong>Memory Coherency</strong></p>

<p>When mapped to the device or used in a command buffer, backing pages for an object are flushed to memory and marked write combined so as to be coherent with the GPU. Likewise, if the CPU accesses an object after the GPU has finished rendering to the object, then the object must be made coherent with the CPU&rsquo;s view of memory, usually involving GPU cache flushing of various kinds. This core CPU&lt;&ndash;>GPU coherency management is provided by a device-specific ioctl, which evaluates an object&rsquo;s current domain and performs any necessary flushing or synchronization to put the object into the desired coherency domain (note that the object may be busy, i.e. an active render target; in that case, setting the domain blocks the client and waits for rendering to complete before performing any necessary flushing operations).</p>

<p><strong>Command Execution</strong></p>

<p>Perhaps the most important GEM function for GPU devices is providing a command execution interface to clients. Client programs construct command buffers containing references to previously allocated memory objects, and then submit them to GEM. At that point, GEM takes care to bind all the objects into the GTT, execute the buffer, and provide necessary synchronization between clients accessing the same buffers. This often involves evicting some objects from the GTT and re-binding others (a fairly expensive operation), and providing relocation support which hides fixed GTT offsets from clients. Clients must take care not to submit command buffers that reference more objects than can fit in the GTT; otherwise, GEM will reject them and no rendering will occur. Similarly, if several objects in the buffer require fence registers to be allocated for correct rendering (e.g. 2D blits on pre-965 chips), care must be taken not to require more fence registers than are available to the client. Such resource management should be abstracted from the client in libdrm.</p>

<p><strong>GEM Function Reference</strong></p>

<p>VMA Offset Manager</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">drm_vma_offset_manager_init</span> <span class="err">—</span> <span class="n">Initialize</span> <span class="k">new</span> <span class="n">offset</span><span class="o">-</span><span class="n">manager</span>
</span><span class='line'><span class="n">drm_vma_offset_manager_destroy</span> <span class="err">—</span> <span class="n">Destroy</span> <span class="n">offset</span> <span class="n">manager</span>
</span><span class='line'><span class="n">drm_vma_offset_lookup</span> <span class="err">—</span> <span class="n">Find</span> <span class="n">node</span> <span class="n">in</span> <span class="n">offset</span> <span class="n">space</span>
</span><span class='line'><span class="n">drm_vma_offset_lookup_locked</span> <span class="err">—</span> <span class="n">Find</span> <span class="n">node</span> <span class="n">in</span> <span class="n">offset</span> <span class="n">space</span>
</span><span class='line'><span class="n">drm_vma_offset_add</span> <span class="err">—</span> <span class="n">Add</span> <span class="n">offset</span> <span class="n">node</span> <span class="n">to</span> <span class="n">manager</span>
</span><span class='line'><span class="n">drm_vma_offset_remove</span> <span class="err">—</span> <span class="n">Remove</span> <span class="n">offset</span> <span class="n">node</span> <span class="n">from</span> <span class="n">manager</span>
</span><span class='line'><span class="n">drm_vma_node_allow</span> <span class="err">—</span> <span class="n">Add</span> <span class="n">open</span><span class="o">-</span><span class="n">file</span> <span class="n">to</span> <span class="n">list</span> <span class="n">of</span> <span class="n">allowed</span> <span class="n">users</span>
</span><span class='line'><span class="n">drm_vma_node_revoke</span> <span class="err">—</span> <span class="n">Remove</span> <span class="n">open</span><span class="o">-</span><span class="n">file</span> <span class="n">from</span> <span class="n">list</span> <span class="n">of</span> <span class="n">allowed</span> <span class="n">users</span>
</span><span class='line'><span class="n">drm_vma_node_is_allowed</span> <span class="err">—</span> <span class="n">Check</span> <span class="n">whether</span> <span class="n">an</span> <span class="n">open</span><span class="o">-</span><span class="n">file</span> <span class="n">is</span> <span class="n">granted</span> <span class="n">access</span>
</span><span class='line'><span class="n">drm_vma_offset_exact_lookup</span> <span class="err">—</span> <span class="n">Look</span> <span class="n">up</span> <span class="n">node</span> <span class="n">by</span> <span class="n">exact</span> <span class="n">address</span>
</span><span class='line'><span class="n">drm_vma_offset_lock_lookup</span> <span class="err">—</span> <span class="n">Lock</span> <span class="n">lookup</span> <span class="k">for</span> <span class="n">extended</span> <span class="k">private</span> <span class="n">use</span>
</span><span class='line'><span class="n">drm_vma_offset_unlock_lookup</span> <span class="err">—</span> <span class="n">Unlock</span> <span class="n">lookup</span> <span class="k">for</span> <span class="n">extended</span> <span class="k">private</span> <span class="n">use</span>
</span><span class='line'><span class="n">drm_vma_node_reset</span> <span class="err">—</span> <span class="n">Initialize</span> <span class="n">or</span> <span class="n">reset</span> <span class="n">node</span> <span class="n">object</span>
</span><span class='line'><span class="n">drm_vma_node_start</span> <span class="err">—</span> <span class="n">Return</span> <span class="n">start</span> <span class="n">address</span> <span class="k">for</span> <span class="n">page</span><span class="o">-</span><span class="n">based</span> <span class="n">addressing</span>
</span><span class='line'><span class="n">drm_vma_node_size</span> <span class="err">—</span> <span class="n">Return</span> <span class="n">size</span> <span class="p">(</span><span class="n">page</span><span class="o">-</span><span class="n">based</span><span class="p">)</span>
</span><span class='line'><span class="n">drm_vma_node_has_offset</span> <span class="err">—</span> <span class="n">Check</span> <span class="n">whether</span> <span class="n">node</span> <span class="n">is</span> <span class="n">added</span> <span class="n">to</span> <span class="n">offset</span> <span class="n">manager</span>
</span><span class='line'><span class="n">drm_vma_node_offset_addr</span> <span class="err">—</span> <span class="n">Return</span> <span class="n">sanitized</span> <span class="n">offset</span> <span class="k">for</span> <span class="n">user</span><span class="o">-</span><span class="n">space</span> <span class="n">mmaps</span>
</span><span class='line'><span class="n">drm_vma_node_unmap</span> <span class="err">—</span> <span class="n">Unmap</span> <span class="n">offset</span> <span class="n">node</span>
</span><span class='line'><span class="n">drm_vma_node_verify_access</span> <span class="err">—</span> <span class="n">Access</span> <span class="n">verification</span> <span class="n">helper</span> <span class="k">for</span> <span class="n">TTM</span>
</span></code></pre></td></tr></table></div></figure>


<p>The vma-manager is responsible to map arbitrary driver-dependent memory regions into the linear user address-space. It provides offsets to the caller which can then be used on the address_space of the drm-device. It takes care to not overlap regions, size them appropriately and to not confuse mm-core by inconsistent fake vm_pgoff fields. Drivers shouldn&rsquo;t use this for object placement in VMEM. This manager should only be used to manage mappings into linear user-space VMs.</p>

<p>We use drm_mm as backend to manage object allocations. But it is highly optimized for alloc/free calls, not lookups. Hence, we use an rb-tree to speed up offset lookups.</p>

<p>You must not use multiple offset managers on a single address_space. Otherwise, mm-core will be unable to tear down memory mappings as the VM will no longer be linear.</p>

<p>This offset manager works on page-based addresses. That is, every argument and return code (with the exception of drm_vma_node_offset_addr) is given in number of pages, not number of bytes. That means, object sizes and offsets must always be page-aligned (as usual). If you want to get a valid byte-based user-space address for a given offset, please see drm_vma_node_offset_addr.</p>

<p>Additionally to offset management, the vma offset manager also handles access management. For every open-file context that is allowed to access a given node, you must call drm_vma_node_allow. Otherwise, an mmap call on this open-file with the offset of the node will fail with -EACCES. To revoke access again, use drm_vma_node_revoke. However, the caller is responsible for destroying already existing mappings, if required.</p>

<p><strong>PRIME Buffer Sharing</strong></p>

<p>Overview and Driver Interface
PRIME Helper Functions
PRIME is the cross device buffer sharing framework in drm, originally created for the OPTIMUS range of multi-gpu platforms. To userspace PRIME buffers are dma-buf based file descriptors.</p>

<p><strong>Overview and Driver Interface</strong></p>

<p>Similar to GEM global names, PRIME file descriptors are also used to share buffer objects across processes. They offer additional security: as file descriptors must be explicitly sent over UNIX domain sockets to be shared between applications, they can&rsquo;t be guessed like the globally unique GEM names.</p>

<p>Drivers that support the PRIME API must set the DRIVER_PRIME bit in the struct drm_driver driver_features field, and implement the prime_handle_to_fd and prime_fd_to_handle operations.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">prime_handle_to_fd</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
</span><span class='line'>                          <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">,</span> <span class="n">uint32_t</span> <span class="n">handle</span><span class="p">,</span>
</span><span class='line'>                          <span class="n">uint32_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">prime_fd</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">prime_fd_to_handle</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
</span><span class='line'>                          <span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file_priv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prime_fd</span><span class="p">,</span>
</span><span class='line'>                          <span class="n">uint32_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>Those two operations convert a handle to a PRIME file descriptor and vice versa. Drivers must use the kernel dma-buf buffer sharing framework to manage the PRIME file descriptors. Similar to the mode setting API PRIME is agnostic to the underlying buffer object manager, as long as handles are 32bit unsigned integers.</p>

<p>While non-GEM drivers must implement the operations themselves, GEM drivers must use the drm_gem_prime_handle_to_fd and drm_gem_prime_fd_to_handle helper functions. Those helpers rely on the driver gem_prime_export and gem_prime_import operations to create a dma-buf instance from a GEM object (dma-buf exporter role) and to create a GEM object from a dma-buf instance (dma-buf importer role).</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">struct</span> <span class="n">dma_buf</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">gem_prime_export</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
</span><span class='line'>                             <span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span>
</span><span class='line'>                             <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
</span><span class='line'><span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">gem_prime_import</span><span class="p">)(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
</span><span class='line'>                                            <span class="k">struct</span> <span class="n">dma_buf</span> <span class="o">*</span><span class="n">dma_buf</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>These two operations are mandatory for GEM drivers that support PRIME.</p>

<p><strong>PRIME Helper Functions</strong></p>

<p>Drivers can implement gem_prime_export and gem_prime_import in terms of simpler APIs by using the helper functions drm_gem_prime_export and drm_gem_prime_import. These functions implement dma-buf support in terms of five lower-level driver callbacks:</p>

<p>Export callbacks:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">gem_prime_pin</span> <span class="p">(</span><span class="n">optional</span><span class="p">)</span><span class="o">:</span> <span class="n">prepare</span> <span class="n">a</span> <span class="n">GEM</span> <span class="n">object</span> <span class="k">for</span> <span class="n">exporting</span>
</span><span class='line'><span class="nl">gem_prime_get_sg_table:</span> <span class="n">provide</span> <span class="n">a</span> <span class="n">scatter</span><span class="o">/</span><span class="n">gather</span> <span class="n">table</span> <span class="n">of</span> <span class="n">pinned</span> <span class="n">pages</span>
</span><span class='line'><span class="nl">gem_prime_vmap:</span> <span class="n">vmap</span> <span class="n">a</span> <span class="n">buffer</span> <span class="n">exported</span> <span class="n">by</span> <span class="n">your</span> <span class="n">driver</span>
</span><span class='line'><span class="nl">gem_prime_vunmap:</span> <span class="n">vunmap</span> <span class="n">a</span> <span class="n">buffer</span> <span class="n">exported</span> <span class="n">by</span> <span class="n">your</span> <span class="n">driver</span>
</span></code></pre></td></tr></table></div></figure>


<p>Import callback:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">gem_prime_import_sg_table</span> <span class="p">(</span><span class="n">import</span><span class="p">)</span><span class="o">:</span> <span class="n">produce</span> <span class="n">a</span> <span class="n">GEM</span> <span class="n">object</span> <span class="n">from</span> <span class="n">another</span> <span class="n">driver</span><span class="err">&#39;</span><span class="n">s</span> <span class="n">scatter</span><span class="o">/</span><span class="n">gather</span> <span class="n">table</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>PRIME Function References</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">drm_gem_dmabuf_release</span> <span class="err">—</span> <span class="n">dma_buf</span> <span class="n">release</span> <span class="n">implementation</span> <span class="k">for</span> <span class="n">GEM</span>
</span><span class='line'><span class="n">drm_gem_prime_export</span> <span class="err">—</span> <span class="n">helper</span> <span class="n">library</span> <span class="n">implementation</span> <span class="n">of</span> <span class="n">the</span> <span class="k">export</span> <span class="n">callback</span>
</span><span class='line'><span class="n">drm_gem_prime_handle_to_fd</span> <span class="err">—</span> <span class="n">PRIME</span> <span class="k">export</span> <span class="n">function</span> <span class="k">for</span> <span class="n">GEM</span> <span class="n">drivers</span>
</span><span class='line'><span class="n">drm_gem_prime_import</span> <span class="err">—</span> <span class="n">helper</span> <span class="n">library</span> <span class="n">implementation</span> <span class="n">of</span> <span class="n">the</span> <span class="n">import</span> <span class="n">callback</span>
</span><span class='line'><span class="n">drm_gem_prime_fd_to_handle</span> <span class="err">—</span> <span class="n">PRIME</span> <span class="n">import</span> <span class="n">function</span> <span class="k">for</span> <span class="n">GEM</span> <span class="n">drivers</span>
</span><span class='line'><span class="n">drm_prime_pages_to_sg</span> <span class="err">—</span> <span class="n">converts</span> <span class="n">a</span> <span class="n">page</span> <span class="n">array</span> <span class="n">into</span> <span class="n">an</span> <span class="n">sg</span> <span class="n">list</span>
</span><span class='line'><span class="n">drm_prime_sg_to_page_addr_arrays</span> <span class="err">—</span> <span class="n">convert</span> <span class="n">an</span> <span class="n">sg</span> <span class="n">table</span> <span class="n">into</span> <span class="n">a</span> <span class="n">page</span> <span class="n">array</span>
</span><span class='line'><span class="n">drm_prime_gem_destroy</span> <span class="err">—</span> <span class="n">helper</span> <span class="n">to</span> <span class="n">clean</span> <span class="n">up</span> <span class="n">a</span> <span class="n">PRIME</span><span class="o">-</span><span class="n">imported</span> <span class="n">GEM</span> <span class="n">object</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>DRM MM Range Allocator</strong></p>

<p>Overview
LRU Scan/Eviction Support
Overview</p>

<p>drm_mm provides a simple range allocator. The drivers are free to use the resource allocator from the linux core if it suits them, the upside of drm_mm is that it&rsquo;s in the DRM core. Which means that it&rsquo;s easier to extend for some of the crazier special purpose needs of gpus.</p>

<p>The main data struct is drm_mm, allocations are tracked in drm_mm_node. Drivers are free to embed either of them into their own suitable datastructures. drm_mm itself will not do any allocations of its own, so if drivers choose not to embed nodes they need to still allocate them themselves.</p>

<p>The range allocator also supports reservation of preallocated blocks. This is useful for taking over initial mode setting configurations from the firmware, where an object needs to be created which exactly matches the firmware&rsquo;s scanout target. As long as the range is still free it can be inserted anytime after the allocator is initialized, which helps with avoiding looped depencies in the driver load sequence.</p>

<p>drm_mm maintains a stack of most recently freed holes, which of all simplistic datastructures seems to be a fairly decent approach to clustering allocations and avoiding too much fragmentation. This means free space searches are O(num_holes). Given that all the fancy features drm_mm supports something better would be fairly complex and since gfx thrashing is a fairly steep cliff not a real concern. Removing a node again is O(1).</p>

<p>drm_mm supports a few features: Alignment and range restrictions can be supplied. Further more every drm_mm_node has a color value (which is just an opaqua unsigned long) which in conjunction with a driver callback can be used to implement sophisticated placement restrictions. The i915 DRM driver uses this to implement guard pages between incompatible caching domains in the graphics TT.</p>

<p>Two behaviors are supported for searching and allocating: bottom-up and top-down. The default is bottom-up. Top-down allocation can be used if the memory area has different restrictions, or just to reduce fragmentation.</p>

<p>Finally iteration helpers to walk all nodes and all holes are provided as are some basic allocator dumpers for debugging.</p>

<p><strong>LRU Scan/Eviction Support</strong></p>

<p>Very often GPUs need to have continuous allocations for a given object. When evicting objects to make space for a new one it is therefore not most efficient when we simply start to select all objects from the tail of an LRU until there&rsquo;s a suitable hole: Especially for big objects or nodes that otherwise have special allocation constraints there&rsquo;s a good chance we evict lots of (smaller) objects unecessarily.</p>

<p>The DRM range allocator supports this use-case through the scanning interfaces. First a scan operation needs to be initialized with drm_mm_init_scan or drm_mm_init_scan_with_range. The the driver adds objects to the roaster (probably by walking an LRU list, but this can be freely implemented) until a suitable hole is found or there&rsquo;s no further evitable object.</p>

<p>The the driver must walk through all objects again in exactly the reverse order to restore the allocator state. Note that while the allocator is used in the scan mode no other operation is allowed.</p>

<p>Finally the driver evicts all objects selected in the scan. Adding and removing an object is O(1), and since freeing a node is also O(1) the overall complexity is O(scanned_objects). So like the free stack which needs to be walked before a scan operation even begins this is linear in the number of objects. It doesn&rsquo;t seem to hurt badly.</p>

<p><strong>DRM MM Range Allocator Function References</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">drm_mm_reserve_node</span> <span class="err">—</span> <span class="n">insert</span> <span class="n">an</span> <span class="n">pre</span><span class="o">-</span><span class="n">initialized</span> <span class="n">node</span>
</span><span class='line'><span class="n">drm_mm_insert_node_generic</span> <span class="err">—</span> <span class="n">search</span> <span class="k">for</span> <span class="n">space</span> <span class="n">and</span> <span class="n">insert</span> <span class="n">node</span>
</span><span class='line'><span class="n">drm_mm_insert_node_in_range_generic</span> <span class="err">—</span> <span class="n">ranged</span> <span class="n">search</span> <span class="k">for</span> <span class="n">space</span> <span class="n">and</span> <span class="n">insert</span> <span class="n">node</span>
</span><span class='line'><span class="n">drm_mm_remove_node</span> <span class="err">—</span> <span class="n">Remove</span> <span class="n">a</span> <span class="n">memory</span> <span class="n">node</span> <span class="n">from</span> <span class="n">the</span> <span class="n">allocator</span><span class="p">.</span>
</span><span class='line'><span class="n">drm_mm_replace_node</span> <span class="err">—</span> <span class="n">move</span> <span class="n">an</span> <span class="n">allocation</span> <span class="n">from</span> <span class="n">old</span> <span class="n">to</span> <span class="k">new</span>
</span><span class='line'><span class="n">drm_mm_init_scan</span> <span class="err">—</span> <span class="n">initialize</span> <span class="n">lru</span> <span class="n">scanning</span>
</span><span class='line'><span class="n">drm_mm_init_scan_with_range</span> <span class="err">—</span> <span class="n">initialize</span> <span class="n">range</span><span class="o">-</span><span class="n">restricted</span> <span class="n">lru</span> <span class="n">scanning</span>
</span><span class='line'><span class="n">drm_mm_scan_add_block</span> <span class="err">—</span> <span class="n">add</span> <span class="n">a</span> <span class="n">node</span> <span class="n">to</span> <span class="n">the</span> <span class="n">scan</span> <span class="n">list</span>
</span><span class='line'><span class="n">drm_mm_scan_remove_block</span> <span class="err">—</span> <span class="n">remove</span> <span class="n">a</span> <span class="n">node</span> <span class="n">from</span> <span class="n">the</span> <span class="n">scan</span> <span class="n">list</span>
</span><span class='line'><span class="n">drm_mm_clean</span> <span class="err">—</span> <span class="n">checks</span> <span class="n">whether</span> <span class="n">an</span> <span class="n">allocator</span> <span class="n">is</span> <span class="n">clean</span>
</span><span class='line'><span class="n">drm_mm_init</span> <span class="err">—</span> <span class="n">initialize</span> <span class="n">a</span> <span class="n">drm</span><span class="o">-</span><span class="n">mm</span> <span class="n">allocator</span>
</span><span class='line'><span class="n">drm_mm_takedown</span> <span class="err">—</span> <span class="n">clean</span> <span class="n">up</span> <span class="n">a</span> <span class="n">drm_mm</span> <span class="n">allocator</span>
</span><span class='line'><span class="n">drm_mm_debug_table</span> <span class="err">—</span> <span class="n">dump</span> <span class="n">allocator</span> <span class="n">state</span> <span class="n">to</span> <span class="n">dmesg</span>
</span><span class='line'><span class="n">drm_mm_dump_table</span> <span class="err">—</span> <span class="n">dump</span> <span class="n">allocator</span> <span class="n">state</span> <span class="n">to</span> <span class="n">a</span> <span class="n">seq_file</span>
</span><span class='line'><span class="n">drm_mm_node_allocated</span> <span class="err">—</span> <span class="n">checks</span> <span class="n">whether</span> <span class="n">a</span> <span class="n">node</span> <span class="n">is</span> <span class="n">allocated</span>
</span><span class='line'><span class="n">drm_mm_initialized</span> <span class="err">—</span> <span class="n">checks</span> <span class="n">whether</span> <span class="n">an</span> <span class="n">allocator</span> <span class="n">is</span> <span class="n">initialized</span>
</span><span class='line'><span class="n">drm_mm_hole_node_start</span> <span class="err">—</span> <span class="n">computes</span> <span class="n">the</span> <span class="n">start</span> <span class="n">of</span> <span class="n">the</span> <span class="n">hole</span> <span class="n">following</span> <span class="n">node</span>
</span><span class='line'><span class="n">drm_mm_hole_node_end</span> <span class="err">—</span> <span class="n">computes</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="n">the</span> <span class="n">hole</span> <span class="n">following</span> <span class="n">node</span>
</span><span class='line'><span class="n">drm_mm_for_each_node</span> <span class="err">—</span> <span class="n">iterator</span> <span class="n">to</span> <span class="n">walk</span> <span class="n">over</span> <span class="n">all</span> <span class="n">allocated</span> <span class="n">nodes</span>
</span><span class='line'><span class="n">drm_mm_for_each_hole</span> <span class="err">—</span> <span class="n">iterator</span> <span class="n">to</span> <span class="n">walk</span> <span class="n">over</span> <span class="n">all</span> <span class="n">holes</span>
</span><span class='line'><span class="n">drm_mm_insert_node</span> <span class="err">—</span> <span class="n">search</span> <span class="k">for</span> <span class="n">space</span> <span class="n">and</span> <span class="n">insert</span> <span class="n">node</span>
</span><span class='line'><span class="n">drm_mm_insert_node_in_range</span> <span class="err">—</span> <span class="n">ranged</span> <span class="n">search</span> <span class="k">for</span> <span class="n">space</span> <span class="n">and</span> <span class="n">insert</span> <span class="n">node</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>CMA Helper Functions Reference</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">drm_gem_cma_create</span> <span class="err">—</span> <span class="n">allocate</span> <span class="n">an</span> <span class="n">object</span> <span class="n">with</span> <span class="n">the</span> <span class="n">given</span> <span class="n">size</span>
</span><span class='line'><span class="n">drm_gem_cma_free_object</span> <span class="err">—</span> <span class="n">free</span> <span class="n">resources</span> <span class="n">associated</span> <span class="n">with</span> <span class="n">a</span> <span class="n">CMA</span> <span class="n">GEM</span> <span class="n">object</span>
</span><span class='line'><span class="n">drm_gem_cma_dumb_create_internal</span> <span class="err">—</span> <span class="n">create</span> <span class="n">a</span> <span class="n">dumb</span> <span class="n">buffer</span> <span class="n">object</span>
</span><span class='line'><span class="n">drm_gem_cma_dumb_create</span> <span class="err">—</span> <span class="n">create</span> <span class="n">a</span> <span class="n">dumb</span> <span class="n">buffer</span> <span class="n">object</span>
</span><span class='line'><span class="n">drm_gem_cma_dumb_map_offset</span> <span class="err">—</span> <span class="k">return</span> <span class="n">the</span> <span class="n">fake</span> <span class="n">mmap</span> <span class="n">offset</span> <span class="k">for</span> <span class="n">a</span> <span class="n">CMA</span> <span class="n">GEM</span> <span class="n">object</span>
</span><span class='line'><span class="n">drm_gem_cma_mmap</span> <span class="err">—</span> <span class="n">memory</span><span class="o">-</span><span class="n">map</span> <span class="n">a</span> <span class="n">CMA</span> <span class="n">GEM</span> <span class="n">object</span>
</span><span class='line'><span class="n">drm_gem_cma_describe</span> <span class="err">—</span> <span class="n">describe</span> <span class="n">a</span> <span class="n">CMA</span> <span class="n">GEM</span> <span class="n">object</span> <span class="k">for</span> <span class="n">debugfs</span>
</span><span class='line'><span class="n">drm_gem_cma_prime_get_sg_table</span> <span class="err">—</span> <span class="n">provide</span> <span class="n">a</span> <span class="n">scatter</span><span class="o">/</span><span class="n">gather</span> <span class="n">table</span> <span class="n">of</span> <span class="n">pinned</span> <span class="n">pages</span> <span class="k">for</span> <span class="n">a</span> <span class="n">CMA</span> <span class="n">GEM</span> <span class="n">object</span>
</span><span class='line'><span class="n">drm_gem_cma_prime_import_sg_table</span> <span class="err">—</span> <span class="n">produce</span> <span class="n">a</span> <span class="n">CMA</span> <span class="n">GEM</span> <span class="n">object</span> <span class="n">from</span> <span class="n">another</span> <span class="n">driver</span><span class="err">&#39;</span><span class="n">s</span> <span class="n">scatter</span><span class="o">/</span><span class="n">gather</span> <span class="n">table</span> <span class="n">of</span> <span class="n">pinned</span> <span class="n">pages</span>
</span><span class='line'><span class="n">drm_gem_cma_prime_mmap</span> <span class="err">—</span> <span class="n">memory</span><span class="o">-</span><span class="n">map</span> <span class="n">an</span> <span class="n">exported</span> <span class="n">CMA</span> <span class="n">GEM</span> <span class="n">object</span>
</span><span class='line'><span class="n">drm_gem_cma_prime_vmap</span> <span class="err">—</span> <span class="n">map</span> <span class="n">a</span> <span class="n">CMA</span> <span class="n">GEM</span> <span class="n">object</span> <span class="n">into</span> <span class="n">the</span> <span class="n">kernel</span><span class="err">&#39;</span><span class="n">s</span> <span class="k">virtual</span> <span class="n">address</span> <span class="n">space</span>
</span><span class='line'><span class="n">drm_gem_cma_prime_vunmap</span> <span class="err">—</span> <span class="n">unmap</span> <span class="n">a</span> <span class="n">CMA</span> <span class="n">GEM</span> <span class="n">object</span> <span class="n">from</span> <span class="n">the</span> <span class="n">kernel</span><span class="err">&#39;</span><span class="n">s</span> <span class="k">virtual</span> <span class="n">address</span> <span class="n">space</span>
</span><span class='line'><span class="k">struct</span> <span class="n">drm_gem_cma_object</span> <span class="err">—</span> <span class="n">GEM</span> <span class="n">object</span> <span class="n">backed</span> <span class="n">by</span> <span class="n">CMA</span> <span class="n">memory</span> <span class="n">allocations</span>
</span></code></pre></td></tr></table></div></figure>


<p>The Contiguous Memory Allocator reserves a pool of memory at early boot that is used to service requests for large blocks of contiguous memory.</p>

<p>The DRM GEM/CMA helpers use this allocator as a means to provide buffer objects that are physically contiguous in memory. This is useful for display drivers that are unable to map scattered buffers via an IOMMU.Memory management</p>
</div>


  <footer>
    
    

    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Mark Zhang</span></span>

      








  


<time datetime="2015-03-02T10:37:00+08:00" pubdate data-updated="true">Mar 2<span>nd</span>, 2015</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/linux-kernel/'>linux-kernel</a>, <a class='category' href='/blog/categories/repost/'>repost</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left articlenav" href="/blog/2015/02/13/iphone6-refund/" title="Previous Post: 转载：我的iphone6退货之路">&laquo; 转载：我的iphone6退货之路</a>
      
      
        <a class="basic-alignment right articlenav" href="/blog/2015/03/02/linux-graphics-stack-notes/" title="Next Post: Linux graphics stack 随便写写">Linux graphics stack 随便写写 &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <!-- JiaThis Button BEGIN -->
<div class="jiathis_style_24x24">
	<a class="jiathis_button_qzone"></a>
	<a class="jiathis_button_tsina"></a>
	<a class="jiathis_button_tqq"></a>
	<a class="jiathis_button_renren"></a>
	<a class="jiathis_button_kaixin001"></a>
	<a href="http://www.jiathis.com/share?uid=1860527" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript">
var jiathis_config = {data_track_clickback:'true'};
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1352426099508779" charset="utf-8"></script>
<!-- JiaThis Button END -->

  </section>


  <section>
    <!-- UY BEGIN -->
<div id="uyan_frame"></div>
<script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=1860527"></script>
<!-- UY END -->

  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Categories</h1>
    <ul id="category-list"><li><a href='/blog/categories/android'>Android (2)</a></li><li><a href='/blog/categories/blog'>Blog (4)</a></li><li><a href='/blog/categories/games'>Games (1)</a></li><li><a href='/blog/categories/git'>git (6)</a></li><li><a href='/blog/categories/hardware'>hardware (1)</a></li><li><a href='/blog/categories/history-science'>History-Science (2)</a></li><li><a href='/blog/categories/life'>Life (1)</a></li><li><a href='/blog/categories/linux'>linux (6)</a></li><li><a href='/blog/categories/linux-kernel'>linux-kernel (11)</a></li><li><a href='/blog/categories/macosx'>MacOSX (6)</a></li><li><a href='/blog/categories/network'>network (13)</a></li><li><a href='/blog/categories/opengl'>OpenGL (4)</a></li><li><a href='/blog/categories/rchelicopter'>RCHelicopter (4)</a></li><li><a href='/blog/categories/repost'>repost (9)</a></li></ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/05/12/build-out-of-tree-kernel-module/">编译out-of-tree的kernel模块</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/05/11/deal-with-git-am-failures/">Git Am失败的时候怎么办</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/04/05/zopo-c7-increase-primary-partition/">卓普大黑（C7、zp990）增大data分区</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/03/04/why-i-leave-chnroutes/">RouterOS：为什么我不用chnroutes</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/03/03/cron/">Linux定时任务 - Cron</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'super119',
            count: 0,
            skip_forks: false,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Mark Zhang -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>&nbsp;&nbsp;
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1000375590'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/z_stat.php%3Fid%3D1000375590%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  











</body>
</html>
