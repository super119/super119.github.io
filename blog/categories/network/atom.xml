<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: network | Make Things Cool]]></title>
  <link href="http://www.markzhang.cn/blog/categories/network/atom.xml" rel="self"/>
  <link href="http://www.markzhang.cn/"/>
  <updated>2014-03-20T22:56:14+08:00</updated>
  <id>http://www.markzhang.cn/</id>
  <author>
    <name><![CDATA[Mark Zhang]]></name>
    <email><![CDATA[super119@139.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[在Ubuntu上连接Juniper SSL VPN]]></title>
    <link href="http://www.markzhang.cn/blog/2014/03/20/juniper-vpn-on-ubuntu/"/>
    <updated>2014-03-20T22:26:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2014/03/20/juniper-vpn-on-ubuntu</id>
    <content type="html"><![CDATA[<p>现在国内很多外企都使用Juniper SSL VPN，来让员工可以在家连入到公司的网络。但是我发现，Juniper的SSL VPN在windows和Mac OS X上都可以很好的工作，但是在Ubuntu上貌似就有问题。就算你正确安装了Java Runtime，打开浏览器，<code>Host Checker</code> 和 <code>Network Connect</code> 也无法正常运行。有人说这是因为现在我们大多使用64位的Ubuntu，而 <code>Host Checker</code> 和 <code>Network Connect</code> 需要32位的浏览器和32位的JRE才能工作。</p>

<p>我没有去深究32位的Ubuntu下是否Juniper VPN就真的可以正常工作了，因为我找到了一个更简单的办法。</p>

<!-- more -->


<p>这个方法来自这位大神，他自己分析了Juniper SSL VPN的工作过程，然后写了一个perl脚本解决了这个问题：</p>

<p><a href="http://smallhacks.wordpress.com/2012/07/15/jvpn-perl-script-to-connect-to-the-juniper-vpn-with-host-checker-enabled/">http://smallhacks.wordpress.com/2012/07/15/jvpn-perl-script-to-connect-to-the-juniper-vpn-with-host-checker-enabled/</a></p>

<p>对原理感兴趣的可以自己去看这篇文章（可能需要翻墙），这里简述一下步骤：</p>

<ul>
<li><p>从上面的文章提供的地址，下载 <code>jvpn-0.7.0.tar.bz2</code>。</p></li>
<li><p>解开，将配置文件 <code>jvpn.ini</code> 拷贝一份以便输入自己的配置，比如：<code>cp jvpn.ini mark.ini</code>，然后编辑这些配置项：</p></li>
</ul>


<p><code>bash
host: 你的VPN server的地址
username: 用户名
realm: 区域，一般的外企应该是 `Employee` 或者 `Contractor`
verifycert: 是否验证SSL证书，如果你本地没有导入你的VPN server的SSL的证书的，可以写0，否则写1
dnsprotect: 这可以防止Ubuntu的NetworkManager修改 `/etc/resolv.conf` 。我们需要修改这个文件从而修改DNS server的配置。
mode: `ncsvc/ncui` 都可以
</code></p>

<ul>
<li>然后就可以执行：<code>sudo perl ./jvpn.pl --conf mark.ini</code>。成功了就可以看到连到了VPN，按 <code>Ctrl+C</code> 可以中断连接。</li>
</ul>


<p><strong> Troubleshooting </strong></p>

<ul>
<li><code>sudo apt-get install libterm-readkey-perl</code>，如果jvpn.pl说 <code>Term::ReadKey module</code> 找不到的话</li>
<li><code>sudo apt-get install lib32z1</code>，如果出现这样的错误： <code>libz.so.1: cannot open shared object file: No such file or directory</code></li>
<li><code>sudo apt-get install gcc-multilib</code>，如果看到这样的错误： <code>bits/predefs.h: No such file or directory</code></li>
<li><code>sudo apt-get install libhttp-request-ascgi-perl</code>，如果jvpn.pl说 <code>HTTP::Request module</code> 找不到的话</li>
</ul>


<p>这样在Ubuntu下，就可以使用Juniper SSL VPN了。很多外企的网络，自带翻墙，所以拨上VPN之后，除了工作之外，还可以实现自动翻墙。配合上chnroute，就完美了。不清楚chnroute有啥作用的，可以看我之前写的一篇文章：</p>

<p><a href="http://markzhang.cn/blog/2013/12/04/chnroutes-on-mac/">Chnroutes的使用（Mac OS X Mavericks）</a></p>

<p>最后附上目前最新版本的jvpn 0.7.0：<a href="/downloads/soft/jvpn-0.7.0.tar.bz2">jvpn-0.7.0.tar.bz2</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chnroutes的使用（Mac OS X Mavericks）]]></title>
    <link href="http://www.markzhang.cn/blog/2013/12/04/chnroutes-on-mac/"/>
    <updated>2013-12-04T14:00:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2013/12/04/chnroutes-on-mac</id>
    <content type="html"><![CDATA[<p>翻墙是我朝人民的普遍需求。现在翻墙的普遍做法是搞一个VPN。买一个也好，找免费的也好。有了VPN之后面临的问题就是当VPN连接之后，所有的网络数据都会走VPN，这显然不是最高效的做法，对于一些没有被墙的网站或是应用，没有必要再走VPN，这样反而更慢。为此，<code>chnroutes</code>应蕴而生了。</p>

<!-- more -->


<p><code>chnroutes</code>就是一份路由表配置，它收集了绝大部分国内没有被墙的网站/IP，然后将他们加到路由表中，设定访问这些IP地址使用原来的网关（非VPN）。这样，在路由表中的IP地址就会走原来的网关，剩下来的就都走VPN了。</p>

<p>在<code>https://code.google.com/p/chnroutes/</code>上下载<code>chnroutes.py</code>，在Mac OS X上运行<code>./chnroutes.py -p mac</code>就得到两个文件：<code>ip-up</code> 和 <code>ip-down</code>。</p>

<p>打开文件一看就明白，没比这更简单的脚本了。<code>ip-up</code>就是使用netstat等命令取到非VPN的网关的IP地址，然后就调用<code>route</code>命令设置一大堆的路由信息。</p>

<p>这里要注意的是，在我的Macbook上（Mac OS X Mavericks），<code>ip-up</code>取到的所谓<code>OLDGW</code>是不对的。<code>ip-up</code>试图去取非VPN的那个网关IP地址，但其实取到的是我所有的网关，也就是包含了VPN的和本地的两个网关IP地址。所以我注释掉了<code>ip-up</code>中获取<code>OLDGW</code>的一行，直接将<code>OLDGW</code>设置成了我本地的网关IP地址。</p>

<p>这样，连接上VPN，然后运行<code>ip-up</code>就可以舒服的上网了。运行<code>ip-down</code>就可以删除掉<code>ip-up</code>添加的路由信息。</p>

<p>为了验证<code>ip-up</code>的确做了我们所想的事情，可以用命令<code>traceroute</code>来验证，比如：<code>traceroute www.youku.com</code>，就可以看到数据是从本地网关走的，而如果是：<code>traceroute www.youtube.com</code>，就可以看到数据是从VPN走的。</p>
]]></content>
  </entry>
  
</feed>
