<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: network | Make Things Cool]]></title>
  <link href="http://www.markzhang.cn/blog/categories/network/atom.xml" rel="self"/>
  <link href="http://www.markzhang.cn/"/>
  <updated>2015-03-03T17:29:12+08:00</updated>
  <id>http://www.markzhang.cn/</id>
  <author>
    <name><![CDATA[Mark Zhang]]></name>
    <email><![CDATA[super119@139.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[RouterOS/远程启动/控制家里的PC]]></title>
    <link href="http://www.markzhang.cn/blog/2014/12/09/ros-rdp-wol/"/>
    <updated>2014-12-09T17:35:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2014/12/09/ros-rdp-wol</id>
    <content type="html"><![CDATA[<h2>远程启动</h2>

<p>远程启动其实就是 <code>WOL(Wake on Lan)</code>，现在的PC机基本上都支持。需要两个东西：</p>

<ul>
<li>在BIOS里面打开 <code>WOL</code></li>
<li>使用一个程序，发送WOL的一个包（所谓magic packet）给PC机</li>
</ul>


<p>先说第一个，在我的PC机上，这个设置是 Advanced Options &ndash;> APM &ndash;> Power on PCIE，设成 <code>Enabled</code> 即可。</p>

<!-- more -->


<p>再说第二个，很酷的是ROS就支持这个，这样你就不需要另外一台PC机常年开着了，ROS路由一直开着即可。在ROS中，打开 <code>New Terminal</code>，输入：</p>

<p><code>bash
/tool wol interface=&lt;连着你要唤醒的PC机的那个网口&gt; mac=&lt;要唤醒PC机的网卡的MAC地址&gt;
</code></p>

<p><img src="/downloads/image/ros-wol.png" alt="ROS Wake on Lan" /></p>

<p>如果你的路由器不是ROS，或是没有WOL功能的话，那就需要另外一台PC来执行WOL的程序了。在Linux下，可以使用：</p>

<p><code>bash
sudo apt-get install etherwake
wakeonlan &lt;mac address&gt;
</code></p>

<p>Windows下也一样，下载一个Wake on Lan的程序使用就行了。</p>

<h2>远程控制</h2>

<p>首先就是打开Windows的远程桌面功能。在 <code>高级系统设置 -&gt; 远程</code> 标签页里面：</p>

<p><img src="/downloads/image/windows-rdp.png" alt="Windows RDP" /></p>

<p>完了就是在ROS里面打开端口映射，这样你才可以从Internet上远程RDP到家里的PC机，需要映射的是著名的3389端口：</p>

<p><code>bash
chain=dstnat action=dst-nat to-addresses=&lt;xxx.xxx.xxx.xxx&gt; to-ports=3389 protocol=tcp dst-port=3389
chain=dstnat action=dst-nat to-addresses=&lt;xxx.xxx.xxx.xxx&gt; to-ports=3389 protocol=udp dst-port=3389
</code></p>

<p>这样就可以远程登录了。Ubuntu下面有自带的 <code>Remmina Remote Desktop</code> 可以使用，Mac下我用的是 <code>Jump Desktop</code>，个人感觉很好用。</p>

<p>最后一个小问题，有关远程登录机器开始菜单中没有 <code>关机</code> 这个功能，只需要打开 <code>Windows CMD</code>，也就是命令行界面，输入：</p>

<p><code>bash
shutdown /f /s
</code></p>

<p>就可以了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RouterOS配置记录（四）：OpenVPN Client]]></title>
    <link href="http://www.markzhang.cn/blog/2014/09/01/ros-openvpn/"/>
    <updated>2014-09-01T15:42:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2014/09/01/ros-openvpn</id>
    <content type="html"><![CDATA[<p>OpenVPN是现在使用相当广泛的一种VPN solution。它不使用特定协议（比如PPTP依赖于GRE协议，如果GRE协议被墙，PPTP就完了），也不使用特定端口，TCP/UDP都支持，性能表现也相当优异（UDP）。所以现在使用OpenVPN作为VPN的solution很多，在Mikrotik的论坛上可以找到大量赞美OpenVPN的帖子。</p>

<p>但是，事实上当我把OpenVPN全部配置完成之后，发现两个问题：</p>

<!-- more -->


<ul>
<li>OpenVPN已被墙，应该就是2013年（或者更早）的事情。虽然上面提到了OpenVPN不使用特定协议，不使用特定端口，但是聪明的GFW还是找到了OpenVPN TLS验证时的特征并墙之。所以如果你辛辛苦苦配置好了服务器端和客户端，客户端拨号的时候发现："Peer disconnected/Connection reset"，那就是被墙的标志。OpenVPN TLS验证的时候，连接直接被reset了。</li>
</ul>


<p>针对这个问题，当然也有解决方案，那就是模糊TLS验证的数据，让GFW寻不到TLS的特征，比如：</p>

<p><a href="http://igfw.net/archives/13018">http://igfw.net/archives/13018</a></p>

<p>但是这种做法是没法在ROS上实现的。因为这要求修改OpenVPN sever和client的代码，而我们是无法修改ROS中的OpenVPN的实现的。</p>

<ul>
<li>ROS不支持UDP模式的OpenVPN。这个已经被广大ROS用户诟病已久，但不知道为什么Mikrotik就是不改：</li>
</ul>


<p><a href="http://forum.mikrotik.com/viewtopic.php?f=1&amp;t=26499">http://forum.mikrotik.com/viewtopic.php?f=1&amp;t=26499</a></p>

<p>TCP模式的OpenVPN延迟（latency）很高，不适合诸如电话会议、在线游戏等场景。</p>

<p>所以坦白说，有上述的两个问题，ROS+OpenVPN，已经没有太多的使用价值了。但是既然我已经将其配置完成了，所以本文还是将过程记录了下来。</p>

<h2>OpenVPN server侧配置</h2>

<p>OpenVPN server侧的配置稍微复杂一些，关键是要生成一堆证书、秘钥。但是也不是复杂到没法忍，关键是要有一篇好的turtorial。所以这里是我找到的一篇很好的文章，照做就行：</p>

<p><a href="https://www.linode.com/docs/networking/vpn/secure-communications-with-openvpn-on-ubuntu-12-04-precise-and-debian-7">Secure communications with OpenVPN on Ubuntu 12.04</a></p>

<p>照着上面的文章做就可以了，这里再给出我最终的OpenVPN server的配置文件作为一个参考：</p>

<p>``` bash
port 3389
proto tcp
dev tun</p>

<h1>Keys</h1>

<p>ca /etc/openvpn/easy-rsa/2.0/keys/ca.crt
cert /etc/openvpn/easy-rsa/2.0/keys/server.crt
key /etc/openvpn/easy-rsa/2.0/keys/server.key
dh /etc/openvpn/easy-rsa/2.0/keys/dh1024.pem</p>

<h1>This will be the internal tun0 connection IP</h1>

<p>server 10.8.0.0 255.255.255.0
ifconfig-pool-persist ipp.txt</p>

<h1>This will send all of a client&rsquo;s 10.x.x.x traffic through the VPN</h1>

<h1>push &ldquo;route 10.0.0.0 255.0.0.0&rdquo;</h1>

<p>keepalive 10 120</p>

<h1>Mikrotik does not support LZO compression</h1>

<h1>comp-lzo</h1>

<p>auth SHA1</p>

<h1>Select a cryptographic cipher.</h1>

<h1>cipher BF-CBC        # Blowfish (default)</h1>

<p>cipher AES-256-CBC</p>

<h1>user nobody</h1>

<h1>group nogroup</h1>

<p>status /var/log/openvpn/openvpn-status.log</p>

<p>persist-key
persist-tun
verb 3
```</p>

<p>几点解释：</p>

<ol>
<li>ROS的OpenVPN client只支持TCP，所以这里使用TCP模式：<code>proto tcp</code>。</li>
<li>被注释的那句：<code>push "route 10.0.0.0 255.0.0.0"</code> 是可以用来给客户端设置路由表的，但是由于我的ROS有chnroutes，所以我会在我的ROS上设置路由表，所以我的OpenVPN server侧就没有push路由表给客户端了。</li>
<li><code>comp-lzo</code> 一定要注释掉，这是因为ROS OpenVPN client不支持这个。所以ROS的OpenVPN UDP不支持，数据压缩又不支持，你就可以想想Mikrotik论坛上大家的怨气有多大了。有空可以上去搜看相关的帖子，相当欢乐。</li>
<li>有关cipher，Blowfish, AES这些ROS OpenVPN client都是支持的，所以可以自由选择。使用默认的Blowfish就挺好。</li>
<li>最后的 <code>verb 3</code> 可以改成诸如 <code>verb 6</code>，这样在 <code>/var/log/syslog</code> 中可以得到很多的log，客户端连不上OpenVPN server的时候，可以帮助调试和定位。</li>
</ol>


<p>配置完成之后，<code>sudo service openvpn restart</code>，OpenVPN server就ready了。</p>

<h2>OpenVPN client侧配置（ROS）</h2>

<p>相比server侧，ROS上client的配置就相对简单了很多。</p>

<p>首先是上传证书和秘钥到ROS上：</p>

<p><img src="/downloads/image/ros-system-certificates.png" alt="Certificates" /></p>

<p>这里其实是3个文件，client的公钥和私钥，还有就是server的证书，这三个文件首先upload到ROS上，然后在上图中点击 <code>Import</code> 按钮就可以导入了。</p>

<p>然后就是创建一个OpenVPN的client了：</p>

<p><img src="/downloads/image/ros-ppp-openvpn.png" alt="PPP Create OpenVPN Client" /></p>

<p>几点说明：</p>

<ol>
<li><code>Connect To</code> 和 <code>Port</code> 不用说了</li>
<li><code>Mode</code> ，这个有两个选项：<code>IP</code> 和 <code>Ethernet</code>，这表示数据是走layer 3还是layer 2，反映到VPN创建出来的本地虚拟网卡，就是tun还是tap，一般来说OpenVPN都是tun，所以这里是选择 <code>IP</code>。如果你使用PPTP，就可以看到虚拟网卡是tap。</li>
<li><code>User</code>，这个其实不需要，因为OpenVPN是使用证书来识别client的，每个client都会有一个证书。但是这里ROS需要填一个用户名，所以随便填一个就好（貌似OpenVPN也可以支持username/password的那种验证的，我没去调查）。</li>
<li><code>Profile</code>，因为在下面会选择加密方式等，所以profile就选default就好，default意思就是按照server的默认设置来。</li>
<li><code>Certificate</code>，这里要选择你upload到ROS上的，client的私钥，这个私钥是用来解密数据的。</li>
<li><code>Auth</code> / <code>Cipher</code>，这个就选成跟server端的配置一致即可。</li>
</ol>


<h2>结束</h2>

<p>所以总的来说，OpenVPN的配置并不复杂，只是ROS不支持UDP的OpenVPN，所以用来翻墙看看网页还是可以的，玩游戏啥的就要差不少。不过OpenVPN作为一个free的，性能优良的VPN solution，在国内网络中使用也是相当不错的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RouterOS配置记录（三）：DDNS]]></title>
    <link href="http://www.markzhang.cn/blog/2014/08/21/ros-ddns/"/>
    <updated>2014-08-21T15:26:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2014/08/21/ros-ddns</id>
    <content type="html"><![CDATA[<p>配置动态DNS主要是为了能让你的RouterBoard在Internet上被访问到，这样我就可以远程控制我的RouterBoard，同时也可以开始做端口映射，在内网做server&hellip;等。</p>

<p>在ROS上配置DDNS非常简单，就是写一个script然后放到ROS的 <code>System</code> &ndash;> <code>Scheduler</code> 中就好了。不过在此之前，先去申请一个DDNS，我用的是3322的。</p>

<p>不过在开始之前，你要先确保你的宽带连接拨号之后，得到的是一个真实的IP地址。现在电信/联通/移动宽带有的时候拨号会得到一个假IP地址，比如 <code>192.168.x.x</code>，<code>10.x.x.x</code>，甚至之前我得到过 <code>100.x.x.x</code>，这个也不是真实的IP地址（RFC编号为6598。RFC 6598 &ndash; IANA-Reserved IPv4 Prefix for Shared Address Space）。判断自己拨号得到的IP是否是真实IP很简单，打开 www.ipaddress.com，网站会告诉你你目前的IP地址，把这个IP跟你在ROS里面看到的你拨号得到的IP比较是不是一样就知道了。</p>

<p>如果你得到的不是真实的IP地址，那就说明在运营商那边还有一层NAT，那么你做DDNS就没有用了，除非你用花生壳客户端这种专门的软件，但是花生壳客户端软件是没法装在ROS上的。可以打电话给宽带运营商投诉，让它给你分配真实的IP地址，如果它不从你可以打工信部电话投诉（我没试过，网友们说可以）。</p>

<!-- more -->


<p>所以先来看一下这个script是长什么模样：</p>

<p>``` bash
:global ednsuser &ldquo;xxxxxxxx&rdquo;
:global ednspass &ldquo;xxxxxxxx&rdquo;
:global ednshost &ldquo;xxxxxxxx.3322.org&rdquo;
:global ednsinterface &ldquo;SHUnicom&rdquo;
:global members &ldquo;<a href="http://members.3322.net/dyndns/update?system=dyndns">http://members.3322.net/dyndns/update?system=dyndns</a>&rdquo;
:global status
:global status [/interface get [/interface find name=$ednsinterface] running]</p>

<p>:if ($status!=false) do={
:global ednslastip [:resolve $ednshost]
:if ([ :typeof $ednslastip ] = nil ) do={ :global ednslastip &ldquo;0&rdquo; }
:global ednsiph [ /ip address get [/ip address find interface=$ednsinterface ] address ]
:global ednsip [:pick $ednsiph 0 [:find $ednsiph &ldquo;/&rdquo;]]
:global ednsstr &ldquo;&amp;hostname=$ednshost&amp;myip=$ednsip&rdquo;
:if ($ednslastip != $ednsip) do={
/tool fetch url=&ldquo;$members$ednsstr&rdquo; mode=http user=$ednsuser password=$ednspass dst-path=$ednshost
:delay 4
:global result [/file get $ednshost contents]
:log info ($ednshost . &ldquo; &rdquo; .$result)
/file remove $ednshost ;
}
}
```</p>

<p>以上script来自：<a href="http://h2appy.blog.51cto.com/609721/776837">ROS DDNS update script</a></p>

<p>修改一下 <code>ednsuser</code>/<code>ednspass</code>/<code>ednshost</code>就可以使用了。</p>

<p>简单来说这个script就是利用ROS的 <code>/tool fetch</code> 来访问一个网页：</p>

<p><a href="http://members.3322.net/dyndns/update?system=dyndns&amp;hostname=xxx&amp;myip=xxx">http://members.3322.net/dyndns/update?system=dyndns&amp;hostname=xxx&amp;myip=xxx</a></p>

<p>这个方法也是3322官方提供的，3322的server就可以从这个http请求中得到你的真实IP地址了。</p>

<p>然后就是来到ROS的 <code>System</code> &ndash;> <code>Scheduler</code>，点击加号按钮：</p>

<p><img src="/downloads/image/ros-system-scheduler.png" alt="ROS Add scheduler" /></p>

<p>把上面的你修改好的script贴到 <code>OnEvent</code> 那个编辑框里面，设定好名字和Interval就OK了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RouterOS配置记录（二）：chnroutes]]></title>
    <link href="http://www.markzhang.cn/blog/2014/08/20/ros-chnroutes/"/>
    <updated>2014-08-20T16:52:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2014/08/20/ros-chnroutes</id>
    <content type="html"><![CDATA[<p>之前写过一篇博客：Chnroutes的使用（Mac OS X Mavericks），讲述了在我的macbook pro上安装chnroutes，从而可以在上网的时候区分国内国外的IP，最终让国外的IP访问走VPN，国内的不走VPN。</p>

<p><a href="http://markzhang.cn/blog/2013/12/04/chnroutes-on-mac/">Chnroutes的使用（Mac OS X Mavericks）</a></p>

<p>现在有了ROS，事情就变的更加棒了，把chnroutes做在ROS上，那所有的网络设备就自动具备了chnroutes的功能。所以在刚配置好了ROS之后，我就尝试配置了chnroutes。</p>

<!-- more -->


<p>首先我的配置参考了这篇文章：</p>

<p><a href="http://autorosvpn.blogspot.jp/2013/05/ros-vpn.html">ros智能vpn自动翻墙</a></p>

<p>总的说来，在ROS上配置chnroutes，就是几个步骤：</p>

<ol>
<li>导入国内IP地址表</li>
<li>对每个请求中的IP进行查找，如果不在国内IP地址列表中的，就标记一下</li>
<li>在路由表中，根据标记，让数据走正常网关或是VPN</li>
</ol>


<h2>导入国内IP地址表</h2>

<p>这个其实非常简单，用VI就搞定了。首先根据我之前的文章：Chnroutes的使用（Mac OS X Mavericks），在我的MBP上运行 <code>./chnroutes.py -p mac</code>，就会生成ip-up/ip-down这两个文件。</p>

<p>ip-up文件里面就包含了所有的国内IP地址，所以接下来我们只需要将这个文件修改成ROS能认识的格式就行了，用VI就可以轻松搞定了。这里给出一个我目前在使用的（2014/7/22的数据）：</p>

<p><a href="/downloads/file/chinasites.rsc">2014/7/22 国内IP地址列表</a></p>

<p>一般来说，这个列表不需要经常更新，在IPv4地址已经差不多消耗殆尽的今天，你能经常访问到新的属于国内的IP地址也不是件容易的事情。</p>

<p>接下来就是把这个 <code>chinasites.rsc</code> 上传到RouterBoard上就OK了，可以用Filezilla，使用FTP的方式。或者你如果是windows平台，使用WinBox的话，也可以用拖拽的方式将文件拖到ROS的 <code>Files</code> 对话框中即可。</p>

<p>上传了之后，点击ROS的 <code>New Terminal</code>，在命令行下输入：<code>import chinasites.rsc</code>，所有的国内IP地址列表就导入了，在ROS的 <code>IP</code> &ndash;> <code>Firewall</code> &ndash;> <code>Address Lists</code> 中就可以看到：</p>

<p><img src="/downloads/image/ros-ip-firewall-address-lists.png" alt="China IP address list" /></p>

<p>在上图中可以看到，我们给这些IP地址都设了一个名字叫做 <code>novpn</code>，表示路由这些地址的时候，不需要走VPN，后面会看到如何使用的。</p>

<h2>标记Packets</h2>

<p>这是Linux netfilter/iptables非常强大的功能体现了，首先来看在ROS里面是怎么配置的：</p>

<p>``` bash
Flags: X &ndash; disabled, I &ndash; invalid, D &ndash; dynamic
 0   chain=prerouting action=mark-routing new-routing-mark=vpn passthrough=yes</p>

<pre><code> dst-address=!192.168.88.0/24 dst-address-list=!novpn 
</code></pre>

<p>```</p>

<p>这个配置项位于：<code>IP</code> &ndash;> <code>Firewall</code> &ndash;> <code>Mangle</code>。首先这个配置针对的是 <code>prerouting</code> 表，对Mangle/Prerouting还不清楚的，看我的这篇文章：</p>

<p><a href="http://markzhang.cn/blog/2014/07/23/netfilter-overview/">Linux Netfilter overview</a></p>

<p>然后，<code>dst-address-list=!novpn</code> 其实意思就是，如果目的地址不在 <code>novpn</code> 这个address list中的；最后 <code>action=mark-routing new-routing-mark=vpn</code> 就表示如果目的地址不在 <code>novpn</code> 中的，就给这些packet打上一个名为 <code>vpn</code> 的routing标记。</p>

<p>当然，上述命令中的：<code>dst-address=!192.168.88.0/24</code>，这表示本地局域网的地址不受该条规则影响，这也是非常好理解的。</p>

<p>所以总结来说，我们通过Linux netfilter的Mangle功能，成功的给不属于国内IP地址列表中的packet，打上了一个名为 <code>vpn</code> 的路由标记。</p>

<p>这里需要提一下 <code>passthrough=yes</code> 这个东西的作用。<code>passthrough=yes</code> 表示packet经过了本规则的处理之后，还会继续往下传递，给下面的rules继续处理。相反的例子是 <code>IP</code> &ndash;> <code>Firewall</code> &ndash;> <code>Fliter</code> 中的规则，比如 <code>accept</code> 或者 <code>drop</code> ，一旦匹配到了这些规则，就不会再继续往下处理了（下面的规则就不会再去执行了），所以这就是为什么我在上篇文章中提到说有一条 <code>drop</code> 的规则一定要放在最后。</p>

<p>所以这里我们设置了 <code>passthrough=yes</code> ，表示位于我们本条规则之后的规则还有机会继续被得到执行，所以你可以继续添加标记类的规则，或者其他任何Mangle的规则。所以再次重申，在Filter/Mangle这些表里，规则的顺序是很有影响的。</p>

<h2>添加路由</h2>

<p>点击 <code>IP</code> &ndash;> <code>Routes</code>，在 <code>Routes</code> 标签页，点击加号按钮添加一条路由规则：</p>

<p><img src="/downloads/image/ros-ip-routes.png" alt="ROS add routing" /></p>

<ul>
<li><p>Dst. Address，这表示哪些目的IP地址受这条路由影响，这里填写 <code>0.0.0.0/0</code> 表示所有IP地址。</p></li>
<li><p>Gateway，这表示这条路由走哪个Interface，一般来说，这就是你的VPN的PPP连接了。</p></li>
<li><p>Distance，这表示这条路由的权重。在之前的一篇介绍ROS的基础设置的文章中，有说到我们添加了一个PPPoE client来实现宽带拨号，在创建那个PPPoE Client的时候，有一个选项叫做：<code>Default Route Distance</code>，我的这项设置是10，而如上图所示，现在我们添加的这条路由，我的设置是1。其实很好理解，我们在添加PPPoE Client的时候，有选择 <code>Add Default Route</code>，所谓Default route就是路由所有IP地址：<code>0.0.0.0/0</code>的，那么现在我们又添加了一条路由，也是路由所有IP地址的，那应该选哪条路由呢？这就是根据路由的Distance来决定的。Distance值越小的，权重越高。</p></li>
<li><p>Routing Mark，这里填写的是 <code>vpn</code>。</p></li>
</ul>


<p>所以总结来说，这条路由的作用就是，对于 <code>Routing Mark</code> 是 <code>vpn</code> 的packet，走我们指定的 <code>Gateway</code>。而且由于这条路由的权重高于默认路由，所以就实现了非国内的IP地址，走我们指定的Gateway，而国内的IP地址还是走默认路由（宽带连接的那条路由）。</p>

<p>写了一堆字，其实做一下就是两分钟的事。ROS的确是非常Power的东西。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RouterOS 配置记录（一）：基础设置]]></title>
    <link href="http://www.markzhang.cn/blog/2014/08/19/ros-basic-setup/"/>
    <updated>2014-08-19T14:38:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2014/08/19/ros-basic-setup</id>
    <content type="html"><![CDATA[<p>RouterOS（以下简称ROS）是一个软路由系统，由拉脱维亚的Mikrotik开发，完全基于Linux。项目刚开始的时候，只支持x86，所以我们可以找一台PC机来安装ROS，从而可以让PC机瞬间变身成一个软路由。</p>

<p>后来Mikrotik开发了专用的硬件设备：RouterBoard。RouterBoard是MIPS架构，运行ROS，所以不想搞一台PC机的话，买一台RouterBoard就显的非常不错。而且RouterBoard有好多型号，带wifi的不带wifi的，企业用的个人用的，千兆的百兆的。。。，最关键的是家用的RouterBoard，带wifi的也不贵，所以最近就把家里的路由器换成了RouterBoard，型号是：951Ui-2HnD。</p>

<p>本系列文章旨在记录我在使用ROS的时候的一些配置，之前已经写了一篇有关修改WinBox字体的文章，算是个引子。ROS虽然强大，但是配置项目的繁杂也颇为吓人，坦白说没有网络基础的话还是别用ROS。</p>

<!-- more -->


<p>本文讲述拿到RouterBoard之后的最基础配置，也就是配置宽带拨号，WIFI，NAT，DHCP，最终能让家里的各网络设备上网。</p>

<h2>宽带拨号</h2>

<p>RouterBoard第一次开机，winbox连入之后，会有一个提示让我们备份当前的配置或是删掉目前的配置，为了从头开始，我删掉了原来的所有配置，从头开始一步一步自己来。</p>

<p>配置宽带拨号非常简单，就是在 <code>PPP</code> 里面添加一个 <code>PPPoE Client</code> 的interface即可：</p>

<p><img src="/downloads/image/ros-pppoe-client.png" alt="ROS add PPPoE client" /></p>

<p>必须要填的会以红色表示，在上图中，要填的是Name和Interfaces。Interfaces指的是哪个网口连接了宽带网线，一般来说，RouterBoard的第一个网口我们都用来连接外网（WAN），所以选择第一个网口即可（如上图所示，我给第一个网口做了重命名，修改名称为ether1-wan）。在第二个标签页 <code>Dial Out</code> 中，就需要填写你的宽带账号和密码了，此外 <code>Use Peer DNS</code> 和 <code>Add Default Router</code> 也可以勾选上。</p>

<p><code>Use Peer DNS</code> 指的是是否使用宽带运营商提供的DNS（在PPPoE拨号的时候能得到），一般都需要使用，当然你也可以不用运营商提供的DNS，自己定义一些DNS server，比如Google的 <code>8.8.8.8</code>, <code>8.8.4.4</code>，还有OpenDNS的 <code>208.67.222.222</code>, <code>208.67.220.220</code>。只是使用这些DNS的话，你要先把翻墙准备好。</p>

<p>在Winbox的 <code>IP</code> &ndash;> <code>DNS</code> 里面，就可以自己设置DNS server：</p>

<p><img src="/downloads/image/ros-ip-dns.png" alt="ROS DNS setting" /></p>

<p>在上图中可以看到，<code>Dynamic Servers</code> 就是来自宽带运营商的DNS server信息。</p>

<p>而 <code>Allow Remote Requests</code> 指的是，RouterBoard本身是否也作为一个DNS server从而可以响应DNS查询请求。一般来说，这个应该enable。顺理成章的，下面的一些有关Cache的配置也就变的有意义了，如上图所示，我加大了Cache的size，从而可以多缓存一些DNS信息。不过在enable了 <code>Allow Remote Request</code> 之后，需要注意要打开TCP/UDP的DNS端口，以防客户端无法通过RouterBoard查询DNS。</p>

<p>回到宽带拨号，配置好了 <code>PPPoE Client</code> 之后，就可以尝试去enable它了，一旦连接成功，就表示你的宽带拨号已经OK了。</p>

<h2>WIFI</h2>

<p>打开 <code>Wireless</code> ，在Interface标签页，可以看到一个wireless interface，默认名字是wlan1，关键的配置在标签页 <code>Wireless</code>：</p>

<p><img src="/downloads/image/ros-wireless.png" alt="ROS Wirelss config" /></p>

<p>大部分都非常好理解，有几个地方需要注意：</p>

<ul>
<li>Channel Width，这里有所谓的HT Above和HT Below，有关这个的解释是（来自Mikrotik官方）：</li>
</ul>


<blockquote><p>ht above and ht below allows to use additional 20MHz extension channel and if it should be located below or above control (main) channel. Extension channel allows 11n device to use 40MHz of spectrum in total thus increasing max throughput.</p></blockquote>

<p>不过需要注意的是，不是所有的Frequency都可以设置Above/Below，这里有一张来自Mikrotik的表说明了这一点，所以最终在设置Frequency的时候需要注意：</p>

<p><img src="/downloads/image/ros-wireless-ht-above-below.png" alt="ROS wireless HT above/below setting" /></p>

<ul>
<li><p>Frequency，上面已经提到了，设置Frequency要注意HT Above/Below是否有取值，此外可以通过点击 <code>Scan</code> 按钮来查看当前环境中有哪些Frequency是被占用的，尽量挑选一个没人使用的频率吧。</p></li>
<li><p>Wireless Protocol，Mikrotik开发了一些自己私有的WIFI协议，比如这里看到的NV2等，对于我们来说，肯定是使用802.11了。</p></li>
<li><p>Security Profile，这个后面紧接着就要配置，就是在这个profile中，我们可以配置WIFI的加密方式（WPA/WEP等）。</p></li>
<li><p>Bridge Mode，要选成Enabled，后面会提到，为了让WIFI的clients能和RouterBoard上的几个以太网口通信，需要将它们都放到一个bridge中。</p></li>
</ul>


<p>接下来就要配置WIFI Security Profile了，如下图所示：</p>

<p><img src="/downloads/image/ros-wireless-security-profile.png" alt="ROS wireless security profile" /></p>

<p>在 <code>Security Profile</code> 标签页中，点击加号按钮就可以新建一个 <code>Security Profile</code> 了。上图中我们配置的security profile name是default，所以在刚才我们设置Wireless Interface的时候，<code>Security Profile</code> 一项我们选择的就是这个 <code>default</code>。</p>

<p>配置到这里，WIFI热点就配置完成了，接下来我们需要将WIFI的wlan1这个interface和以太网的四个端口（第一个端口ether1-wan我们是分配给了宽带连接）放到一个bridge中去，这样才可以实现WIFI的clients和这四个以太网口互通。</p>

<p>在配置Bridge的时候，其实有两个配置步骤，顾名思义Bridge肯定只能包含两个Interface（Bridge的两端），而我们需要将wlan1和四个以太网口都配置到Bridge上去，那怎么办？</p>

<p>所以第一步是，将以太网口3/4/5都配置成以太网口2的 <code>Slave Port</code>，如下图所示：</p>

<p><img src="/downloads/image/ros-interface-master-port.png" alt="ROS interface master port" /></p>

<p>点击 <code>Interfaces</code>，在出来的对话框的 <code>Interface</code> 标签页，点击以太网口3/4/5就可以看到上图。在上图中可以看到，我们将以太网口3（ether3）的 <code>Master Port</code> 这一项选成了 <code>lan-ps3</code>。这里解释一下，<code>lan-ps3</code> 就是我的第二个以太网口，因为这个网口接着我的PS3，所以我给它取名为 <code>lan-ps3</code>。</p>

<p>将3/4/5以太网口设置成以太网口2的Slave Port之后，就可以创建Bridge了，点击 <code>Bridge</code>，在出来的对话框的 <code>Bridge</code> 标签页中，点击加号新建一个Bridge，啥都不需要修改，只需要给个名字就OK了。关键是在标签页 <code>Ports</code> 中，点击加号按钮，将wlan1和lan-ps3加入到Bridge中去：</p>

<p><img src="/downloads/image/ros-bridge-ports.png" alt="ROS Bridge ports" /></p>

<p>这样就OK了，WIFI部分的配置就差不多了。</p>

<h2>NAT</h2>

<p>但凡搞过Linux iptables的都知道了，input/forward/output，pre-route/post-route&hellip;，对这些概念不清楚的可以看我这篇文章：</p>

<p><a href="http://markzhang.cn/blog/2014/07/23/netfilter-overview/">Linux Netfilter overview</a></p>

<p>说起来配置一个简单的能上网的NAT非常的简单，选择 <code>IP</code> &ndash;> <code>Firewall</code>，在 <code>NAT</code> 标签页里面点击加号按钮，添加一个NAT：</p>

<p><img src="/downloads/image/ros-ip-firewall-nat.png" alt="ROS add NAT" /></p>

<p>总共就只需要做三件事情：Chain选成srcnat（表示伪装源地址），Out Interface选成宽带连接那个PPPoE client，最后在 <code>Action</code> 标签页里面选择动作为：masquerade。</p>

<p>这样就表示所有的packet，在经过路由表之后，如果最终经过路由决定要从 <code>Out Interface</code> 这个接口出去的话，就做masquerade。</p>

<h2>DHCP Server</h2>

<ul>
<li>首先是创建一个IP Pool。点击 <code>IP</code> &ndash;> <code>Pool</code>，然后新建一个Pool：</li>
</ul>


<p><img src="/downloads/image/ros-ip-pool.png" alt="ROS create IP pool" /></p>

<p>就是填写一个名字，一个IP地址范围即可，比如我这里设置的就是192.168.88.2-192.168.88.254，RouterBoard自己就是192.168.88.1了。</p>

<ul>
<li>然后就是创建一个DHCP server了，来到 <code>IP</code> &ndash;> <code>DHCP Server</code>，点击加号按钮创建一个DHCP Server:</li>
</ul>


<p><img src="/downloads/image/ros-ip-dhcp-server.png" alt="ROS Create DHCP server" /></p>

<p>需要注意的就是，首先 <code>Interface</code> 那一项要选成你的Bridge device，这样WIFI和以太网的网络client就都可以DHCP了；其次 <code>Address Pool</code> 那一项就选我们刚才创建的那个IP Pool。</p>

<ul>
<li>最后设定DHCP Server的Network的一些信息，还是在DHCP Server的对话框中，选 <code>Networks</code> 那个标签页，点击加号按钮：</li>
</ul>


<p><img src="/downloads/image/ros-ip-dhcp-server-networks.png" alt="ROS DHCP server networks" /></p>

<p>可以看到，这其实就是设定网关和DNS Server的。上图中，对于192.168.88.0/24这个网络的DHCP，clients自动获得了IP地址之后，获得的网关就是192.168.88.1，DNS也是192.168.88.1。联想到一开始的时候提到的 <code>IP</code> &ndash;> <code>DNS</code> 的设定，网络客户端知道DNS Server是RouterBoard就是在这里设定的。</p>

<h2>最后</h2>

<p>最后我们还可以配置一些简单的防火墙规则，用来拦截来自外网的请求，这里用命令行的方式来展现，这些规则都是配置在：<code>IP</code> &ndash;> <code>Firewall</code> &ndash;> <code>Filter</code> 里面的，非常简单：</p>

<p>``` bash
Flags: X &ndash; disabled, I &ndash; invalid, D &ndash; dynamic
 0   chain=input action=accept protocol=icmp</p>

<p> 1   chain=input action=accept connection-state=established</p>

<p> 2   chain=input action=accept connection-state=related</p>

<p> 3   chain=input action=accept protocol=tcp dst-port=22</p>

<p> 4   chain=input action=accept protocol=tcp dst-port=8291</p>

<p> 5   chain=input action=accept protocol=tcp dst-port=3987</p>

<p> 6   chain=input action=accept protocol=tcp dst-port=80</p>

<p> 7  chain=input action=accept protocol=tcp dst-port=53</p>

<p> 8   chain=input action=accept protocol=udp dst-port=53</p>

<p> 9   chain=input action=drop in-interface=SHUnicom
```</p>

<p>打开22端口是为了可以远程ssh RouterBoard，打开8291/3987/80端口是为了可以远程使用WinBox登录（可以额外添加src-address来限定只允许某个IP地址登录，这样可以增强安全性），接受53端口是为了DNS查询（实际上DNS一般都是使用UDP，TCP不需要打开），最后一条就是拦截所有外部的网络请求，请确保这一条一定位于所有规则的最后，iptables是匹配到一条规则之后就会返回的，所以如果这条不出现在最后，那么这一条之后的所有规则都会无法生效。</p>

<p>这个最后一条规则，可以看到，是说如果是从 <code>SHUnicom</code> 这个接口进来的数据一律drop，而 <code>SHUnicom</code> 是我的宽带连接接口。想到这个宽带连接其实是在我的ether1-wan这个物理接口上，那么这里是否也可以设置成从 <code>ether1-wan</code> 接口进来的数据一律drop呢？仔细想想是不对的，<code>ether1-wan</code> 是物理接口，用于宽带拨号；而 <code>SHUnicom</code> 其实是一个PPPoE，它会创建一个虚拟的网卡interface，所以我们要drop的是从这个虚拟的网卡interface尝试进入RouterBoard的数据，而不是物理的 <code>ether1-wan</code> 上进入的数据。如果我们真的drop了 <code>ether1-wan</code> 上进来的数据，那就上不了网了，因为所有的返回的数据都被丢掉了。在PPPoE/VPN的时候，虚拟网卡会被创建，所以这个时候要分清楚虚拟网卡和物理网卡，免的设置错误的规则。</p>

<p>能上网只是最基本需求了，接下来才是开始各种折腾的时候，VPN/chnroutes/DDNS/&hellip; 后续博客将记录这些。</p>
]]></content>
  </entry>
  
</feed>
