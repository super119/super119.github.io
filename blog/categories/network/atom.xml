<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: network | Make Things Cool]]></title>
  <link href="http://www.markzhang.cn/blog/categories/network/atom.xml" rel="self"/>
  <link href="http://www.markzhang.cn/"/>
  <updated>2014-08-20T18:08:30+08:00</updated>
  <id>http://www.markzhang.cn/</id>
  <author>
    <name><![CDATA[Mark Zhang]]></name>
    <email><![CDATA[super119@139.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[RouterOS配置记录（二）：chnroutes]]></title>
    <link href="http://www.markzhang.cn/blog/2014/08/20/ros-chnroutes/"/>
    <updated>2014-08-20T16:52:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2014/08/20/ros-chnroutes</id>
    <content type="html"><![CDATA[<p>之前写过一篇博客：Chnroutes的使用（Mac OS X Mavericks），讲述了在我的macbook pro上安装chnroutes，从而可以在上网的时候区分国内国外的IP，最终让国外的IP访问走VPN，国内的不走VPN。</p>

<p><a href="http://markzhang.cn/blog/2013/12/04/chnroutes-on-mac/">Chnroutes的使用（Mac OS X Mavericks）</a></p>

<p>现在有了ROS，事情就变的更加棒了，把chnroutes做在ROS上，那所有的网络设备就自动具备了chnroutes的功能。所以在刚配置好了ROS之后，我就尝试配置了chnroutes。</p>

<!-- more -->


<p>首先我的配置参考了这篇文章：</p>

<p><a href="http://autorosvpn.blogspot.jp/2013/05/ros-vpn.html">ros智能vpn自动翻墙</a></p>

<p>总的说来，在ROS上配置chnroutes，就是几个步骤：</p>

<ol>
<li>导入国内IP地址表</li>
<li>对每个请求中的IP进行查找，如果不在国内IP地址列表中的，就标记一下</li>
<li>在路由表中，根据标记，让数据走正常网关或是VPN</li>
</ol>


<h2>导入国内IP地址表</h2>

<p>这个其实非常简单，用VI就搞定了。首先根据我之前的文章：Chnroutes的使用（Mac OS X Mavericks），在我的MBP上运行 <code>./chnroutes.py -p mac</code>，就会生成ip-up/ip-down这两个文件。</p>

<p>ip-up文件里面就包含了所有的国内IP地址，所以接下来我们只需要将这个文件修改成ROS能认识的格式就行了，用VI就可以轻松搞定了。这里给出一个我目前在使用的（2014/7/22的数据）：</p>

<p><a href="/downloads/file/chinasites.rsc">2014/7/22 国内IP地址列表</a></p>

<p>一般来说，这个列表不需要经常更新，在IPv4地址已经差不多消耗殆尽的今天，你能经常访问到新的属于国内的IP地址也不是件容易的事情。</p>

<p>接下来就是把这个 <code>chinasites.rsc</code> 上传到RouterBoard上就OK了，可以用Filezilla，使用FTP的方式。或者你如果是windows平台，使用WinBox的话，也可以用拖拽的方式将文件拖到ROS的 <code>Files</code> 对话框中即可。</p>

<p>上传了之后，点击ROS的 <code>New Terminal</code>，在命令行下输入：<code>import chinasites.rsc</code>，所有的国内IP地址列表就导入了，在ROS的 <code>IP</code> &ndash;> <code>Firewall</code> &ndash;> <code>Address Lists</code> 中就可以看到：</p>

<p><img src="/downloads/image/ros-ip-firewall-address-lists.png" alt="China IP address list" /></p>

<p>在上图中可以看到，我们给这些IP地址都设了一个名字叫做 <code>novpn</code>，表示路由这些地址的时候，不需要走VPN，后面会看到如何使用的。</p>

<h2>标记Packets</h2>

<p>这是Linux netfilter/iptables非常强大的功能体现了，首先来看在ROS里面是怎么配置的：</p>

<p>``` bash
Flags: X &ndash; disabled, I &ndash; invalid, D &ndash; dynamic
 0   chain=prerouting action=mark-routing new-routing-mark=vpn passthrough=yes</p>

<pre><code> dst-address=!192.168.88.0/24 dst-address-list=!novpn 
</code></pre>

<p>```</p>

<p>这个配置项位于：<code>IP</code> &ndash;> <code>Firewall</code> &ndash;> <code>Mangle</code>。首先这个配置针对的是 <code>prerouting</code> 表，对Mangle/Prerouting还不清楚的，看我的这篇文章：</p>

<p><a href="http://markzhang.cn/blog/2014/07/23/netfilter-overview/">Linux Netfilter overview</a></p>

<p>然后，<code>dst-address-list=!novpn</code> 其实意思就是，如果目的地址不在 <code>novpn</code> 这个address list中的；最后 <code>action=mark-routing new-routing-mark=vpn</code> 就表示如果目的地址不在 <code>novpn</code> 中的，就给这些packet打上一个名为 <code>vpn</code> 的routing标记。</p>

<p>当然，上述命令中的：<code>dst-address=!192.168.88.0/24</code>，这表示本地局域网的地址不受该条规则影响，这也是非常好理解的。</p>

<p>所以总结来说，我们通过Linux netfilter的Mangle功能，成功的给不属于国内IP地址列表中的packet，打上了一个名为 <code>vpn</code> 的路由标记。</p>

<p>这里需要提一下 <code>passthrough=yes</code> 这个东西的作用。<code>passthrough=yes</code> 表示packet经过了本规则的处理之后，还会继续往下传递，给下面的rules继续处理。相反的例子是 <code>IP</code> &ndash;> <code>Firewall</code> &ndash;> <code>Fliter</code> 中的规则，比如 <code>accept</code> 或者 <code>drop</code> ，一旦匹配到了这些规则，就不会再继续往下处理了（下面的规则就不会再去执行了），所以这就是为什么我在上篇文章中提到说有一条 <code>drop</code> 的规则一定要放在最后。</p>

<p>所以这里我们设置了 <code>passthrough=yes</code> ，表示位于我们本条规则之后的规则还有机会继续被得到执行，所以你可以继续添加标记类的规则，或者其他任何Mangle的规则。所以再次重申，在Filter/Mangle这些表里，规则的顺序是很有影响的。</p>

<h2>添加路由</h2>

<p>点击 <code>IP</code> &ndash;> <code>Routes</code>，在 <code>Routes</code> 标签页，点击加号按钮添加一条路由规则：</p>

<p><img src="/downloads/image/ros-ip-routes.png" alt="ROS add routing" /></p>

<ul>
<li><p>Dst. Address，这表示哪些目的IP地址受这条路由影响，这里填写 <code>0.0.0.0/0</code> 表示所有IP地址。</p></li>
<li><p>Gateway，这表示这条路由走哪个Interface，一般来说，这就是你的VPN的PPP连接了。</p></li>
<li><p>Distance，这表示这条路由的权重。在之前的一篇介绍ROS的基础设置的文章中，有说到我们添加了一个PPPoE client来实现宽带拨号，在创建那个PPPoE Client的时候，有一个选项叫做：<code>Default Route Distance</code>，我的这项设置是10，而如上图所示，现在我们添加的这条路由，我的设置是1。其实很好理解，我们在添加PPPoE Client的时候，有选择 <code>Add Default Route</code>，所谓Default route就是路由所有IP地址：<code>0.0.0.0/0</code>的，那么现在我们又添加了一条路由，也是路由所有IP地址的，那应该选哪条路由呢？这就是根据路由的Distance来决定的。Distance值越小的，权重越高。</p></li>
<li><p>Routing Mark，这里填写的是 <code>vpn</code>。</p></li>
</ul>


<p>所以总结来说，这条路由的作用就是，对于 <code>Routing Mark</code> 是 <code>vpn</code> 的packet，走我们指定的 <code>Gateway</code>。而且由于这条路由的权重高于默认路由，所以就实现了非国内的IP地址，走我们指定的Gateway，而国内的IP地址还是走默认路由（宽带连接的那条路由）。</p>

<p>写了一堆字，其实做一下就是两分钟的事。ROS的确是非常Power的东西。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RouterOS 配置记录（一）：基础设置]]></title>
    <link href="http://www.markzhang.cn/blog/2014/08/19/ros-basic-setup/"/>
    <updated>2014-08-19T14:38:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2014/08/19/ros-basic-setup</id>
    <content type="html"><![CDATA[<p>RouterOS（以下简称ROS）是一个软路由系统，由拉脱维亚的Mikrotik开发，完全基于Linux。项目刚开始的时候，只支持x86，所以我们可以找一台PC机来安装ROS，从而可以让PC机瞬间变身成一个软路由。</p>

<p>后来Mikrotik开发了专用的硬件设备：RouterBoard。RouterBoard是MIPS架构，运行ROS，所以不想搞一台PC机的话，买一台RouterBoard就显的非常不错。而且RouterBoard有好多型号，带wifi的不带wifi的，企业用的个人用的，千兆的百兆的。。。，最关键的是家用的RouterBoard，带wifi的也不贵，所以最近就把家里的路由器换成了RouterBoard，型号是：951Ui-2HnD。</p>

<p>本系列文章旨在记录我在使用ROS的时候的一些配置，之前已经写了一篇有关修改WinBox字体的文章，算是个引子。ROS虽然强大，但是配置项目的繁杂也颇为吓人，坦白说没有网络基础的话还是别用ROS。</p>

<!-- more -->


<p>本文讲述拿到RouterBoard之后的最基础配置，也就是配置宽带拨号，WIFI，NAT，DHCP，最终能让家里的各网络设备上网。</p>

<h2>宽带拨号</h2>

<p>RouterBoard第一次开机，winbox连入之后，会有一个提示让我们备份当前的配置或是删掉目前的配置，为了从头开始，我删掉了原来的所有配置，从头开始一步一步自己来。</p>

<p>配置宽带拨号非常简单，就是在 <code>PPP</code> 里面添加一个 <code>PPPoE Client</code> 的interface即可：</p>

<p><img src="/downloads/image/ros-pppoe-client.png" alt="ROS add PPPoE client" /></p>

<p>必须要填的会以红色表示，在上图中，要填的是Name和Interfaces。Interfaces指的是哪个网口连接了宽带网线，一般来说，RouterBoard的第一个网口我们都用来连接外网（WAN），所以选择第一个网口即可（如上图所示，我给第一个网口做了重命名，修改名称为ether1-wan）。在第二个标签页 <code>Dial Out</code> 中，就需要填写你的宽带账号和密码了，此外 <code>Use Peer DNS</code> 和 <code>Add Default Router</code> 也可以勾选上。</p>

<p><code>Use Peer DNS</code> 指的是是否使用宽带运营商提供的DNS（在PPPoE拨号的时候能得到），一般都需要使用，当然你也可以不用运营商提供的DNS，自己定义一些DNS server，比如Google的 <code>8.8.8.8</code>, <code>8.8.4.4</code>，还有OpenDNS的 <code>208.67.222.222</code>, <code>208.67.220.220</code>。只是使用这些DNS的话，你要先把翻墙准备好。</p>

<p>在Winbox的 <code>IP</code> &ndash;> <code>DNS</code> 里面，就可以自己设置DNS server：</p>

<p><img src="/downloads/image/ros-ip-dns.png" alt="ROS DNS setting" /></p>

<p>在上图中可以看到，<code>Dynamic Servers</code> 就是来自宽带运营商的DNS server信息。</p>

<p>而 <code>Allow Remote Requests</code> 指的是，RouterBoard本身是否也作为一个DNS server从而可以响应DNS查询请求。一般来说，这个应该enable。顺理成章的，下面的一些有关Cache的配置也就变的有意义了，如上图所示，我加大了Cache的size，从而可以多缓存一些DNS信息。不过在enable了 <code>Allow Remote Request</code> 之后，需要注意要打开TCP/UDP的DNS端口，以防客户端无法通过RouterBoard查询DNS。</p>

<p>回到宽带拨号，配置好了 <code>PPPoE Client</code> 之后，就可以尝试去enable它了，一旦连接成功，就表示你的宽带拨号已经OK了。</p>

<h2>WIFI</h2>

<p>打开 <code>Wireless</code> ，在Interface标签页，可以看到一个wireless interface，默认名字是wlan1，关键的配置在标签页 <code>Wireless</code>：</p>

<p><img src="/downloads/image/ros-wireless.png" alt="ROS Wirelss config" /></p>

<p>大部分都非常好理解，有几个地方需要注意：</p>

<ul>
<li>Channel Width，这里有所谓的HT Above和HT Below，有关这个的解释是（来自Mikrotik官方）：</li>
</ul>


<blockquote><p>ht above and ht below allows to use additional 20MHz extension channel and if it should be located below or above control (main) channel. Extension channel allows 11n device to use 40MHz of spectrum in total thus increasing max throughput.</p></blockquote>

<p>不过需要注意的是，不是所有的Frequency都可以设置Above/Below，这里有一张来自Mikrotik的表说明了这一点，所以最终在设置Frequency的时候需要注意：</p>

<p><img src="/downloads/image/ros-wireless-ht-above-below.png" alt="ROS wireless HT above/below setting" /></p>

<ul>
<li><p>Frequency，上面已经提到了，设置Frequency要注意HT Above/Below是否有取值，此外可以通过点击 <code>Scan</code> 按钮来查看当前环境中有哪些Frequency是被占用的，尽量挑选一个没人使用的频率吧。</p></li>
<li><p>Wireless Protocol，Mikrotik开发了一些自己私有的WIFI协议，比如这里看到的NV2等，对于我们来说，肯定是使用802.11了。</p></li>
<li><p>Security Profile，这个后面紧接着就要配置，就是在这个profile中，我们可以配置WIFI的加密方式（WPA/WEP等）。</p></li>
<li><p>Bridge Mode，要选成Enabled，后面会提到，为了让WIFI的clients能和RouterBoard上的几个以太网口通信，需要将它们都放到一个bridge中。</p></li>
</ul>


<p>接下来就要配置WIFI Security Profile了，如下图所示：</p>

<p><img src="/downloads/image/ros-wireless-security-profile.png" alt="ROS wireless security profile" /></p>

<p>在 <code>Security Profile</code> 标签页中，点击加号按钮就可以新建一个 <code>Security Profile</code> 了。上图中我们配置的security profile name是default，所以在刚才我们设置Wireless Interface的时候，<code>Security Profile</code> 一项我们选择的就是这个 <code>default</code>。</p>

<p>配置到这里，WIFI热点就配置完成了，接下来我们需要将WIFI的wlan1这个interface和以太网的四个端口（第一个端口ether1-wan我们是分配给了宽带连接）放到一个bridge中去，这样才可以实现WIFI的clients和这四个以太网口互通。</p>

<p>在配置Bridge的时候，其实有两个配置步骤，顾名思义Bridge肯定只能包含两个Interface（Bridge的两端），而我们需要将wlan1和四个以太网口都配置到Bridge上去，那怎么办？</p>

<p>所以第一步是，将以太网口3/4/5都配置成以太网口2的 <code>Slave Port</code>，如下图所示：</p>

<p><img src="/downloads/image/ros-interface-master-port.png" alt="ROS interface master port" /></p>

<p>点击 <code>Interfaces</code>，在出来的对话框的 <code>Interface</code> 标签页，点击以太网口3/4/5就可以看到上图。在上图中可以看到，我们将以太网口3（ether3）的 <code>Master Port</code> 这一项选成了 <code>lan-ps3</code>。这里解释一下，<code>lan-ps3</code> 就是我的第二个以太网口，因为这个网口接着我的PS3，所以我给它取名为 <code>lan-ps3</code>。</p>

<p>将3/4/5以太网口设置成以太网口2的Slave Port之后，就可以创建Bridge了，点击 <code>Bridge</code>，在出来的对话框的 <code>Bridge</code> 标签页中，点击加号新建一个Bridge，啥都不需要修改，只需要给个名字就OK了。关键是在标签页 <code>Ports</code> 中，点击加号按钮，将wlan1和lan-ps3加入到Bridge中去：</p>

<p><img src="/downloads/image/ros-bridge-ports.png" alt="ROS Bridge ports" /></p>

<p>这样就OK了，WIFI部分的配置就差不多了。</p>

<h2>NAT</h2>

<p>但凡搞过Linux iptables的都知道了，input/forward/output，pre-route/post-route&hellip;，对这些概念不清楚的可以看我这篇文章：</p>

<p><a href="http://markzhang.cn/blog/2014/07/23/netfilter-overview/">Linux Netfilter overview</a></p>

<p>说起来配置一个简单的能上网的NAT非常的简单，选择 <code>IP</code> &ndash;> <code>Firewall</code>，在 <code>NAT</code> 标签页里面点击加号按钮，添加一个NAT：</p>

<p><img src="/downloads/image/ros-ip-firewall-nat.png" alt="ROS add NAT" /></p>

<p>总共就只需要做三件事情：Chain选成srcnat（表示伪装源地址），Out Interface选成宽带连接那个PPPoE client，最后在 <code>Action</code> 标签页里面选择动作为：masquerade。</p>

<p>这样就表示所有的packet，在经过路由表之后，如果最终经过路由决定要从 <code>Out Interface</code> 这个接口出去的话，就做masquerade。</p>

<h2>DHCP Server</h2>

<ul>
<li>首先是创建一个IP Pool。点击 <code>IP</code> &ndash;> <code>Pool</code>，然后新建一个Pool：</li>
</ul>


<p><img src="/downloads/image/ros-ip-pool.png" alt="ROS create IP pool" /></p>

<p>就是填写一个名字，一个IP地址范围即可，比如我这里设置的就是192.168.88.2-192.168.88.254，RouterBoard自己就是192.168.88.1了。</p>

<ul>
<li>然后就是创建一个DHCP server了，来到 <code>IP</code> &ndash;> <code>DHCP Server</code>，点击加号按钮创建一个DHCP Server:</li>
</ul>


<p><img src="/downloads/image/ros-ip-dhcp-server.png" alt="ROS Create DHCP server" /></p>

<p>需要注意的就是，首先 <code>Interface</code> 那一项要选成你的Bridge device，这样WIFI和以太网的网络client就都可以DHCP了；其次 <code>Address Pool</code> 那一项就选我们刚才创建的那个IP Pool。</p>

<ul>
<li>最后设定DHCP Server的Network的一些信息，还是在DHCP Server的对话框中，选 <code>Networks</code> 那个标签页，点击加号按钮：</li>
</ul>


<p><img src="/downloads/image/ros-ip-dhcp-server-networks.png" alt="ROS DHCP server networks" /></p>

<p>可以看到，这其实就是设定网关和DNS Server的。上图中，对于192.168.88.0/24这个网络的DHCP，clients自动获得了IP地址之后，获得的网关就是192.168.88.1，DNS也是192.168.88.1。联想到一开始的时候提到的 <code>IP</code> &ndash;> <code>DNS</code> 的设定，网络客户端知道DNS Server是RouterBoard就是在这里设定的。</p>

<h2>最后</h2>

<p>最后我们还可以配置一些简单的防火墙规则，用来拦截来自外网的请求，这里用命令行的方式来展现，这些规则都是配置在：<code>IP</code> &ndash;> <code>Firewall</code> &ndash;> <code>Filter</code> 里面的，非常简单：</p>

<p>``` bash
Flags: X &ndash; disabled, I &ndash; invalid, D &ndash; dynamic
 0   chain=input action=accept protocol=icmp</p>

<p> 1   chain=input action=accept connection-state=established</p>

<p> 2   chain=input action=accept connection-state=related</p>

<p> 3   chain=input action=accept protocol=tcp dst-port=22</p>

<p> 4   chain=input action=accept protocol=tcp dst-port=8291</p>

<p> 5   chain=input action=accept protocol=tcp dst-port=3987</p>

<p> 6   chain=input action=accept protocol=tcp dst-port=80</p>

<p> 7  chain=input action=accept protocol=tcp dst-port=53</p>

<p> 8   chain=input action=accept protocol=udp dst-port=53</p>

<p> 9   chain=input action=drop in-interface=SHUnicom
```</p>

<p>打开22端口是为了可以远程ssh RouterBoard，打开8291/3987/80端口是为了可以远程使用WinBox登录（可以额外添加src-address来限定只允许某个IP地址登录，这样可以增强安全性），接受53端口是为了DNS查询（实际上DNS一般都是使用UDP，TCP不需要打开），最后一条就是拦截所有外部的网络请求，请确保这一条一定位于所有规则的最后，iptables是匹配到一条规则之后就会返回的，所以如果这条不出现在最后，那么这一条之后的所有规则都会无法生效。</p>

<p>这个最后一条规则，可以看到，是说如果是从 <code>SHUnicom</code> 这个接口进来的数据一律drop，而 <code>SHUnicom</code> 是我的宽带连接接口。想到这个宽带连接其实是在我的ether1-wan这个物理接口上，那么这里是否也可以设置成从 <code>ether1-wan</code> 接口进来的数据一律drop呢？仔细想想是不对的，<code>ether1-wan</code> 是物理接口，用于宽带拨号；而 <code>SHUnicom</code> 其实是一个PPPoE，它会创建一个虚拟的网卡interface，所以我们要drop的是从这个虚拟的网卡interface尝试进入RouterBoard的数据，而不是物理的 <code>ether1-wan</code> 上进入的数据。如果我们真的drop了 <code>ether1-wan</code> 上进来的数据，那就上不了网了，因为所有的返回的数据都被丢掉了。在PPPoE/VPN的时候，虚拟网卡会被创建，所以这个时候要分清楚虚拟网卡和物理网卡，免的设置错误的规则。</p>

<p>能上网只是最基本需求了，接下来才是开始各种折腾的时候，VPN/chnroutes/DDNS/&hellip; 后续博客将记录这些。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Winbox for Mac OS X，修改界面字体]]></title>
    <link href="http://www.markzhang.cn/blog/2014/07/24/winbox-mac-change-font/"/>
    <updated>2014-07-24T18:19:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2014/07/24/winbox-mac-change-font</id>
    <content type="html"><![CDATA[<p>RouterOS（或简称ROS）是拉脱维亚的Mikrotik开发的一个强大到变态（对于个人用户而言）的路由系统。基于Linux，支持x86和MIPS（routerboard）。也就是说，你可以找一台PC来，装上routeros，就变身成了一台路由器。所以也有很多人称RouterOS为软路由。</p>

<p>Winbox是Mikrotik开发的RouterOS的管理工具（客户端）。当然，RouterOS也有网页版和命令行（终端，支持SSH，串口等）的管理界面，但是Winbox是相对来说最直观和好用的（当然用多了肯定到最后就是纯命令行了）。</p>

<p>有一个问题就是，Winbox只有windows版的。在Mac和Linux上，要使用wine来运行（或安装虚拟机）。</p>

<!-- more -->


<p>对于Mac OS X，网上有爱好者已经做好了一个包，下载下来安装即可，不用自己去折腾安装和配置 <code>wine</code>。地址在这里：</p>

<p><a href="http://wiki.mikrotik.com/wiki/MikroTik_WinBox_for_Mac_StandAlone">http://wiki.mikrotik.com/wiki/MikroTik_WinBox_for_Mac_StandAlone</a></p>

<p>的确很好用，就是有一个问题，字体太难看。看起来用的是默认的宋体，所以英文显示效果不忍直视。</p>

<p>所以很自然想修改字体。说起修改这个字体，其实就是修改windows的默认字体。参考了这篇文章：</p>

<p><a href="http://linfan.info/blog/2012/03/01/wine-mac/">http://linfan.info/blog/2012/03/01/wine-mac/</a></p>

<p>具体可以这么做：</p>

<ul>
<li>找一个喜欢的字体（Mac OS X自带了很多字体，如果安装了Office for Mac，那微软的很多字体也都有了），拷贝到 <code>/Applications/Winbox.app/drive_c/windows/Fonts</code> 目录下。比如我用的是微软雅黑：</li>
</ul>


<p><code>bash
cp /Library/Fonts/Microsoft/Microsoft\ Yahei.ttf /Applications/WinBox.app/drive_c/windows/Fonts
</code></p>

<ul>
<li>使用Wine运行注册表编辑器。这个打包好的Winbox for Mac，使用的是Wineskin（就是一个wine的wrapper，这样就把winbox.exe做成了Mac上的Winbox.app），所以这样：</li>
</ul>


<p><code>bash
open /Applications/WinBox.app/Wineskin.app/
</code></p>

<p>然后点击 <code>Advanced</code> 按钮，再选择 <code>Tools</code> 标签页，最后点击 <code>Registry Editor (regedit)</code> 按钮，出现windows的注册表编辑器，导入这个注册表：</p>

<p>``` ini
REGEDIT4</p>

<p>[HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\FontSubstitutes]
&ldquo;Microsoft Yahei&rdquo;=&ldquo;Microsoft Yahei&rdquo;
&ldquo;Comic Sans MS&rdquo;=&ldquo;Microsoft Yahei&rdquo;
&ldquo;Courier&rdquo;=&ldquo;Microsoft Yahei&rdquo;
&ldquo;Courier New&rdquo;=&ldquo;Microsoft Yahei&rdquo;
&ldquo;Fixedsys&rdquo;=&ldquo;Microsoft Yahei&rdquo;
&ldquo;Helv&rdquo;=&ldquo;Microsoft Yahei&rdquo;
&ldquo;Helvetica&rdquo;=&ldquo;Microsoft Yahei&rdquo;
&ldquo;Lucida Console&rdquo;=&ldquo;Microsoft Yahei&rdquo;
&ldquo;Lucida Sans&rdquo;=&ldquo;Microsoft Yahei&rdquo;
&ldquo;Microsoft Sans Serif&rdquo;=&ldquo;Microsoft Yahei&rdquo;
&ldquo;MingLiU&rdquo;=&ldquo;Microsoft Yahei&rdquo;
&ldquo;PMingLiu&rdquo;=&ldquo;Microsoft Yahei&rdquo;
&ldquo;MS Shell Dlg&rdquo;=&ldquo;Microsoft Yahei&rdquo;
&ldquo;MS Shell Dlg 2&rdquo;=&ldquo;Microsoft Yahei&rdquo;
&ldquo;MS Dialog&rdquo;=&ldquo;Microsoft Yahei&rdquo;
&ldquo;MS Gothic&rdquo;=&ldquo;Microsoft Yahei&rdquo;
&ldquo;MS PGothic&rdquo;=&ldquo;Microsoft Yahei&rdquo;
&ldquo;MS UI Gothic&rdquo;=&ldquo;Microsoft Yahei&rdquo;
&ldquo;MS Mincho&rdquo;=&ldquo;Microsoft Yahei&rdquo;
&ldquo;MS PMincho&rdquo;=&ldquo;Microsoft Yahei&rdquo;
&ldquo;SimHei&rdquo;=&ldquo;Microsoft Yahei&rdquo;
&ldquo;SimSun&rdquo;=&ldquo;Microsoft Yahei&rdquo;
&ldquo;NSimSun&rdquo;=&ldquo;Microsoft Yahei&rdquo;
&ldquo;System&rdquo;=&ldquo;Microsoft Yahei&rdquo;
&ldquo;Tahoma&rdquo;=&ldquo;Microsoft Yahei&rdquo;
&ldquo;Times&rdquo;=&ldquo;Microsoft Yahei&rdquo;
&ldquo;Times New Roman&rdquo;=&ldquo;Microsoft Yahei&rdquo;
&ldquo;Tms Rmn&rdquo;=&ldquo;Microsoft Yahei&rdquo;
&ldquo;Trebuchet MS&rdquo;=&ldquo;Microsoft Yahei&rdquo;
&ldquo;Verdana&rdquo;=&ldquo;Microsoft Yahei&rdquo;
```</p>

<p>这样就OK了，再次打开Winbox，终于看到舒服的界面了：</p>

<p><img src="/downloads/image/mac-winbox-change-font.png" alt="Mac Winbox changed font" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux netfilter概述，mangle/nat/filter, prerouting/input/forward...到底是啥]]></title>
    <link href="http://www.markzhang.cn/blog/2014/07/23/netfilter-overview/"/>
    <updated>2014-07-23T18:30:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2014/07/23/netfilter-overview</id>
    <content type="html"><![CDATA[<p>本文转载自：</p>

<p><a href="http://shorewall.net/NetfilterOverview.html">http://shorewall.net/NetfilterOverview.html</a></p>

<!-- more -->


<p>Netfilter consists of three tables: Filter, Nat and Mangle. Each table has a number of build-in chains: PREROUTING, INPUT, FORWARD, OUTPUT and POSTROUTING.</p>

<p>Rules in the various tables are used as follows:</p>

<p>Filter
Packet filtering (rejecting, dropping or accepting packets)</p>

<p>Nat
Network Address Translation including DNAT, SNAT and Masquerading</p>

<p>Mangle
General packet header modification such as setting the TOS value or marking packets for policy routing and traffic shaping.</p>

<p>Raw
Used primarily for creating exemptions from connection tracking with the NOTRACK target. Also used for stateless DNAT.</p>

<p>Rawpost
Used for stateless SNAT.</p>

<p>The following diagram shows how packets traverse the various builtin chains within Netfilter. Note that not all table/chain combinations are used.</p>

<p><img src="/downloads/image/netfilter-overview.png" alt="Netfilter Overview" /></p>

<p>&ldquo;Local Process” means a process running on the Shorewall system itself.</p>

<p>A more elaborate version of this flow is available here and this one contrasts the Netfilter flow with that of ipchains.</p>

<p>In the above diagram are boxes similar to this:</p>

<p><img src="/downloads/image/netfilter-input-chain.png" alt="Input chain" /></p>

<p>The above box gives the name of the built-in chain (INPUT) along with the names of the tables (Mangle and Filter) that the chain exists in and in the order that the chains are traversed. The above sample indicates that packets go first through the INPUT chain of the Mangle table then through the INPUT chain of the Filter table. When a chain is enclosed in parentheses, Shorewall does not use the named chain (INPUT) in that table (Mangle).</p>

<p><strong> Keep in mind that chains in the Nat table are only traversed for new connection requests (including those related to existing connections) while the chains in the other tables are traversed on every packet. </strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac OS X（Mavericks）共享VPN给其他设备]]></title>
    <link href="http://www.markzhang.cn/blog/2014/07/17/mac-share-vpn-connection/"/>
    <updated>2014-07-17T11:22:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2014/07/17/mac-share-vpn-connection</id>
    <content type="html"><![CDATA[<p>之前写过一篇文章叫“Chnroutes的使用“，主要说的是如何通过使用 <code>chnroutes</code> 从而将国内和国外的路由分开，国内走正常路由，国外则走VPN。现在的问题是，如果在一台电脑上有了VPN之后，如何将这个VPN share给其他设备，比如PS3？</p>

<!-- more -->


<p>首先很自然想到的是Mac OS X（Mavericks）自带的 <code>Internet Sharing</code> 功能：</p>

<p><img src="/downloads/image/mac-internet-sharing.png" alt="Mac OS X Internet Sharing" /></p>

<p>但是通过使用后发现有如下的问题：</p>

<ol>
<li><p>你需要有两个网络设备，才能开始share。上面的截图也可以看到，你要选择一个 <code>From</code> 的设备，再选择 <code>To</code> 的网络设备（也就是说其他设备是通过本机的这个网络设备连接的）。</p></li>
<li><p>当然你可以说，VPN在Mac OS X里面也是一个单独的网络设备啊。是，但是通过试验，如果你只有一个网络设备，比如WIFI，那么就意味着我们既需要通过这个WIFI去连接VPN，还要通过这个WIFI让其他的设备能够连到本机，这是没法做到的。试验的结果就是，当你开了 <code>Internet Sharing</code> 之后，你的VPN就拨不上去（一拨就掉）；当你开了VPN之后，<code>Inetnet Sharing</code> 一开你的VPN就掉。事实上，如果通过WIFI来share的话，你会发现Mac OS X会将WIFI配置成一个AP，所以自然一旦被enable，你的VPN就掉了。</p></li>
<li><p>就算以上两点对你来说都没问题，这第三点就是绝望的来源：Mac OS X不会forward VPN的数据。也就是说，你想要通过Mac OS X的这个 <code>Internet Sharing</code> 功能来share你的VPN的话，是不可行的。</p></li>
</ol>


<p>所以没办法还是通过万能的Google来寻找答案，答案在这里：</p>

<p><a href="http://rodrigo.sharpcube.com/2010/06/20/using-and-sharing-a-vpn-connection-on-your-mac/">http://rodrigo.sharpcube.com/2010/06/20/using-and-sharing-a-vpn-connection-on-your-mac/</a></p>

<p>基本上就是需要我们写脚本来实现，上面这篇文章中，VPN使用的是OpenVPN，我测试的时候，使用的是PPTP的VPN，所以根据上文中 <code>Troubleshooting</code> 一节的描述，我做了这么两个脚本：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>开启VPN共享 bash (share-pptp-vpn.sh)</span> <a href='/downloads/code/share-pptp-vpn.sh'>download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c">#!/bin/sh</span>
</span><span class='line'>
</span><span class='line'>natd -same_ports -use_sockets -unregistered_only -dynamic -interface ppp0 -clamp_mss
</span><span class='line'>ipfw -f flush
</span><span class='line'>ipfw add divert natd ip from any to any via ppp0
</span><span class='line'>ipfw add pass all from any to any
</span><span class='line'>sysctl -w net.inet.ip.forwarding<span class="o">=</span>1
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>关闭VPN共享 bash (off-share-pptp-vpn.sh)</span> <a href='/downloads/code/off-share-pptp-vpn.sh'>download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c">#!/bin/sh</span>
</span><span class='line'>
</span><span class='line'>killall natd
</span><span class='line'>ipfw -f flush
</span><span class='line'>sysctl -w net.inet.ip.forwarding<span class="o">=</span>0
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>所以当拨上了VPN之后，运行开启VPN共享那个脚本就OK了。在PS3上将网关指到Macbook的IP地址就可以了。</p>

<p>最后一个遗留问题。Mac OS X的VPN高级设定中有这么一个checkbox：</p>

<p><img src="/downloads/image/mac-send-traffic-over-vpn.png" alt="Send all traffic over VPN" /></p>

<p>这个 <code>Send all traffic over VPN</code> 我不太理解是什么意思，是指本地NAT网络的地址不走VPN么？还是Mac OS X内置了类似 <code>chnroutes</code> 这样的功能？</p>

<p>有意思的是，有的时候如果enable了这个选项，我发现PS3连接网络就会出现问题。而如果VPN已经拨上去了，再去enable这个选项貌似就没有影响。</p>

<p>没有深究这个，所以这是目前的一个遗留问题。</p>
]]></content>
  </entry>
  
</feed>
