<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux | Make Things Cool]]></title>
  <link href="http://www.markzhang.cn/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://www.markzhang.cn/"/>
  <updated>2015-07-28T11:05:55+08:00</updated>
  <id>http://www.markzhang.cn/</id>
  <author>
    <name><![CDATA[Mark Zhang]]></name>
    <email><![CDATA[super119@139.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[NVIDIA Linux驱动在Ubuntu 12.04上的安装]]></title>
    <link href="http://www.markzhang.cn/blog/2015/06/03/nvidia-linux-driver-on-ubuntu/"/>
    <updated>2015-06-03T21:35:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2015/06/03/nvidia-linux-driver-on-ubuntu</id>
    <content type="html"><![CDATA[<p>在Ubuntu上安装显卡驱动不是一件容易的事情，安装不是Ubuntu官方认证过的NVIDIA自家的驱动就更是困难，而我选择在一个老的Ubuntu版本上安装显卡驱动，事情就变的更加麻烦起来。</p>

<p>其实一开始我也不想安装NVIDIA自家的驱动，首先想尝试用 <code>nouveau</code>，但是悲剧的发现Ubuntu 12.04上的nouveau无法驱动我的GTX970，可能需要新版本的Ubuntu才可以。所以，被迫选择安装NVIDIA自家的驱动。</p>

<!-- more -->


<p>安装和使用N卡驱动中途遇到了很多的问题，这里来个总结。</p>

<h2>第一次安装</h2>

<p>现在总结起来，可以按照如下步骤来：</p>

<ul>
<li>禁用nouveau和其他相关的module：</li>
</ul>


<p>``` bash
sudo vi /etc/modprobe.d/blacklist.conf</p>

<p>添加：</p>

<p>blacklist vga16fb
blacklist nouveau
blacklist rivafb
blacklist nvidiafb
blacklist rivatv
```</p>

<ul>
<li>卸载nvidia相关的package，否则NVIDIA驱动安装的时候会报错：</li>
</ul>


<p><code>bash
dpkg -l|grep nvidia
sudo apt-get remove &lt;nvidia packages&gt;
</code></p>

<ul>
<li>安装一些常用的package，比如：</li>
</ul>


<p><code>bash
sudo apt-get install build-essential
sudo apt-get install ia32-libs
</code></p>

<p>这是因为NVIDIA驱动安装的时候，会编译kernel module（nvidia.ko），所以需要一些常用的开发用的package。</p>

<ul>
<li><p>NVIDIA驱动安装的时候，X server不能运行，所以我是这么做的：</p></li>
<li><p>重启系统，在grub界面选择进入 <code>Recovery</code> 模式</p></li>
<li>进入Recovery之后，选择 <code>Enable Network</code></li>
<li>重新返回到Recovery界面，选择 <code>Drop to root console</code></li>
<li>运行NVIDIA驱动安装包，按照提示操作即可</li>
</ul>


<p>之所以要做一次 <code>Enable Network</code> 是因为，这个选项会mount一些必要的文件系统，比如 <code>/tmp</code>，NVIDIA驱动安装的时候是需要 <code>/tmp</code> 的。</p>

<h2>Ubuntu更新kernel之后</h2>

<p>如果你使用了Ubuntu的 <code>Update Manager</code> 更新了package之后，一定要注意是否有升级kernel，如果升级了kernel，那么很可能你需要重新安装一次NVIDIA的驱动。</p>

<p>这是因为上面也提到了，<code>nvidia.ko</code> 需要重新编译。所以，如果你更新了kernel，发现X server起不来了，那么就可以尝试这么来：</p>

<ol>
<li>重启系统，在grub界面选择进入 <code>Recovery</code> 模式</li>
<li>进入Recovery之后，选择 <code>Enable Network</code></li>
<li>重新返回到Recovery界面，选择 <code>Drop to root console</code></li>
<li>运行 <code>nvidia-uninstall</code> 卸载当前的NVIDIA驱动</li>
<li>重新运行NVIDIA驱动安装包，再安装一遍驱动</li>
</ol>


<p>之前我尝试过不运行 <code>nvidia-uninstall</code>，直接再次安装一遍驱动，发现这样做的话，安装包也会提醒你说发现当前已经安装了驱动，说是否需要卸载再重新安装。然后我就选择OK，但是发现这样操作下来之后有的时候还是不行，所以还是自己手动uninstall，然后再安装吧。</p>

<h2>如何看出错日志</h2>

<p>主要就是要看两个东西：</p>

<ul>
<li>dmesg：这是kernel的log，看nvidia的内核驱动是否有什么错误，crash，如果有，就Google一下错误信息看是否有帮助</li>
</ul>


<p>这里提一下，看到这个信息是正常的：</p>

<p><code>bash
[    1.222765] nvidia: module license 'NVIDIA' taints kernel.
[    1.225367] nvidia: module verification failed: signature and/or  required key missing - tainting kernel
</code></p>

<ul>
<li>/var/log/Xorg.0.log：这里主要是看NVIDIA的X server driver（nvidia_drv.so）是否有错误，crash</li>
</ul>


<h2>万般无奈怎么办</h2>

<ul>
<li><p>去 <a href="http://www.geforce.com/drivers">http://www.geforce.com/drivers</a> 看看有没有BETA版本的驱动下载，有的话下载下来试试。再说一次，记得先uninstall当前的驱动再安装新的。</p></li>
<li><p>去NVIDIA的论坛报bug，我没这么干，因为本身我用的Ubuntu就是老版本了，估计NVIDIA也不会理我，如果去报告Ubuntu 14.04上的bug，可能NVIDIA会创建bug并派人fix。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux定时任务 - Cron]]></title>
    <link href="http://www.markzhang.cn/blog/2015/03/03/cron/"/>
    <updated>2015-03-03T17:09:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2015/03/03/cron</id>
    <content type="html"><![CDATA[<ul>
<li><p>crontab -e编辑定时任务，crontab -l查看。最后的cron任务文件保存在/var/spool/cron/crontab目录下</p></li>
<li><p>cron会切换到/var/spool/cron/crontab目录下cron文件的owner这个用户，然后执行定义的定时任务。</p></li>
</ul>


<!-- more -->


<ul>
<li>但是cron切换用户的时候，任何环境变量，包括.bashrc都不会被执行到。所以诸如$HOME这样的变量也是没有定义的。所以，一般在定时任务的脚本中，我们会这样处理：</li>
</ul>


<p>``` bash</p>

<h1>!/bin/bash</h1>

<p>HOME=/home/markz
source ${HOME}/.bashrc
export PATH=/usr/local/bin:$PATH
```</p>

<p>然后才是具体的要执行的任务。</p>

<p>有一点注意，~/.bashrc往往都含有大量的定义和脚本执行，这有可能会影响到source的成功执行。我们之所以在需要cron的脚本中加入这句source，大多数情况下是为了定义一些环境变量。所以为了让source能保证成功，一般我们都会把需要的环境变量单独存放到一个文件中，然后去source那个文件即可。直接source ~/.bashrc不是一个好的做法。</p>

<ul>
<li><p>/var/log/syslog保存了cron的log，查看该log可以方便的知道定时任务执行的一些情况。</p></li>
<li><p>不要assume cron会在你想要的目录下执行脚本/程序，所以，奔放但是有效的做法是，在你的定时脚本和程序中，请全部使用绝对路径。</p></li>
<li><p>貌似crontab -e的时候，命令行中不能使用>&amp;，否则会导致命令不会被定时触发。可以使用这个来代替：</p></li>
</ul>


<p><code>bash
&lt;cmd...&gt; &gt;&gt; /home/super/cmd.log 2&gt;&amp;1
</code></p>

<ul>
<li>定义定时任务（crontab -e）的几个例子：</li>
</ul>


<p>``` bash</p>

<h1>每小时执行一次</h1>

<p>0 * * * * /script/path</p>

<h1>每五分钟执行一次</h1>

<p>0,5,10,15,20,25,30,35,40,45,50,55 * * * * /script/path</p>

<h1>每五分钟执行一次</h1>

<h1>这种写法不保证在所有Linux distribution上都能work</h1>

<p>0-59/5 * * * * /script/path</p>

<h1>每分钟执行一次</h1>

<p>0-59 * * * * /script/path</p>

<h1>每天执行一次</h1>

<ul>
<li>0 * * * /script/path
```</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Thunderbird 80(72) column - 邮件在80(72)列处line break]]></title>
    <link href="http://www.markzhang.cn/blog/2014/11/25/thunderbird-72-column/"/>
    <updated>2014-11-25T11:13:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2014/11/25/thunderbird-72-column</id>
    <content type="html"><![CDATA[<p>这个需求做linux kernel upstream的人都懂的&hellip;&hellip;要设置Thunderbird在80列正确换行，只需要这样：</p>

<!-- more -->


<ul>
<li><p>Thunderbird如果撰写的邮件是plain text格式（在这里设置：Edit &ndash;> Account Settings &ndash;> Composition &amp; Addressing, you should uncheck Compose in HTML format for all accounts），那么自动就会在72列处做line wrap。但是需要注意的是，这里的line wrap只是在display邮件内容和撰写邮件时，你可以看到。当你发出邮件的时候，这个line wrap就没有了，换句话说，别人看到的你的邮件内容，还是很长的一行行的文字。所以需要下面一步。</p></li>
<li><p>以下内容来自：</p></li>
</ul>


<p><a href="http://arapulido.com/2009/12/01/enabling-line-wrapping-in-thunderbird/#comment-807">http://arapulido.com/2009/12/01/enabling-line-wrapping-in-thunderbird/#comment-807</a></p>

<p>下文中提到的option设置在：Edit &ndash;> Preferences &ndash;> Advanced (General tab) &ndash;> Configure Editor：</p>

<blockquote><p>I am a happy user of the daily build of Thunderbird 3. Although it is still under development, is the best email client for Linux I’ve tried so far, at least, the one that better works for me. Email search &amp; filtering is fast and reliable.</p>

<p>The only thing I don’t like is that wrapping your emails to 72 characters when sending plain text is not straightforward. Once you have selected to send your emails as plain text and have set the line wrap option to 72, there is still one more option to tweak.</p>

<p>Thunderbird has a “feature” that sends by default all plain text with the option format=flowed, which unwraps the email in the client receiver. To turn this feature off, you have to toggle one of the options in the chrome editor:</p>

<p>To disable flowed paragraphs, enforcing line breaks as formatted in the message, set the preference:</p>

<p>mailnews.display.disable_format_flowed_support true
(<a href="http://kb.mozillazine.org/Mail_content_types#Plain_text">http://kb.mozillazine.org/Mail_content_types#Plain_text</a>)</p>

<p>To disable paragraph flow when you send plain text messages, and in the plain text part of multipart messages, set the preference:</p>

<p>mailnews.send_plaintext_flowed false
(<a href="http://kb.mozillazine.org/Mail_content_types#Disabling_paragraph_flow">http://kb.mozillazine.org/Mail_content_types#Disabling_paragraph_flow</a>)</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ChromeOS配置SSH Server]]></title>
    <link href="http://www.markzhang.cn/blog/2014/10/17/chromeos-enable-ssh-server/"/>
    <updated>2014-10-17T12:52:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2014/10/17/chromeos-enable-ssh-server</id>
    <content type="html"><![CDATA[<p>ChromeOS是一个相当"Linux"的OS。现在一般能拿到手的ChromeOS的设备很多都是Chromebook，所以本文是在一台Chromebook上做的测试。</p>

<p>ChromeOS默认的零售版本是什么开发类工具都没有的，包括ssh client都没有。要enable SSH client/server，首先要将ChromeOS切换到 <code>Developer Mode</code>。在我手上的这台Chromebook上，做法很简单，就是三键同按开机即可（ESC + Refresh + Power）。</p>

<p>具体的切换到 <code>Developer Mode</code> 的做法可以参考Google的ChromeOS网站上的文章。接下来来看怎么enable SSH Server。</p>

<!-- more -->


<p>以下内容完全参考了文章：</p>

<p><a href="http://www.de7ec7ed.com/2013/05/ssh-daemon-samsung-chromebook-exynos.html">http://www.de7ec7ed.com/2013/05/ssh-daemon-samsung-chromebook-exynos.html</a></p>

<p>所以在这里基本上是做一个英翻中的工作。</p>

<ul>
<li><p>首先启动Chrome浏览器，按下 <code>ctrl + alt + t</code>，开启Crosh（浏览器界面的一个Terminal程序）。Crosh也是只有将ChromeOS切换成 <code>Developer Mode</code> 之后才有的。</p></li>
<li><p>输入：<code>shell</code>，得到一个bash，然后输入 <code>sudo -i</code>，就可以得到root权限了。</p></li>
<li><p>mkdir -p /mnt/stateful_partition/etc/ssh</p></li>
<li><p>ssh-keygen -t dsa -f /mnt/stateful_partition/etc/ssh/ssh_host_dsa_key</p></li>
<li><p>ssh-keygen -t rsa -f /mnt/stateful_partition/etc/ssh/ssh_host_rsa_key</p></li>
<li><p>vi /etc/ssh/sshd_config，将 <code>PasswordAuthentication</code> 改成 <code>yes</code>。在这里也可以看到，为什么我们要在/mnt/stateful_partition下面创建etc/ssh目录，并在里面生成keys。就是因为在这个配置文件中指定了ssh key的路径。</p></li>
<li><p>/sbin/iptables -A INPUT -p tcp &mdash;dport 22 -j ACCEPT</p></li>
<li><p>给root用户设置一个密码，输入passwd即可。</p></li>
<li><p>/usr/sbin/sshd，这样SSH server就启动起来了，可以从其他机器登录过来了。</p></li>
</ul>


<p>题外话：如果你是 <code>cd /usr/sbin;./sshd</code>，或者 <code>/usr/sbin</code> 在PATH里面，直接输入 <code>sshd</code> 启动，你会发现sshd无法启动，错误是：</p>

<blockquote><p>sshd re-exec requires execution with an absolute path</p></blockquote>

<p>Stackexchange有这个问题的回答，很有意思，有两点：</p>

<blockquote><p>This is specific to OpenSSH from version 3.9 onwards.</p>

<p>For every new connection, sshd will re-execute itself, to ensure that all execute-time randomisations are re-generated for each new connection. In order for sshd to re-execute itself, it needs to know the full path to itself.</p>

<p>Here&rsquo;s a quote from the release notes for 3.9:</p>

<p>Make sshd(8) re-execute itself on accepting a new connection. This security measure ensures that all execute-time randomisations are reapplied for each connection rather than once, for the master process' lifetime. This includes mmap and malloc mappings, shared library addressing, shared library mapping order, ProPolice and StackGhost cookies on systems that support such things</p></blockquote>

<p>另外一个说法也有一定道理：</p>

<blockquote><p>This is to prevent someone from injecting a sshd program somewhere in one of the directories in your PATH and you inadvertently executing it.</p></blockquote>

<p>回到SSH server的配置上来，如果想ChromeOS开机的时候启动SSHD，写这样一个脚本放到 <code>/etc/init</code> 目录下面即可：</p>

<p>``` bash
start on started system-services
script</p>

<pre><code> /sbin/iptables -A INPUT -p tcp --dport 22 -j ACCEPT
 /usr/sbin/sshd
</code></pre>

<p>end script
```</p>

<p>最后，突然想到，要做上面的所有的事情，要求ChromeOS的root partition是可写的，但是默认情况下，ChromeOS的root partition是read-only的。需要修改的话这样做：</p>

<ul>
<li><p>/usr/share/vboot/bin/make_dev_ssd.sh &mdash;remove_rootfs_verification &mdash;partitions 2</p></li>
<li><p>做完上述命令后，需要重启ChromeOS</p></li>
<li><p>重启完成之后，再开启一个Crosh，执行：mount -o rw,remount /，就可以将root partition变成可写的了。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CloneZilla磁盘克隆，超快的更换硬盘]]></title>
    <link href="http://www.markzhang.cn/blog/2014/06/03/ubuntu-disk-clone/"/>
    <updated>2014-06-03T12:49:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2014/06/03/ubuntu-disk-clone</id>
    <content type="html"><![CDATA[<p>开发用的PC机用的是一块128G的SSD，安装的Ubuntu 12.04，速度明显比机械硬盘快了好多，唯一的不足就是容量太小。于是最近购入了一块新的240G的SSD，需要将原来128G的SSD上的东西全部克隆过来。</p>

<p>对于Linux ext4文件分区系统的磁盘来说，<code>ghost</code>工作的并不好，工作的比较好的是<code>CloneZilla</code>，因为它能识别ext4的文件系统，从而使克隆变的无比快速，之前我写过一篇类似的文章：</p>

<p><a href="http://www.cnblogs.com/super119/archive/2012/09/26/2703479.html">http://www.cnblogs.com/super119/archive/2012/09/26/2703479.html</a></p>

<p>但是那一次的克隆是两块容量一样的磁盘，而这一次两块SSD的容量并不相同，所以我做了一些改变。</p>

<!-- more -->


<p>两块磁盘的容量不一样，我能想到的问题是，如果是克隆整块硬盘的话，那MBR部分也会被克隆过去，也就是说，源磁盘的分区信息也会被克隆到目的盘上，这样，会不会240G的SSD就会变成120G？我没有试验，有可能 <code>CloneZilla</code> 能帮我们解决这个问题，但是为了避免麻烦，我还是手动的克隆了。</p>

<p>所以我的做法是，不是克隆整个硬盘，而是只克隆源磁盘上的分区。完成之后，在目的盘上重建MBR信息，也就是在目的盘上恢复grub。具体我是这么做的：</p>

<ul>
<li><p>使用Ubuntu 12.04安装盘，进入Ubuntu Live（不是安装Ubuntu那个选项），然后使用Ubuntu的Disk Utility给目的盘分区</p></li>
<li><p>使用CloneZilla的启动ISO启动系统，可以把这个ISO刻成光盘，也可以使用UltraISO这种工具将ISO烧录到U盘上，然后从USB启动电脑。启动起来之后，按照 <code>CloneZilla</code> 提供的向导，一步一步进行即可，超级简单。将源磁盘每个分区都克隆到目的盘对应的分区上即可。100G的数据五分钟搞定。</p></li>
</ul>


<p><img src="/downloads/image/clonezilla.jpg" alt="CloneZilla Cloning" /></p>

<ul>
<li>接下来就可以将源磁盘从机器中拿出来了，我们只需要再把目的磁盘的MBR恢复就可以成功启动系统了。其实就是恢复grub的标准做法：首先还是使用Ubuntu的安装盘进入Ubuntu Live，然后打开终端，输入以下命令：</li>
</ul>


<p>``` bash</p>

<h1>Mount root partition to /mnt</h1>

<p>sudo mount /dev/sda1 /mnt
sudo mount &mdash;bind /dev /mnt/dev
sudo mount &mdash;bind /dev/pts /mnt/dev/pts
sudo mount &mdash;bind /proc /mnt/proc
sudo mount &mdash;bind /sys /mnt/sys</p>

<h1>Chroot into it and update grub</h1>

<p>sudo chroot /mnt
grub-install /dev/sda
grub-install &mdash;recheck /dev/sda
update-grub
exit</p>

<h1>Quit chroot environment and umount all stuffs</h1>

<p>sudo umount /mnt/dev &amp;&amp;
sudo umount /mnt/dev/pts &amp;&amp;
sudo umount /mnt/proc &amp;&amp;
sudo umount /mnt/sys &amp;&amp;
sudo umount /mnt
```</p>

<p>这样就完成了，在我的机器上，/dev/sda就是我新更换的240G的SSD，你需要根据你的机器上的磁盘配置来决定使用哪个磁盘。</p>

<p>上述操作来自文章：</p>

<p><a href="http://howtoubuntu.org/how-to-repair-restore-reinstall-grub-2-with-a-ubuntu-live-cd">http://howtoubuntu.org/how-to-repair-restore-reinstall-grub-2-with-a-ubuntu-live-cd</a></p>
]]></content>
  </entry>
  
</feed>
