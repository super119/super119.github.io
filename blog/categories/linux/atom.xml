<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux | Make Things Cool]]></title>
  <link href="http://markzhang.cn/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://markzhang.cn/"/>
  <updated>2016-01-08T10:03:45+08:00</updated>
  <id>http://markzhang.cn/</id>
  <author>
    <name><![CDATA[Mark Zhang]]></name>
    <email><![CDATA[super119@139.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[netstat -na输出中Recv-Q和Send-Q两项的值不为零需要注意程序是否有问题]]></title>
    <link href="http://markzhang.cn/blog/2016/01/07/recv-q-send-q/"/>
    <updated>2016-01-07T10:59:00+08:00</updated>
    <id>http://markzhang.cn/blog/2016/01/07/recv-q-send-q</id>
    <content type="html"><![CDATA[<p>Recv-Q：表示收到的数据中还有多少没有被进程取走（通过recv）</p>

<p>Send-Q：表示需要发送的数据还有多少没有被发出</p>

<p>所以，一般来说这两个值都是0，如果不为0且持续增长，那就表明程序出现了问题。</p>

<p>比如Recv-Q的数字持续增长，表示没有进程去取这些收到的数据。比如使用select+recv来收数据的时候，由于select有1024这个限制，所以如果socket的FD大于1024的时候，就会导致这个socket FD上的数据不会被select检测到从而导致recv不会被调用。</p>

<p>所以，通过netstat的这两个值就可以简单判断程序收不到包到底是包没到还是包没有被进程recv。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Cron的一些小Tips]]></title>
    <link href="http://markzhang.cn/blog/2016/01/04/cron-tips/"/>
    <updated>2016-01-04T10:08:00+08:00</updated>
    <id>http://markzhang.cn/blog/2016/01/04/cron-tips</id>
    <content type="html"><![CDATA[<ul>
<li><p>crontab -e编辑定时任务，crontab -l查看。最后的cron任务文件保存在/var/spool/cron/crontab目录下</p></li>
<li><p>cron会切换到/var/spool/cron/crontab目录下cron文件的owner这个用户，然后执行定义的定时任务。</p></li>
<li><p>但是cron切换用户的时候，任何环境变量，包括.bashrc都不会被执行到。所以诸如$HOME这样的变量也是没有定义的。所以，一般在定时任务的脚本中，我们会这样处理：</p></li>
</ul>


<p>``` bash</p>

<h1>!/bin/bash</h1>

<p>HOME=/home/markz
source ${HOME}/.bashrc
export PATH=/usr/local/bin:$PATH
&hellip;. <tasks>
```</p>

<p>有一点注意，~/.bashrc往往都含有大量的定义和脚本执行，这有可能会影响到source的成功执行。我们之所以在需要cron的脚本中加入这句source，大多数情况下是为了定义一些环境变量。所以为了让source能保证成功，一般我们都会把需要的环境变量单独存放到一个文件中，然后去source那个文件即可。直接source ~/.bashrc不是一个好的做法。</p>

<ul>
<li>/var/log/syslog保存了cron的log，查看该log可以方便的知道定时任务执行的一些情况。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Compile: what is softfp & hardfp?]]></title>
    <link href="http://markzhang.cn/blog/2016/01/04/softfp-hardfp/"/>
    <updated>2016-01-04T09:56:00+08:00</updated>
    <id>http://markzhang.cn/blog/2016/01/04/softfp-hardfp</id>
    <content type="html"><![CDATA[<p>hardfp compiles inline FP instructions.  If you have an FPU this will be fastest.  If you don&rsquo;t, every FP instruction will trap to an emulation routine (assuming your runtime supports this).</p>

<!-- more -->


<p>softfp will compile a library call for every FP operation.  Use this if you never run on a system with an FPU.</p>

<p>来自gcc的manual：</p>

<blockquote><p>-mfloat-abi=name       Specifies which floating-point ABI to use.  Permissible values are: soft, softfp and hard.</p>

<p>Specifying soft causes GCC to generate output containing library calls for floating-point operations.  softfp allows the generation of code using hardware floating-point instructions, but still uses the soft-float calling conventions.  hard allows generation of floating-point instructions and uses FPU-specific calling conventions.</p>

<p>The default depends on the specific target configuration.  Note that the hard-float and soft-float ABIs are not link-compatible; you must compile your entire program with the same ABI, and link with a compatible set of libraries.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UTF-8 Encoding rules]]></title>
    <link href="http://markzhang.cn/blog/2016/01/03/utf8-encoding-rules/"/>
    <updated>2016-01-03T11:38:00+08:00</updated>
    <id>http://markzhang.cn/blog/2016/01/03/utf8-encoding-rules</id>
    <content type="html"><![CDATA[<p><code>cpp
/* UTF-8 encoding
00000000-01111111  00-7F  US-ASCII (single byte)
10000000-10111111  80-BF  Second, third, or fourth byte of a multi-byte sequence
11000000-11011111  C0-DF  Start of 2-byte sequence
11100000-11101111  E0-EF  Start of 3-byte sequence
11110000-11110100  F0-F4  Start of 4-byte sequence
*/
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux通过sendmsg在进程中共享FD]]></title>
    <link href="http://markzhang.cn/blog/2015/12/25/share-fd-by-sendmsg/"/>
    <updated>2015-12-25T10:57:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/12/25/share-fd-by-sendmsg</id>
    <content type="html"><![CDATA[<p>对于现代Linux来说，FD的使用变的越来越广泛。FD不光用于一个文件或设备的打开句柄，现在FD还往往会用于一些其他数据类型的句柄，比如一块buffer。</p>

<p>对于一些要避免拷贝的buffer来说（比如一块用于display的buffer，或者一块用于render的buffer），使用FD来表示这块buffer并在不同进程中传递就被使用的越来越广泛。而且进程退出（不管是正常退出还是被杀）的时候，FD还能被kernel回收，再加上 <code>reference count</code>，这块buffer就不会有泄漏的问题。看看Android和Linux kernel的代码就会发现，现在使用FD的这种例子是越来越多了。</p>

<p>在userspace，进程共享FD可以通过 <code>sendmsg</code> 来实现：</p>

<!-- more -->


<p>man 7 unix</p>

<p>man sendmsg</p>

<p>sendmsg可以发送control message，也就是不是普通的regular数据。看sendmsg的manual可以知道。</p>

<p>control message其实也是指定一个指针和一个长度，和普通数据一样。</p>

<p>有趣的事，control message可以发送一个FD（或一组，以数组方式组织）给另外一个进程。不是说把FD这个数字发给了别人，而是这个FD真正的另外一个进程中存在，而且和发送进程的FD指向的是一个struct file</p>

<p>简单来说，就好象接收进程dup了发送进程的那个FD一样。事实上嘛，大家都懂的，其实就是kernel帮助接收进程dup了一下而已。。。</p>

<p>在man 7 unix中搜索SCM_RIGHTS可以看到具体用法和信息。</p>

<p>有个条件是：必须工作在UNIX这个socket domain上（AF_UNIX），TCP/IP socket domain是不行的。</p>
]]></content>
  </entry>
  
</feed>
