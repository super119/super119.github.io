<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux | Make Things Cool]]></title>
  <link href="http://markzhang.cn/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://markzhang.cn/"/>
  <updated>2016-01-06T09:49:52+08:00</updated>
  <id>http://markzhang.cn/</id>
  <author>
    <name><![CDATA[Mark Zhang]]></name>
    <email><![CDATA[super119@139.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用Cron的一些小Tips]]></title>
    <link href="http://markzhang.cn/blog/2016/01/04/cron-tips/"/>
    <updated>2016-01-04T10:08:00+08:00</updated>
    <id>http://markzhang.cn/blog/2016/01/04/cron-tips</id>
    <content type="html"><![CDATA[<ul>
<li><p>crontab -e编辑定时任务，crontab -l查看。最后的cron任务文件保存在/var/spool/cron/crontab目录下</p></li>
<li><p>cron会切换到/var/spool/cron/crontab目录下cron文件的owner这个用户，然后执行定义的定时任务。</p></li>
<li><p>但是cron切换用户的时候，任何环境变量，包括.bashrc都不会被执行到。所以诸如$HOME这样的变量也是没有定义的。所以，一般在定时任务的脚本中，我们会这样处理：</p></li>
</ul>


<p>``` bash</p>

<h1>!/bin/bash</h1>

<p>HOME=/home/markz
source ${HOME}/.bashrc
export PATH=/usr/local/bin:$PATH
&hellip;. <tasks>
```</p>

<p>有一点注意，~/.bashrc往往都含有大量的定义和脚本执行，这有可能会影响到source的成功执行。我们之所以在需要cron的脚本中加入这句source，大多数情况下是为了定义一些环境变量。所以为了让source能保证成功，一般我们都会把需要的环境变量单独存放到一个文件中，然后去source那个文件即可。直接source ~/.bashrc不是一个好的做法。</p>

<ul>
<li>/var/log/syslog保存了cron的log，查看该log可以方便的知道定时任务执行的一些情况。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Compile: what is softfp & hardfp?]]></title>
    <link href="http://markzhang.cn/blog/2016/01/04/softfp-hardfp/"/>
    <updated>2016-01-04T09:56:00+08:00</updated>
    <id>http://markzhang.cn/blog/2016/01/04/softfp-hardfp</id>
    <content type="html"><![CDATA[<p>hardfp compiles inline FP instructions.  If you have an FPU this will be fastest.  If you don&rsquo;t, every FP instruction will trap to an emulation routine (assuming your runtime supports this).</p>

<!-- more -->


<p>softfp will compile a library call for every FP operation.  Use this if you never run on a system with an FPU.</p>

<p>来自gcc的manual：</p>

<blockquote><p>-mfloat-abi=name       Specifies which floating-point ABI to use.  Permissible values are: soft, softfp and hard.</p>

<p>Specifying soft causes GCC to generate output containing library calls for floating-point operations.  softfp allows the generation of code using hardware floating-point instructions, but still uses the soft-float calling conventions.  hard allows generation of floating-point instructions and uses FPU-specific calling conventions.</p>

<p>The default depends on the specific target configuration.  Note that the hard-float and soft-float ABIs are not link-compatible; you must compile your entire program with the same ABI, and link with a compatible set of libraries.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UTF-8 Encoding rules]]></title>
    <link href="http://markzhang.cn/blog/2016/01/03/utf8-encoding-rules/"/>
    <updated>2016-01-03T11:38:00+08:00</updated>
    <id>http://markzhang.cn/blog/2016/01/03/utf8-encoding-rules</id>
    <content type="html"><![CDATA[<p><code>cpp
/* UTF-8 encoding
00000000-01111111  00-7F  US-ASCII (single byte)
10000000-10111111  80-BF  Second, third, or fourth byte of a multi-byte sequence
11000000-11011111  C0-DF  Start of 2-byte sequence
11100000-11101111  E0-EF  Start of 3-byte sequence
11110000-11110100  F0-F4  Start of 4-byte sequence
*/
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux通过sendmsg在进程中共享FD]]></title>
    <link href="http://markzhang.cn/blog/2015/12/25/share-fd-by-sendmsg/"/>
    <updated>2015-12-25T10:57:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/12/25/share-fd-by-sendmsg</id>
    <content type="html"><![CDATA[<p>对于现代Linux来说，FD的使用变的越来越广泛。FD不光用于一个文件或设备的打开句柄，现在FD还往往会用于一些其他数据类型的句柄，比如一块buffer。</p>

<p>对于一些要避免拷贝的buffer来说（比如一块用于display的buffer，或者一块用于render的buffer），使用FD来表示这块buffer并在不同进程中传递就被使用的越来越广泛。而且进程退出（不管是正常退出还是被杀）的时候，FD还能被kernel回收，再加上 <code>reference count</code>，这块buffer就不会有泄漏的问题。看看Android和Linux kernel的代码就会发现，现在使用FD的这种例子是越来越多了。</p>

<p>在userspace，进程共享FD可以通过 <code>sendmsg</code> 来实现：</p>

<!-- more -->


<p>man 7 unix</p>

<p>man sendmsg</p>

<p>sendmsg可以发送control message，也就是不是普通的regular数据。看sendmsg的manual可以知道。</p>

<p>control message其实也是指定一个指针和一个长度，和普通数据一样。</p>

<p>有趣的事，control message可以发送一个FD（或一组，以数组方式组织）给另外一个进程。不是说把FD这个数字发给了别人，而是这个FD真正的另外一个进程中存在，而且和发送进程的FD指向的是一个struct file</p>

<p>简单来说，就好象接收进程dup了发送进程的那个FD一样。事实上嘛，大家都懂的，其实就是kernel帮助接收进程dup了一下而已。。。</p>

<p>在man 7 unix中搜索SCM_RIGHTS可以看到具体用法和信息。</p>

<p>有个条件是：必须工作在UNIX这个socket domain上（AF_UNIX），TCP/IP socket domain是不行的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ubuntu 12.04安装Microsoft lifecam studio摄像头]]></title>
    <link href="http://markzhang.cn/blog/2015/12/24/ubuntu-install-microsoft-camera/"/>
    <updated>2015-12-24T09:20:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/12/24/ubuntu-install-microsoft-camera</id>
    <content type="html"><![CDATA[<p>这是一个UVC摄像头，所以可以使用uvcvideo这个kernel驱动，一般kernel都编译了这个module。</p>

<p>什么是UVC？</p>

<p>UVC，全称为：USB video class 或USB video device class</p>

<!-- more -->


<p>UVC是Microsoft与另外几家设备厂商联合推出的为USB视频捕获设备定义的协议标准，目前已成为USB org标准之一。</p>

<p>如今的主流操作系统(如Windows XP SP2 and later, Linux 2.4.6 and later, MacOS 10.5 and later)都已提供UVC设备驱动，因此符合UVC规格的硬件设备在不需要安装任何的驱动程序下即可在主机中正常使用。使用UVC技术的包括摄像头、数码相机、类比影像转换器、电视棒及静态影像相机等设备。</p>

<p>最新的UVC版本为UVC 1.1，由USB Implementers Forum定义包括基本协议及负载格式。</p>

<p>网络摄像头是第一个支持UVC而且也是数量最多的UVC设备，目前，操作系统只要是 Windows XP SP2 之后的版本都可以支持 UVC，当然 Vista 就更不用说了。Linux系统自2.4以后的内核都支持了大量的设备驱动，其中支持UVC设备。</p>

<p>使用 UVC 的好处 USB 在 Video这块也成为一项标准了之后，硬件在各个程序之间彼此运行会更加顺利，而且也省略了驱动程序安装这一环节。</p>

<p>所以，apt-get一下guvcview就可以看到图像了。</p>

<p>问题：</p>

<p><strong> 第一个问题 </strong></p>

<p>也是uvc驱动官方网站给出的问题，就是有关这款摄像头每次都请求最大USB带宽的问题，需要给uvcvideo这个kernel module添加一个参数，具体做法是：</p>

<p><code>bash
sudo rmmod uvcvideo
sudo modprobe uvcvideo quirks=0x80
重新插拔摄像头
cat /sys/module/uvcvideo/parameters/quirks来检验是否设置成功了。
</code></p>

<p>参考资料：<a href="http://www.ideasonboard.org/uvc/faq/#faq6">http://www.ideasonboard.org/uvc/faq/#faq6</a></p>

<p><strong> 第二个问题 </strong></p>

<p>有的时候会发现好好的图像定格了，或者是整个摄像头设备都没了（在lsusb中看不到了）。此外还有个现象就是，摄像头上的蓝灯会莫名其妙的闪烁起来。Google下，这是由于Chrome中的Peperflash造成的。所以，禁用PeperFlash，安装Adobe的flash即可。做法：</p>

<p>打开chrome，输入about:plugins，点右上角Details，Disable PeperFlash</p>

<p>在Adobe网站下载11.2的flashplayer，可以下载.tar.gz包那个版本，解开，得到libflashplayer.so和一个usr目录。</p>

<p><code>bash
sudo mkdir /opt/google/chrome/plugins
sudo cp &lt;libflashplayer.so&gt; /opt/google/chrome/plugins
sudo cp usr/* /usr
</code></p>

<p>重启Chrome，再次进入about:plugins，发现11.2的Adobe flash是enable的，PeperFlash是disable的，就OK了。</p>

<p>貌似PeperFlash是Chrome自带的一个flashplayer，有GPU加速。</p>

<p>Adobe的Linux flashplayer不会再有新版本，但是会有安全更新。</p>
]]></content>
  </entry>
  
</feed>
