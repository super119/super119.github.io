<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: git | Make Things Cool]]></title>
  <link href="http://www.markzhang.cn/blog/categories/git/atom.xml" rel="self"/>
  <link href="http://www.markzhang.cn/"/>
  <updated>2014-04-09T17:40:13+08:00</updated>
  <id>http://www.markzhang.cn/</id>
  <author>
    <name><![CDATA[Mark Zhang]]></name>
    <email><![CDATA[super119@139.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Git都在说些啥（一）]]></title>
    <link href="http://www.markzhang.cn/blog/2014/04/04/git-gossip-1/"/>
    <updated>2014-04-04T14:28:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2014/04/04/git-gossip-1</id>
    <content type="html"><![CDATA[<p>当我们在做某些git操作的时候，git有的时候会给出一段一段的提示信息，而往往这些信息都是比较重要的。因为按照UNIX的设计哲学，执行成功或是无害操作，这些都是不会有任何提示信息的。做Linux的Hackers也奉行这种哲学，所以当git开始唠叨的时候，你真的需要关注一下它到底在罗嗦些啥。</p>

<p>这篇文章描述的就是某一个git的唠叨。</p>

<!-- more -->


<p>有的时候，特别是当执行 <code>git checkout</code> 的时候，你可能会看到这样的信息：</p>

<blockquote><p>Warning: you are leaving 30 commits behind, not connected to
any of your branches:</p>

<p>2553655 Merge branch &lsquo;master&rsquo; into prod</p>

<p>6b07300 Fix build</p>

<p>&hellip; and 28 more.</p>

<p>If you want to keep them by creating a new branch, this may be a good time
to do so with:</p>

<p>git branch new_branch_name 654646464</p></blockquote>

<p>注：以上信息来自：<a href="https://groups.google.com/forum/#!topic/git-users/4XC8KhZ-cBM">https://groups.google.com/forum/#!topic/git-users/4XC8KhZ-cBM</a></p>

<p>所以git的这段罗嗦到底是什么意思？</p>

<p>发生这种情况时，你一般工作在 <code>no branch</code> 上，也就是说，这个branch没有名字。也就是说，一旦你发生了 <code>git checkout</code> 操作之后，无法你是checkout到了一个有名字的branch，还是没有指定checkout的branch，就是更新本地的文件，这个 <code>no branch</code> 就再也回不去了，因为这个branch没有名字，所以你无法告诉git，我需要再回到这个branch上去。</p>

<p>基于此，如果你在 <code>no branch</code> 上有一些commit（无论是你自己commit的，还是你cherry-pick的），那么，当发生 <code>git checkout</code> 的时候，git就会给出上面的信息，告诉你，如果你现在不做点事的话，之前你所在的 <code>no branch</code> 就再也回不去了，所以，这个时候你最好建一个branch来保证你还能回到 <code>no branch</code> 上去：</p>

<blockquote><p>If you want to keep them by creating a new branch, this may be a good time
to do so with:</p>

<p>git branch new_branch_name 654646464</p></blockquote>

<p>事实上，如果你真的碰到了这种情况，而且当git给出上面一段信息告诉了你利害关系之后，你仍然义无反顾的无视了git的警告，没有创建一个有名字的branch来保存之前你在 <code>no branch</code> 上的工作成果，最终在某一天你想起来，想要找回N久之前在 <code>no branch</code> 上的一些commit的话，你仍然还有一根救命稻草：</p>

<p><code>git reflog</code></p>

<p>基本上，<code>git reflog</code> 将给出所有“失联”的commit。也就是说，这些commit不属于任何branch（no connection），从git数据库中删掉也无所谓。</p>

<p>所以，你最好期望 <code>git reflog</code> 中有你需要的commit，因为就像上面所说，这些commit本就是可以被安全删除的commit，如果你做过 <code>git gc</code>，或者是git自动做过 <code>git gc</code> 的话（git有一套逻辑来判断什么时候应该做一次gc），这些commit就真的没有了。</p>

<p>注：上面一段说的有点严重，事实上，git对待失联的commit，有一个expire time的设定，所以也不是说一旦执行过 <code>git gc</code>，这些commit就真的没有了。但是为了安全起见，对于重要的commit，还是需要注意不要丢了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git常见命令和配置]]></title>
    <link href="http://www.markzhang.cn/blog/2013/11/20/git-tips/"/>
    <updated>2013-11-20T21:01:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2013/11/20/git-tips</id>
    <content type="html"><![CDATA[<h2>常用配置</h2>

<p>``` cfg git常用配置
[color]</p>

<pre><code>    ui = auto
</code></pre>

<p>[user]</p>

<pre><code>    name = Mark Zhang
    email = xxxx@xxxx.xxx
</code></pre>

<p>[core]</p>

<pre><code>    editor = vim
    abbrev = 12
    pager = less -X -F
</code></pre>

<p>[diff]</p>

<pre><code>    tool = vimdiff
    renames = true
</code></pre>

<p>[difftool]</p>

<pre><code>    prompt = No
</code></pre>

<p>[sendemail]</p>

<pre><code>    chainreplyto = false
    smtpserver = xxxxxxxx
    smtpencryption = tls
    from = Mark Zhang &lt;xxxx@xxx.xxx&gt;
    envelopesender = auto
</code></pre>

<p>[alias]</p>

<pre><code>    s = status
    cp = cherry-pick
    ck = checkout
    b = branch
    lo = log --oneline
    dt = difftool
</code></pre>

<p>```</p>

<!-- more -->


<h2>常用命令</h2>

<ul>
<li><code>git remote add &lt;name&gt; &lt;url&gt;</code></li>
</ul>


<p>如果要添加本地的一个git repository的话，<url>填写成 <code>git repository的路径/.git</code> 即可。</p>

<ul>
<li><p><code>git fetch -p &lt;remote name, e.g: origin&gt;</code></p></li>
<li><p><code>git show &lt;commit id&gt;</code></p></li>
<li><p><code>git push origin HEAD:next</code></p></li>
</ul>


<p>Push本地HEAD commit对应的branch到名为 <code>origin</code> 的远端仓库的 <code>next</code> branch上。</p>

<ul>
<li><code>git push origin +HEAD:next / git push -f origin HEAD:next</code></li>
</ul>


<p>所谓的Force update，也就是用本地的commit历史覆盖远端的。</p>

<ul>
<li><code>git push origin :next</code></li>
</ul>


<p>删除远端仓库的 <code>next</code> branch。</p>

<ul>
<li><code>git push --tags</code></li>
</ul>


<p>Push本地的tag列表到远端。</p>

<ul>
<li><p><code>git format-patch -&lt;N&gt;</code></p></li>
<li><p><code>git format-patch &lt;commit id&gt;^..&lt;commit id&gt;</code></p></li>
</ul>


<p>这个命令可以用来为一个指定的commit生成patch。</p>

<ul>
<li><p><code>git format-patch --subject-prefix 'PATCH V2' --cover-letter</code></p></li>
<li><p><code>git send-email --to=XXX --to=XXX --cc=XXX *.patch</code></p></li>
<li><p><code>git send-email --no-signed-off-cc --to=XXX --to=XXX --cc=XXX *.patch</code></p></li>
<li><p><code>git rebase -i &lt;commit id&gt;</code></p></li>
<li><p><code>git checkout &lt;branch&gt; -- &lt;file path&gt;</code></p></li>
</ul>


<p>这个命令将指定branch中的指定文件checkout出来，更新当前working tree中的对应文件。</p>

<ul>
<li><code>git show &lt;branch&gt;:&lt;file path&gt; &gt;&amp; &lt;filename&gt;</code></li>
</ul>


<p>这个命令将指定branch中的指定文件checkout出来，并存到 <code>&lt;filename&gt;</code> 指定的路径上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linus说，请将这个配置加到你的.gitconfig]]></title>
    <link href="http://www.markzhang.cn/blog/2013/11/07/linus-git-config/"/>
    <updated>2013-11-07T18:18:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2013/11/07/linus-git-config</id>
    <content type="html"><![CDATA[<p>近日Linus说，请将 <code>git config core.abbrev 12</code> 加到你的git repository中。事实上，这个config很有意义，可以加到你的全局git config中：</p>

<!-- more -->


<p><code>git config --global core.abbrev 12</code>。</p>

<p>原因简单来说就是，git默认的7个字符的短HASH表示方法经常导致冲突，所以Linus建议改成12个字符。原文引用如下：</p>

<blockquote><p>Linus jumped in to say that he would like everybody to run this command in their repositories:</p>

<p>   git config core.abbrev 12</p>

<p>That causes git to abbreviate commit hashes to 12 characters. The default of seven characters is too small to prevent occasional hash collisions in the kernel; it was, he said, a big mistake made early in git&rsquo;s history. He also noted that he spends a lot of time fixing up hashes in patch, many of which are &ldquo;clearly bogus.&rdquo; Most of the problems, most likely, are caused by the rebasing of trees.</p></blockquote>
]]></content>
  </entry>
  
</feed>
