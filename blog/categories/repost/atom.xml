<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: repost | Make Things Cool]]></title>
  <link href="http://www.markzhang.cn/blog/categories/repost/atom.xml" rel="self"/>
  <link href="http://www.markzhang.cn/"/>
  <updated>2015-07-28T11:05:55+08:00</updated>
  <id>http://www.markzhang.cn/</id>
  <author>
    <name><![CDATA[Mark Zhang]]></name>
    <email><![CDATA[super119@139.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Kernel的ZONE_DMA]]></title>
    <link href="http://www.markzhang.cn/blog/2015/07/28/zone-dma/"/>
    <updated>2015-07-28T10:54:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2015/07/28/zone-dma</id>
    <content type="html"><![CDATA[<p>转载自：<a href="https://lkml.org/lkml/2011/7/6/249">https://lkml.org/lkml/2011/7/6/249</a></p>

<!-- more -->


<p>On Wed, Jul 06, 2011 at 11:19:00AM -0500, Christoph Lameter wrote:</p>

<blockquote><p>What I described is the basic memory architecture of Linux. I am not that
familiar with ARM and the issue discussed here. Only got involved because
ZONE_DMA was mentioned. The nature of ZONE_DMA is often misunderstood.</p>

<p>The allocation of the memory banks for the Samsung devices has to fit
somehow into one of these zones. Its probably best to put the memory banks
into ZONE_NORMAL and not have any dependency on ZONE_DMA at all.</p></blockquote>

<p>Let me teach you about the ARM memory management on Linux.</p>

<p>Firstly, lets go over the structure of zones in Linux.  There are three
zones &ndash; ZONE_DMA, ZONE_NORMAL and ZONE_HIGHMEM.  These zones are filled
in that order.  So, ZONE_DMA starts at zero.  Following on from ZONE_DMA
is ZONE_NORMAL memory, and lastly ZONE_HIGHMEM.</p>

<p>At boot, we pass all memory over to the kernel as follows:</p>

<ol>
<li><p>If there is no DMA zone, then we pass all low memory over as ZONE_NORMAL.</p></li>
<li><p>If there is a DMA zone, by default we pass all low memory as ZONE_DMA.
This is required so drivers which use GFP_DMA can work.</p>

<p>Platforms with restricted DMA requirements can modify that layout to
move memory from ZONE_DMA into ZONE_NORMAL, thereby restricting the
upper address which the kernel allocators will give for GFP_DMA
allocations.</p></li>
<li><p>In either case, any high memory as ZONE_HIGHMEM if configured (or memory
is truncated if not.)</p></li>
</ol>


<p>So, when we have (eg) a platform where only the <em>even</em> MBs of memory are
DMA-able, we have a 1MB DMA zone at the beginning of system memory, and
everything else in ZONE_NORMAL.  This means GFP_DMA will return either
memory from the first 1MB or fail if it can&rsquo;t.  This is the behaviour we
desire.</p>

<p>Normal allocations will come from ZONE_NORMAL <em>first</em> and then try ZONE_DMA
if there&rsquo;s no other alternative.  This is the same desired behaviour as
x86.</p>

<p>So, ARM is no different from x86, with the exception that the 16MB DMA
zone due to ISA ends up being different sizes on ARM depending on our
restrictions.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一篇文章学会电工：火线 零线 地线 中线]]></title>
    <link href="http://www.markzhang.cn/blog/2015/06/27/live-naught-earth-wires/"/>
    <updated>2015-06-27T18:20:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2015/06/27/live-naught-earth-wires</id>
    <content type="html"><![CDATA[<p>转载自：<a href="http://wenku.baidu.com/view/6aa265f57c1cfad6195fa74b.html">http://wenku.baidu.com/view/6aa265f57c1cfad6195fa74b.html</a></p>

<p>首先你要知道电为什么分为火线.&lt;也叫相线>零线&lt;也叫中性线>和接地线.&lt;也叫保护线>是从那里来的.各起什么作用的.</p>

<!-- more -->


<p>电自然是从发电机出来的这个大家都知道.发电机分为单相发电机和三相发电机.现在在电厂基本都用三相发电机.单相基本已不用&lt;当然应急发电机除外>.</p>

<p>因为三相发电机在发电机的定子上嵌放三个相同的线圈.当转子在原动机&lt;如汽轮机.水轮机>带动下切割磁感应线而在线圈中产生感生电动势.也就是电.有于三相发电机定子上有三个线圈所以会产生三相电.如果在三相发电机每个线圈各接上一个负载的话那么就会产生三个独立和单相电路.就构成了三相六线制了.如果是这样的话我要输电的话需要六根导线,很不经济,也没有实用价值.但是我们目前低压供电系统多数用三相四线制供电.三相四线是把发电机三个线圈的末端连接在一起（电流是在线圈中产生的，不清楚请复习电磁感应）,成为一个公共端点&lt;称为中性点这也就是为什么人们把零线称为中性线的原因>从中性线引出的输电线称为中性线,中性线通常与大地相接,并把接大地和中性点称为零点.始终保持与相线的零地位&lt;这也就是人们为什么把中性线称为零线的原因>.</p>

<p>第一.从电厂的发电机出来后经变电站加压后通过输电网进入工厂或用电处到工厂或用电处后再经过变压器降压后进入负载&lt;用电器>一般为三相四线制即用线色表示为黄.绿.红和蓝&lt;黄.绿.红为相线蓝为中性线也就零线>用字幕表示为A.B.C和N.但是现在国家提倡新的工厂用三相五线制也就是在原来四根线上再加根接地线&lt;不是从电厂过来的是在要用电器的地方如居民住宅楼国家强制规定必须要有接地线自己加的.主要作用为当设备漏电时把电导入大地防止人体触电>也叫PE线色为黄绿双色线&lt;IEC标准全球通用></p>

<p>第二.这五根线中中性线&lt;零线>和接地线<PE>没有电压其他三根线<ABC>电压一般为线与线之间任意二根线为400V&lt;即ABC三线中任意二根线实际为 390V左右用电时有压降被称为线电压>线与中性线之间为230V&lt;即ABC与N之间任意二根线实际为225V左右被称为相电压>.</p>

<p>第三接地线也叫保护线.那为什么要叫它保护线.你想在家里的家用电器或工厂的设备很多都是用金属做外壳的吧.那么如果万一当我电器或设备发生漏电的话那么我的电器或是设备那不是要带电了吗?如果人碰一下的话是不是要触电啊?是不是很危险啊?那么有没有方法可以当我的电器或是设备漏电时避免发生触电的事故. 有!接地线就是一种很好的保护方法.人为什么会触电.首先人是导电体,第二因为有电流流过.为什么会有电流过.因为有电压.我想欧姆定律你应当知道吧?I=U/R也就是说在电压相同的情况下电阻越大电流就越小是吧!电流还有一个特征就是那边电阻小它向那边走.人体的电阻一般为1700欧姆.那么如果接地线电阻只有4欧姆的话你看那大部分的电流会向那里走啊.没有电流流过的话那人也就不会触电了吧?其实说白了就是一句话.那就是接地线的作用就是当用电器发生漏电时把电导入大地防止人体触电!这也就是人们为什么把接地线叫为保护线的原因!</p>

<p>第四以三相电源为例如果有三条相线，一条零线和一条地线。&lt;在电路图中用字幕L1 L2 L3 表示为A B C三相.用N 表示零线或中性线.用PE表示接地线>
那就是三相五线制也就是人们通常说的TN-S系统。就是中性线《零线N》和保护线《接地线PE》是分开的。
如果三相线加一零线的那种是三相四线制也就是人们通常说的TN-C系统。就是中性线《零线N》和保护线《接地线PE》是合一的，称为PEN线。通常用保护接零的方法.共用PEN线.</p>

<p>现在国家提倡新开的工厂使用TN-S系统。如果你用三相五线制的去接三相四线制的话那要看你设备上需要了。如果在你设备上要用220V电源的话那就接中性线《零线N》。用保护接零使用。禁止把接地线当中性线《零线N》使用。如果设备上没有用220V的电源那就接接地线就可以了。</p>

<p>照明电路里的两根电线，一根叫火线，另一根则叫零线。火线和零线的区别在于它们对地的电压不同：火线的对地电压等于220V；零线的对地的电压等于零（它本身跟大地相连接在一起的）。所以当人的一部分碰上了火线，另一部分站在地上，人的这两个部分这间的电压等于220V，就有触电的危险了。反之人即使用手去抓零线，如果人是站在地上的话，由于零线的对地的电压等于零，所以人的身体各部分之间的电压等于零，人就没有触电的危险。</p>

<p>如果火线和零线一旦碰起来，由于两者之间的电压等于220伏，而两接触点间的电阻几乎等于零，这时的电流非常大，在火线和零线的接触点处将产生巨大的热量，从而发出电火花，火花处的温度高到足以把金属导线烧得熔化。</p>

<p>接地是电器设备安全技术中最重要的工作，应该认真对待。那种不加考虑随意接地的做法常常会给计算机设备造成不良的后果，严重时会烧毁整个设备应用系统，甚至造成人身伤害。正确接地可提高整个系统的抗干扰能力。</p>

<p>要正确使用计算机的电源线。目前，我们使用的电源插座大多是单相三线插座或单相二线插座。单相三线插座中，中间为接地线，也作定位用，另外两端分别接火线和零线，接线顺序是左零右火，即左边为零线，右边为火线.凡外壳是金属的家用电器都采用的是单相三线制电源插头。三个插头呈正三解形排列，其中上面最长最粗的铜制插头就是地线。地线下面两个分别是火线（标志字母为"L"Live Wire）、零线（标志字母为"N"Naught wire），顺序是左零右火，（插头背面对着自己本人时）。</p>

<p>使用中千万不要将零线端和定位用的地线端连在一起，因为有的设备采用二线插头，如果设备的电源火线、零线接反或使用中插错位置，必将造成火线、零线短路，烧坏设备，造成不可弥补的损失。因此，即使家里或单位的三线插座中没有接地，也最好使用三线电源插头和三线插座。</p>

<p>区分：</p>

<ul>
<li><p>用颜色区分：在动力电缆中黄色绿色红色分别代表A相B相C相（三相火线）蓝色代表零线，黄绿双色代表接地线。</p></li>
<li><p>用电笔区分：火线用电笔测试时会发光，而零线则不会。</p></li>
<li><p>用电压表区分：不同相线（即火线）之间的电压为线电压380V，相线（火线）与零线（或良好的接地体）之间的电压为相电压220V，零线与良好的接地体的电压为0V。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[高压输电：为什么高压输电压升高了，电流会变小呢]]></title>
    <link href="http://www.markzhang.cn/blog/2015/06/27/power-transfer/"/>
    <updated>2015-06-27T18:13:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2015/06/27/power-transfer</id>
    <content type="html"><![CDATA[<p>转载自：<a href="http://iask.sina.com.cn/b/11686110.html">http://iask.sina.com.cn/b/11686110.html</a></p>

<p>为什么高压输电线路上电压升高了，电流会变小呢，不是I=U/R么，照理说电压升高了，电流也大了，损耗也就多了啊？</p>

<!-- more -->


<p>因为输出功率是固定的。而功率等于电流乘以电压，即P=IU。这样，乘积固定，一个因数（电压U）变大，另一个因数（电流I）就要变小。</p>

<p>你引用的那个公式（I=U/R），隐含的前提是功率是可变的，所以在此不适用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GEM - Graphics Execution Manager 介绍]]></title>
    <link href="http://www.markzhang.cn/blog/2015/03/02/gem-introduction/"/>
    <updated>2015-03-02T11:15:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2015/03/02/gem-introduction</id>
    <content type="html"><![CDATA[<p>本文来自：<a href="http://lwn.net/Articles/283798/">http://lwn.net/Articles/283798/</a></p>

<p>NOTE: Currently the buffer creation/read/write are implemented by driver specified ioctls. So right now you can&rsquo;t find functions like &ldquo;drm_gem_create&rdquo; in kernel sources.
And that&rsquo;s also why we need &ldquo;dumb buffer&rdquo; in drm&rsquo;s ioctls(dumb_create, dumb_destroy&hellip;)</p>

<!-- more -->


<p>原文请看：<a href="http://lwn.net/Articles/283798/">http://lwn.net/Articles/283798/</a></p>

<p>GEM是Intel建议提出并实现的，所以这篇文章是GEM maintainer写的introduction，非常详尽，只是对照现在的kernel来说，内容已经有一点outdate（所以我写了上面的NOTE），但是大部分内容都是OK的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[转载：GEM vs TTM]]></title>
    <link href="http://www.markzhang.cn/blog/2015/03/02/gem-vs-ttm/"/>
    <updated>2015-03-02T11:09:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2015/03/02/gem-vs-ttm</id>
    <content type="html"><![CDATA[<p>本文来自: <a href="http://lwn.net/Articles/283793/">http://lwn.net/Articles/283793/</a></p>

<p>Getting high-performance, three-dimensional graphics working under Linux is quite a challenge even when the fundamental hardware programming information is available.  One component of this problem is memory management: a graphics processor (GPU) is, essentially, a computer of its own with a distinct view of memory.  Managing the GPU&rsquo;s memory &ndash; and its view of system RAM &ndash; must be done carefully if the resulting system is intended to work at all, much less with acceptable performance.</p>

<p>Not that long ago, it appeared that this problem had been solved with thetranslation table maps (TTM) subsystem.  TTM remains outside of the mainline kernel, though, as do all drivers which use it.  A recent queryabout what would be required to get TTM merged led to an interesting discussion where it turned out that, in fact, TTM may not be the future of graphics memory management after all.</p>

<!-- more -->


<p></p>

<p>A number of complaints about TTM have been raised.  Its API is far larger than is needed for any free Linux driver; it has, in other words, a certain amount of code dedicated to the needs of binary-only drivers.  The fencing mechanism (which manages concurrency between the host CPUs and the GPU) is seen as being complex, difficult to work with, and not always yielding the best performance.  Heavy use of memory-mapped buffers can create performance problems of its own.  The TTM API is an exercise in trying to provide for everything in all situations;  as a result it is, according to some driver developers, hard to match to any specific hardware, hard to get started with, and still insufficiently flexible.  And, importantly, there is a distinct shortage of working free drivers which use TTM.  So Dave Airlie worries:</p>

<blockquote><p>I was hoping that by now, one of the radeon or nouveau drivers would have adopted TTM, or at least demoed something working using it, this hasn&rsquo;t happened which worries me&hellip;  The real question is whether TTM suits the driver writers for use in Linux desktop and embedded environments, and I think so far I&rsquo;m not seeing enough positive feedback from the desktop side
All of these worries would seem to be moot, since TTM is available and there is nothing else out there.  Except, as it turns out, there issomething out there: it&rsquo;s called the Graphics Execution Manager, or GEM. The Intel-sponsored GEM project is all of one month old, as of this writing. The GEM developers had not really intended to announce their work quite yet, but the TTM discussion brought the issue to the fore.</p></blockquote>

<p>Keith Packard&rsquo;s introduction to GEM includes a document describing the API as it exists so far.  There are a number of significant differences in how GEM does things.  To begin with, GEM allocates graphical buffer objects using normal, anonymous, user-space memory.  That means that these buffers can be forced out to swap when memory gets tight.  There are clear advantages to this approach, and not just in memory flexibility: it also makes the implementation of suspend and resume easier by automatically providing backing store for all buffer objects.</p>

<p>The GEM API tries to do away with the mapping of buffers into user space. That mapping is expensive to do and brings all sorts of interesting issues with cache coherency between the CPU and GPU.  So, instead, buffer objects are accessed with simple read() and write() calls.  Or, at least, that&rsquo;s the way it would be if the GEM developers could attach a file descriptor to each buffer object.  The kernel, however, does not make the management of that many file descriptors easy (yet), so the real API uses separate handles for buffer objects and a series of ioctl()calls.</p>

<p>That said, it is possible to map a buffer object into user space.  But then the user-space driver must take explicit responsibility for the management of cache coherency.  To that end there is a set of ioctl()calls for managing the &ldquo;domain&rdquo; of a buffer; the domain, essentially, describes which component of the system owns the buffer and is entitled to operate on it.  Changing the domains (there are two, one for read access and one for writes) of a buffer will perform the necessary cache flushes.  In a sense, this mechanism resembles the streaming DMA API, where the ownership of DMA buffers can be switched between the CPU and the peripheral controller. That is not entirely surprising, as a very similar problem is being solved.</p>

<p>This API also does away with the need for explicit fence operations. Instead, a CPU operation which requires access to a buffer will simply wait, if necessary, for the GPU to finish any outstanding operations involving that buffer.</p>

<p>Finally, the GEM API does not try to solve the entire problem; a number of important operations (such as the execution of a set of GPU commands) are left for the hardware-specific driver to implement.  GEM is, thus, quite specific to the needs of Intel&rsquo;s driver at this time; it does not try for the same sort of generality that was a goal of TTM.  As describedby Eric Anholt:</p>

<blockquote><p>The problem with TTM is that it&rsquo;s designed to expose one general API for all hardware, when that&rsquo;s not what our drivers want&hellip; We&rsquo;re trying to come at it from the other direction: Implement one driver well.  When someone else implements another driver and finds that there&rsquo;s code that should be common, make it into a support library and share it.</p></blockquote>

<p>The advantage to this approach is that it makes it relatively easy to create something which works well with Intel drivers.  And that may well be a good start; one working set of drivers is better than none.  On the other hand, that means that a significant amount of work may be required to get GEM to the point where it can support drivers for other hardware.  There seem to be two points of view on how that might be done: (1) add capabilities to GEM when needed by other drivers, or (2) have each driver use its own memory manager.</p>

<p>The first approach is, in many ways, more pleasing.  But it implies that the GEM API could change significantly over time.  And that, in turn, could delay the merging of the whole thing; the GEM API is exported to user space, and, as a result, must remain compatible as things change.  So there may be resistance to a quick merge of an API which looks like it may yet have to evolve for some time.</p>

<p>The second approach, instead, is best describedby Dave Airlie:</p>

<blockquote><p>Well the thing is I can&rsquo;t believe we don&rsquo;t know enough to do this in some way generically, but maybe the TTM vs GEM thing proves its not possible.  So we can then punt to having one memory manager per driver, but I suspect this will be a maintenance nightmare, so if people decide this is the way forward, I&rsquo;m happy to see it happen. However the person submitting the memory manager n+1 must damn well be willing to stand behind the interface until time ends, and explain why they couldn&rsquo;t re-use 1..n memory managers.</p></blockquote>

<p>One other remaining issue is performance.  Keith Whitwell posted some benchmark results showing that the i915 driver performs significantly worse with either TTM or GEM than without.  Keith Packard gets different results, though; his tests show that the GEM-based driver is significantly faster.  Clearly there is a need for a set of consistent benchmarks; performance of graphics drivers is important, but performance cannot be optimized if it cannot be reliably measured.</p>

<p>The use of anonymous memory also raises some performance concerns: a first-person shooter game will not provide the same experience if its blood-and-gore textures must be continually paged in.  Anonymous memory can also be high memory, and, thus, not necessarily accessible via a 32-bit pointer.  Some GPU hardware cannot address high memory; that will likely force the use of bounce buffers within the kernel.  In the end, GEM will have to prove that it can deliver good performance; GEM&rsquo;s developers are highly motivated to make their hardware look good, so there is a reasonable chance that things will work out on this front.</p>

<p>The conclusion to draw from all of this is that the GPU memory management problem cannot yet be considered solved.  GEM might eventually become that solution, but it is a very new API which still needs a fair amount of work.  There is likely to be a lot of work yet to be done in this area.</p>

<p>(Thanks to Timo Jyrinki for suggesting this topic.)</p>
]]></content>
  </entry>
  
</feed>
