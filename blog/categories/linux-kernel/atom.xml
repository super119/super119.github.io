<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux-kernel | Make Things Cool]]></title>
  <link href="http://www.markzhang.cn/blog/categories/linux-kernel/atom.xml" rel="self"/>
  <link href="http://www.markzhang.cn/"/>
  <updated>2014-03-20T22:56:14+08:00</updated>
  <id>http://www.markzhang.cn/</id>
  <author>
    <name><![CDATA[Mark Zhang]]></name>
    <email><![CDATA[super119@139.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[KGDB使用简介]]></title>
    <link href="http://www.markzhang.cn/blog/2014/03/10/kgdb-howto/"/>
    <updated>2014-03-10T13:57:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2014/03/10/kgdb-howto</id>
    <content type="html"><![CDATA[<p>KGDB是调试linux kernel的一个工具，虽然没有userspace的gdb那么好用，但有些时候还是能派上一些用处。比如kernel启动的时候自动重启，用kgdb连上之后就可以在kernel重启之前被KGDB截获，从而打印出调用栈来。</p>

<!-- more -->


<p>具体步骤是这样：</p>

<h2>Kernel配置</h2>

<ul>
<li><code>make menuconfig</code>, under &ldquo;Kernel Hacking&rdquo;, enable &ldquo;KGDB&rdquo; &amp; &ldquo;KGDB over serial line&rdquo;. Enable &ldquo;compile kernel with debug info&rdquo;(CONFIG_DEBUG_INFO) &amp; &ldquo;enable frame pointer&rdquo;(CONFIG_FRAME_POINTER) options(both are under &ldquo;Kernel Hacking&rdquo;).</li>
</ul>


<p>有关CONFIG_FRAME_POINTER这个option，需要在enable了ARCH_CONFIG_FRAME_POINTERS这个option之后才会出现在Kernel hacking下面。</p>

<p>这ARCH_CONFIG_FRAME_POINTERS在make menuconfig里面是找不到的。这个option是专门给其他人select用的。一般都是在ARCH config的时候会去select这个option</p>

<p>比如x86下，一般会enable这个option。而ARM则不会（可能是考虑到生成的kernel文件尺寸和性能）。</p>

<p>所以，在ARM下，可以编辑arch/arm/Kconfig，在CONFIG_ARM下面的一堆select的最后，添加上一句select CONFIG_ARCH_FRAME_POINTERS就可以了。</p>

<p>从实验结果来看，只要enable了CONFIG_DEBUG_INFO，基本上就差不多了，能看到代码了。</p>

<ul>
<li>Add kernel option: <code>kgdboc=ttyS0,38400 kgdbwait</code> into kernel command line.</li>
</ul>


<p>根据我的实验，这里115200不行。在后面gdb设置<code>target remote /dev/ttyS0</code>的时候，会被告知最高支持到38400.</p>

<p>所以，这里如果115200不行，就改成38400。</p>

<p>注意这里将<code>/dev/ttyS0</code>修改成你的串口设备文件。</p>

<ul>
<li>Start kernel, kernel will wait for connection from remote PC&rsquo;s gdb.</li>
</ul>


<h2>PC端（remote machine）设置</h2>

<ul>
<li>On remote machine, <code>&lt;gdb path&gt; ./vmlinux</code> &mdash; this &ldquo;vmlinux&rdquo; mostly is under the root directory of kernel(a big kernel image with debug infos, not the one under arch/arm/boot, that is stripped version).</li>
</ul>


<p>需要注意的是，这里的GDB必须使用host是x86-64，target是ARM的那种GDB。我们PC上的gdb一般host和target都是x86-64。</p>

<p>这样的GDB可以在一些常见的toolchain网站找到，比如linaro。</p>

<ul>
<li>Enter gdb commands:</li>
</ul>


<p><code>bash
set remotebaud 38400
target remote /dev/ttyS0
</code></p>

<ul>
<li>Done. You can list source codes, set breakpoints now. Continue the debugging after finished.</li>
</ul>


<p><em>CAUTION</em>: Close any other programs(normally it&rsquo;s minicom which we use to monitor serial outputs) which may occupy &ldquo;/dev/ttyS0&rdquo; before running gdb on remote machine. Otherwise gdb can&rsquo;t connect with target board.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Device tree: interrupts的解释]]></title>
    <link href="http://www.markzhang.cn/blog/2013/11/27/dt-interrupts/"/>
    <updated>2013-11-27T20:41:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2013/11/27/dt-interrupts</id>
    <content type="html"><![CDATA[<p>Linux kernel现在使用Device tree（DT）来描述硬件设备。既然是描述硬件设备，那自然就需要对硬件充分了解才能理解DT。Interrupts就是一个例子。</p>

<p>一般来说，DT中的 <code>interrupts</code> （本文不描述interrupt controller）看起来是这样的：</p>

<p>``` c
pmu {</p>

<pre><code>compatible = "arm,cortex-a9-pmu";
interrupts = &lt;0 144 0x04
          0 145 0x04
          0 146 0x04
          0 147 0x04&gt;;
</code></pre>

<p>};
```</p>

<!-- more -->


<p>可以看到 <code>interrupts</code> 有三个member，对于这三个member，Linux kernel的文档是这样说的：</p>

<p>```
The 1st cell is the interrupt type; 0 for SPI interrupts, 1 for PPI
interrupts.</p>

<p>The 2nd cell contains the interrupt number for the interrupt type.
SPI interrupts are in the range [0-987].  PPI interrupts are in the
range [0-15].</p>

<p>The 3rd cell is the flags, encoded as follows:</p>

<pre><code>bits[3:0] trigger type and level flags.
    1 = low-to-high edge triggered
    2 = high-to-low edge triggered
    4 = active high level-sensitive
    8 = active low level-sensitive
bits[15:8] PPI interrupt cpu mask.  Each bit corresponds to each of
the 8 possible cpus attached to the GIC.  A bit set to '1' indicated
the interrupt is wired to that CPU.  Only valid for PPI interrupts.
</code></pre>

<p>```</p>

<p><em>来自：<code>Documentation/devicetree/bindings/arm/gic.txt</code></em></p>

<p>如果不了解ARM GIC的话，其实也看不懂上面的描述，所以这里解释一下：</p>

<ol>
<li>第一个member表示该 <code>interrupt</code> 是 <code>SPI</code> 还是 <code>PPI</code>。<code>SPI</code> 和 <code>PPI</code> 的解释如下，来自ARM的文档：</li>
</ol>


<blockquote><p>Private Peripheral Interrupts</p>

<p>A PPI is an interrupt generated by a peripheral that is specific to a single processor. There are seven PPIs for each CPU interface.</p></blockquote>

<p>这是ARM A15的 <code>PPI</code> 的描述，如果是A9的话，每个CPU interface是5个 <code>PPI</code>。</p>

<blockquote><p>Shared Peripheral Interrupts</p>

<p>An interrupt generated by a peripheral that the Interrupt Controller can route to any, or all, processor interfaces.</p>

<p>SPIs are triggered by events generated on associated interrupt input lines. The GIC can support up to 224 SPIs corresponding to the external IRQS[223:0] signal. The number of SPIs available depends on the implemented configuration of the Cortex-A15 MPCore processor. The permitted values are 0, 32, 64, 96, 128, 160, 192, or 224. SPIs start at ID32. The SPIs can be configured to be edge-triggered or active-HIGH level-sensitive.</p></blockquote>

<p>第一句话就可以看出和 <code>PPI</code> 的区别。<code>SPI</code> 的数量可以配置，如32，64&hellip;最大支持224，而且SPI的编号从32开始。至于最后提到的 <code>edge-triggered</code>，<code>active-HIGH level-sensitive</code> 正好就是 <code>interrupts</code> 第三个member。</p>

<p>所以，在一颗SoC中，绝大部分的中断都是 <code>SPI</code>。</p>

<p>事实上，ARM还有一种中断：<code>SGI</code>，也就是软中断：</p>

<blockquote><p>Software Generated Interrupt (SGI)</p>

<p>Generated by writing to the Software Generated Interrupt Register (ICDSGIR).</p>

<p>A maximum of 16 SGIs can be generated for each Cortex-A9 processor interface.</p></blockquote>

<p>但是Device tree是用来描述硬件设备的，所以Linux kernel中 <code>interrupts</code> 的类型没有定义 <code>SGI</code>。</p>

<ol>
<li><p>第二个member就是具体的中断号了。查阅SoC的手册就可以得到。</p></li>
<li><p>第三个member指的是中断的触发方式，每个SoC是不同的，查阅SoC的手册就可以知道了。这里kernel的文档解释的还是比较清楚的，就是一个16bit的数，0-3, 8-15 bit分别做了定义。</p></li>
</ol>

]]></content>
  </entry>
  
</feed>
