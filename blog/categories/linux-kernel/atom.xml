<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux-kernel | Make Things Cool]]></title>
  <link href="http://www.markzhang.cn/blog/categories/linux-kernel/atom.xml" rel="self"/>
  <link href="http://www.markzhang.cn/"/>
  <updated>2015-01-06T14:53:36+08:00</updated>
  <id>http://www.markzhang.cn/</id>
  <author>
    <name><![CDATA[Mark Zhang]]></name>
    <email><![CDATA[super119@139.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[32/64的问题：32bit指针转换成64bit - Sign Extension]]></title>
    <link href="http://www.markzhang.cn/blog/2014/12/16/convert-32bit-pointer-to-64bit/"/>
    <updated>2014-12-16T15:09:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2014/12/16/convert-32bit-pointer-to-64bit</id>
    <content type="html"><![CDATA[<p>32/64有很多问题，指针转换是其中一个，比如这个例子：</p>

<!-- more -->


<p><code>cpp
void *p = 0xc8f68000;
unsigned long long v = (unsigned long long)p;
</code></p>

<p>这个时候得到的 <code>v</code> 是： <code>0xffffffffc8f68000</code> 而不是 <code>0x00000000c8f68000</code></p>

<p>以上例子来自：</p>

<p><a href="http://stackoverflow.com/questions/22239752/convert-32-bit-pointer-to-64-bit-integer">http://stackoverflow.com/questions/22239752/convert-32-bit-pointer-to-64-bit-integer</a></p>

<p>最近就碰到了好几次类似的问题。原因非常简单，就是编译器看到我们要把一个指针转换成 <code>unsigned long long</code>，而 <code>p</code> 的最高位是1，编译器认为这是负数，所以编译器就启动了 <code>Sign Extension</code>，将高32bit全部设置成1，这样最终你看到的高32bit就是全F了。</p>

<p>所以当做32bit &ndash;> 64bit指针转换的时候，要使用 <code>intptr_t</code> 和 <code>uintptr_t</code>。这样编译器就知道这是指针的转换，高32bit就会是全0了。同样，这也就说明了，为什么 <code>stdint.h</code> 里面要定义这么些个typedef了:</p>

<p><code>cpp
void *p = 0xc8f68000;
uint64_t v = (uintptr_t)p;
</code></p>

<p>事实上，无论何时都尽量要避免指针和Integer之间的转换，因为Integer是有正负的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Thunderbird 80(72) column - 邮件在80(72)列处line break]]></title>
    <link href="http://www.markzhang.cn/blog/2014/11/25/thunderbird-72-column/"/>
    <updated>2014-11-25T11:13:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2014/11/25/thunderbird-72-column</id>
    <content type="html"><![CDATA[<p>这个需求做linux kernel upstream的人都懂的&hellip;&hellip;要设置Thunderbird在80列正确换行，只需要这样：</p>

<!-- more -->


<ul>
<li><p>Thunderbird如果撰写的邮件是plain text格式（在这里设置：Edit &ndash;> Account Settings &ndash;> Composition &amp; Addressing, you should uncheck Compose in HTML format for all accounts），那么自动就会在72列处做line wrap。但是需要注意的是，这里的line wrap只是在display邮件内容和撰写邮件时，你可以看到。当你发出邮件的时候，这个line wrap就没有了，换句话说，别人看到的你的邮件内容，还是很长的一行行的文字。所以需要下面一步。</p></li>
<li><p>以下内容来自：</p></li>
</ul>


<p><a href="http://arapulido.com/2009/12/01/enabling-line-wrapping-in-thunderbird/#comment-807">http://arapulido.com/2009/12/01/enabling-line-wrapping-in-thunderbird/#comment-807</a></p>

<p>下文中提到的option设置在：Edit &ndash;> Preferences &ndash;> Advanced (General tab) &ndash;> Configure Editor：</p>

<blockquote><p>I am a happy user of the daily build of Thunderbird 3. Although it is still under development, is the best email client for Linux I’ve tried so far, at least, the one that better works for me. Email search &amp; filtering is fast and reliable.</p>

<p>The only thing I don’t like is that wrapping your emails to 72 characters when sending plain text is not straightforward. Once you have selected to send your emails as plain text and have set the line wrap option to 72, there is still one more option to tweak.</p>

<p>Thunderbird has a “feature” that sends by default all plain text with the option format=flowed, which unwraps the email in the client receiver. To turn this feature off, you have to toggle one of the options in the chrome editor:</p>

<p>To disable flowed paragraphs, enforcing line breaks as formatted in the message, set the preference:</p>

<p>mailnews.display.disable_format_flowed_support true
(<a href="http://kb.mozillazine.org/Mail_content_types#Plain_text">http://kb.mozillazine.org/Mail_content_types#Plain_text</a>)</p>

<p>To disable paragraph flow when you send plain text messages, and in the plain text part of multipart messages, set the preference:</p>

<p>mailnews.send_plaintext_flowed false
(<a href="http://kb.mozillazine.org/Mail_content_types#Disabling_paragraph_flow">http://kb.mozillazine.org/Mail_content_types#Disabling_paragraph_flow</a>)</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux设备驱动suspend/resume的顺序]]></title>
    <link href="http://www.markzhang.cn/blog/2014/04/09/linux-driver-suspend-orders/"/>
    <updated>2014-04-09T16:07:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2014/04/09/linux-driver-suspend-orders</id>
    <content type="html"><![CDATA[<p>Linux在进入suspend的时候，会首先freeze userspace，然后挨个去调用设备驱动程序的suspend，最后调用architecture dependent的callback（非常奔放的描述了，其实有大量的细节问题存在）。Resume就是反过来执行一遍，最后重新enable userspace。那么作为设备驱动程序的编写者来说，主要就是要实现本驱动的suspend/resume逻辑。但是事实上，很多设备之间是有依赖性的，比如在ARM上，很多设备在resume之前，要求 <code>IOMMU</code> 要已经被enable，否则硬件上就会出现问题，因为访问的地址不对了。</p>

<p>那么Linux是如何设计/定义各个设备驱动之间的suspend/resume的顺序的呢？</p>

<!-- more -->


<p>简单来说，就是以下几条逻辑：</p>

<ul>
<li><p>各设备驱动程序按照其对应的设备（device）注册的先后次序，来决定其suspend/resume的顺序。注意是该驱动对应的设备的注册顺序，不是驱动注册的顺序，所以和驱动的注册优先级无关（也就是和module_init, rootfs_init, subsys_initcall这些无关）。越早被注册的设备，其对应的驱动的suspend越晚被调用，其对应驱动的resume越早被调用；越晚被注册的设备，其对应的驱动的suspend越早被调用，其对应的驱动的resume越晚被调用。</p></li>
<li><p>上面所说的逻辑往往不能满足我们的要求，因为现在的设备（device）都通过DT（Device Tree）的方式进行注册。那么，在DTS文件中，出现的越早的设备就越早被注册（可以参考函数 <code>of_platform_populate</code>）。而按照现在upstream linux kernel的约定，设备在DTS文件中，是按照其寄存器的地址，从低到高排序的，所以自然不可能满足我们的需求。</p></li>
</ul>


<p>那要怎么办？答案是驱动程序执行probe的时候返回 <code>-EPROBE_DEFER</code> 。</p>

<p>对于现在ARM SoC上的设备和其驱动程序来说，Linux kernel都使用Platform device/Platform driver来描述他们。而Platform driver的probe函数就相当于是驱动的初始化函数，一般用来映射寄存器，分配必需的内存等等，看一个驱动程序的代码，一般也可以从Probe开始看起。</p>

<p>Probe函数返回 <code>-EPROBE_DEFER</code>，指的是当一个设备驱动程序检测到其依赖的设备的驱动程序还没有ready的时候，返回这个出错码告诉kernel driver framework，我需要延缓自身的probe。还是举上面那个IOMMU的例子，如果一个设备依赖IOMMU，那么该设备的驱动在probe的时候，就应该检测iommu的驱动是否已经ready，如果没有那就要defer自己的probe。在Linux kernel driver framework中，收到驱动probe返回 <code>-EPROBE_DEFER</code>，就会将该驱动放入一个list中，一个workqueue来负责遍历这个list，从而再次执行这些驱动的probe函数（事实上，由于kernel driver framework不知道驱动互相之间的依赖关系，所以一旦有一个驱动成功probe了，kernel都会触发这个workqueue，让其去遍历一遍list）。</p>

<p>上面说的是 <code>-EPROBE_DEFER</code> 的背景故事了，而事实上，当一个驱动的probe返回过 <code>-EPROBE_DEFER</code> ，而最终成功probe之后，kernel就会修改该驱动的suspend/resume的顺序了。这就是为什么驱动probe的时候返回 <code>-EPROBE_DEFER</code> 能影响其suspend/resume的次序的原因了：</p>

<p><code>c
/*
 * Force the device to the end of the dpm_list since
 * the PM code assumes that the order we add things to
 * the list is a good order for suspend but deferred
 * probe makes that very unsafe.
 */
device_pm_lock();
device_pm_move_last(dev);
device_pm_unlock();
</code></p>

<p>上面的代码来自函数：<code>deferred_probe_work_func</code>，也就是上面所说的defer probe的workqueue的工作函数。所以这里可以看到，当一个驱动最终在probe defer的work函数中probe成功之后，kernel会修改该驱动对应的设备（device）在 <code>dpm_list</code> 中的位置，而 <code>dpm_list</code> 正是kernel suspend/resume 驱动时候遍历的链表。看到调用了函数：<code>device_pm_move_last(dev);</code> 没？这个设备被移到了 <code>dpm_list</code> 的末尾。</p>

<ul>
<li>事情到此为止，可以说已经有了解决方案：我们可以使用 DEFER PROBE 的方式来调整驱动 suspend/resume 的顺序。不过这里要提一下，还有一条路也是可行的，那就是利用 <code>syscore suspend/resume</code>。</li>
</ul>


<p>syscore是Linux kernel定义的一个framework，我们可以将我们的驱动注册到syscore中去。syscore比较关键的就是 <code>syscore_ops</code> 这个结构：</p>

<p>``` c
struct syscore_ops {</p>

<pre><code>struct list_head node;
int (*suspend)(void);
void (*resume)(void);
void (*shutdown)(void);
</code></pre>

<p>};
```</p>

<p>可以看到只有 suspend/resume/shutdown 这三个ops，所以看到这里大概也可以猜到了，注册到syscore中的驱动，其suspend函数是在所有其他驱动的suspend都调用过之后调用的，而其resume函数是在所有其他驱动的resume调用之前调用的。简单来说，syscore的驱动，suspend被晚调用保证其他驱动suspend的时候，syscore的驱动还活着；syscore的驱动，resume被很早调用，从而保证其他驱动resume的时候，syscore的驱动已经活着了。好绕。。。</p>

<p>要将驱动注册到syscore中很简单，调用函数：<code>register_syscore_ops(&amp;your_driver_syscore_ops);</code> 就可以了。至于上面说到的syscore的suspend/resume的顺序，实现代码在这里：</p>

<p>``` c
error = syscore_suspend();
if (!error) {</p>

<pre><code>*wakeup = pm_wakeup_pending();
if (!(suspend_test(TEST_CORE) || *wakeup)) {
    error = suspend_ops-&gt;enter(state);
    events_check_enabled = false;
}
syscore_resume();
</code></pre>

<p>}
```</p>

<p>以上代码来自函数：<code>suspend_enter</code>。可以看到当syscore_suspend被调用之后，就调用architecture dependent的 <code>suspend_ops-&gt;enter</code> 了，到这里整个系统就已经停下来了，进入suspend状态了。而当resume开始，<code>suspend_ops-&gt;enter</code> 返回之后，第一个被调用的就是 <code>syscore_resume</code>，所以上面那一段听起来好绕的逻辑就这么区区几行代码解释了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KGDB使用简介]]></title>
    <link href="http://www.markzhang.cn/blog/2014/03/10/kgdb-howto/"/>
    <updated>2014-03-10T13:57:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2014/03/10/kgdb-howto</id>
    <content type="html"><![CDATA[<p>KGDB是调试linux kernel的一个工具，虽然没有userspace的gdb那么好用，但有些时候还是能派上一些用处。比如kernel启动的时候自动重启，用kgdb连上之后就可以在kernel重启之前被KGDB截获，从而打印出调用栈来。</p>

<!-- more -->


<p>具体步骤是这样：</p>

<h2>Kernel配置</h2>

<ul>
<li><code>make menuconfig</code>, under &ldquo;Kernel Hacking&rdquo;, enable &ldquo;KGDB&rdquo; &amp; &ldquo;KGDB over serial line&rdquo;. Enable &ldquo;compile kernel with debug info&rdquo;(CONFIG_DEBUG_INFO) &amp; &ldquo;enable frame pointer&rdquo;(CONFIG_FRAME_POINTER) options(both are under &ldquo;Kernel Hacking&rdquo;).</li>
</ul>


<p>有关CONFIG_FRAME_POINTER这个option，需要在enable了ARCH_CONFIG_FRAME_POINTERS这个option之后才会出现在Kernel hacking下面。</p>

<p>这ARCH_CONFIG_FRAME_POINTERS在make menuconfig里面是找不到的。这个option是专门给其他人select用的。一般都是在ARCH config的时候会去select这个option</p>

<p>比如x86下，一般会enable这个option。而ARM则不会（可能是考虑到生成的kernel文件尺寸和性能）。</p>

<p>所以，在ARM下，可以编辑arch/arm/Kconfig，在CONFIG_ARM下面的一堆select的最后，添加上一句select CONFIG_ARCH_FRAME_POINTERS就可以了。</p>

<p>从实验结果来看，只要enable了CONFIG_DEBUG_INFO，基本上就差不多了，能看到代码了。</p>

<ul>
<li>Add kernel option: <code>kgdboc=ttyS0,38400 kgdbwait</code> into kernel command line.</li>
</ul>


<p>根据我的实验，这里115200不行。在后面gdb设置<code>target remote /dev/ttyS0</code>的时候，会被告知最高支持到38400.</p>

<p>所以，这里如果115200不行，就改成38400。</p>

<p>注意这里将<code>/dev/ttyS0</code>修改成你的串口设备文件。</p>

<ul>
<li>Start kernel, kernel will wait for connection from remote PC&rsquo;s gdb.</li>
</ul>


<h2>PC端（remote machine）设置</h2>

<ul>
<li>On remote machine, <code>&lt;gdb path&gt; ./vmlinux</code> &mdash; this &ldquo;vmlinux&rdquo; mostly is under the root directory of kernel(a big kernel image with debug infos, not the one under arch/arm/boot, that is stripped version).</li>
</ul>


<p>需要注意的是，这里的GDB必须使用host是x86-64，target是ARM的那种GDB。我们PC上的gdb一般host和target都是x86-64。</p>

<p>这样的GDB可以在一些常见的toolchain网站找到，比如linaro。</p>

<ul>
<li>Enter gdb commands:</li>
</ul>


<p><code>bash
set remotebaud 38400
target remote /dev/ttyS0
</code></p>

<ul>
<li>Done. You can list source codes, set breakpoints now. Continue the debugging after finished.</li>
</ul>


<p><em>CAUTION</em>: Close any other programs(normally it&rsquo;s minicom which we use to monitor serial outputs) which may occupy &ldquo;/dev/ttyS0&rdquo; before running gdb on remote machine. Otherwise gdb can&rsquo;t connect with target board.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Device tree: interrupts的解释]]></title>
    <link href="http://www.markzhang.cn/blog/2013/11/27/dt-interrupts/"/>
    <updated>2013-11-27T20:41:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2013/11/27/dt-interrupts</id>
    <content type="html"><![CDATA[<p>Linux kernel现在使用Device tree（DT）来描述硬件设备。既然是描述硬件设备，那自然就需要对硬件充分了解才能理解DT。Interrupts就是一个例子。</p>

<p>一般来说，DT中的 <code>interrupts</code> （本文不描述interrupt controller）看起来是这样的：</p>

<p>``` c
pmu {</p>

<pre><code>compatible = "arm,cortex-a9-pmu";
interrupts = &lt;0 144 0x04
          0 145 0x04
          0 146 0x04
          0 147 0x04&gt;;
</code></pre>

<p>};
```</p>

<!-- more -->


<p>可以看到 <code>interrupts</code> 有三个member，对于这三个member，Linux kernel的文档是这样说的：</p>

<p>```
The 1st cell is the interrupt type; 0 for SPI interrupts, 1 for PPI
interrupts.</p>

<p>The 2nd cell contains the interrupt number for the interrupt type.
SPI interrupts are in the range [0-987].  PPI interrupts are in the
range [0-15].</p>

<p>The 3rd cell is the flags, encoded as follows:</p>

<pre><code>bits[3:0] trigger type and level flags.
    1 = low-to-high edge triggered
    2 = high-to-low edge triggered
    4 = active high level-sensitive
    8 = active low level-sensitive
bits[15:8] PPI interrupt cpu mask.  Each bit corresponds to each of
the 8 possible cpus attached to the GIC.  A bit set to '1' indicated
the interrupt is wired to that CPU.  Only valid for PPI interrupts.
</code></pre>

<p>```</p>

<p><em>来自：<code>Documentation/devicetree/bindings/arm/gic.txt</code></em></p>

<p>如果不了解ARM GIC的话，其实也看不懂上面的描述，所以这里解释一下：</p>

<ol>
<li>第一个member表示该 <code>interrupt</code> 是 <code>SPI</code> 还是 <code>PPI</code>。<code>SPI</code> 和 <code>PPI</code> 的解释如下，来自ARM的文档：</li>
</ol>


<blockquote><p>Private Peripheral Interrupts</p>

<p>A PPI is an interrupt generated by a peripheral that is specific to a single processor. There are seven PPIs for each CPU interface.</p></blockquote>

<p>这是ARM A15的 <code>PPI</code> 的描述，如果是A9的话，每个CPU interface是5个 <code>PPI</code>。</p>

<blockquote><p>Shared Peripheral Interrupts</p>

<p>An interrupt generated by a peripheral that the Interrupt Controller can route to any, or all, processor interfaces.</p>

<p>SPIs are triggered by events generated on associated interrupt input lines. The GIC can support up to 224 SPIs corresponding to the external IRQS[223:0] signal. The number of SPIs available depends on the implemented configuration of the Cortex-A15 MPCore processor. The permitted values are 0, 32, 64, 96, 128, 160, 192, or 224. SPIs start at ID32. The SPIs can be configured to be edge-triggered or active-HIGH level-sensitive.</p></blockquote>

<p>第一句话就可以看出和 <code>PPI</code> 的区别。<code>SPI</code> 的数量可以配置，如32，64&hellip;最大支持224，而且SPI的编号从32开始。至于最后提到的 <code>edge-triggered</code>，<code>active-HIGH level-sensitive</code> 正好就是 <code>interrupts</code> 第三个member。</p>

<p>所以，在一颗SoC中，绝大部分的中断都是 <code>SPI</code>。</p>

<p>事实上，ARM还有一种中断：<code>SGI</code>，也就是软中断：</p>

<blockquote><p>Software Generated Interrupt (SGI)</p>

<p>Generated by writing to the Software Generated Interrupt Register (ICDSGIR).</p>

<p>A maximum of 16 SGIs can be generated for each Cortex-A9 processor interface.</p></blockquote>

<p>但是Device tree是用来描述硬件设备的，所以Linux kernel中 <code>interrupts</code> 的类型没有定义 <code>SGI</code>。</p>

<ol>
<li><p>第二个member就是具体的中断号了。查阅SoC的手册就可以得到。</p></li>
<li><p>第三个member指的是中断的触发方式，每个SoC是不同的，查阅SoC的手册就可以知道了。这里kernel的文档解释的还是比较清楚的，就是一个16bit的数，0-3, 8-15 bit分别做了定义。</p></li>
</ol>

]]></content>
  </entry>
  
</feed>
