<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux-kernel | Make Things Cool]]></title>
  <link href="http://markzhang.cn/blog/categories/linux-kernel/atom.xml" rel="self"/>
  <link href="http://markzhang.cn/"/>
  <updated>2015-12-23T10:30:05+08:00</updated>
  <id>http://markzhang.cn/</id>
  <author>
    <name><![CDATA[Mark Zhang]]></name>
    <email><![CDATA[super119@139.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Kernel barrier/wmb/mb宏的作用]]></title>
    <link href="http://markzhang.cn/blog/2015/12/23/kernel-barrier-mb-wmb/"/>
    <updated>2015-12-23T10:28:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/12/23/kernel-barrier-mb-wmb</id>
    <content type="html"><![CDATA[<p>内存屏障主要解决的问题是编译器的优化和CPU的乱序执行。</p>

<p>编译器在优化的时候，生成的汇编指令可能和c语言程序的执行顺序不一样，在需要程序严格按照c语言顺序执行时，需要显式的告诉编译不需要优化，这在linux下是通过barrier()宏完成的，它依靠volidate关键字和memory关键字，前者告诉编译barrier()周围的指令不要被优化，后者作用是告诉编译器汇编代码会使内存里面的值更改，编译器应使用内存里的新值而非寄存器里保存的老值。</p>

<p>同样，CPU执行会通过乱序以提高性能。汇编里的指令不一定是按照我们看到的顺序执行的。linux中通过mb()系列宏来保证执行的顺序。具体做法是通过mfence/lfence指令（它们是奔4后引进的，早期x86没有）以及x86指令中带有串行特性的指令（这样的指令很多，例如linux中实现时用到的lock指令，I/O指令，操作控制寄存器、系统寄存器、调试寄存器的指令、iret指令等等）。简单的说，如果在程序某处插入了mb()/rmb()/wmb()宏，则宏之前的程序保证比宏之后的程序先执行，从而实现串行化。wmb的实现和barrier()类似，是因为在x86平台上，写内存的操作不会被乱序执行。</p>

<p>实际上在RSIC平台上，这些串行工作都有专门的指令由程序员显式的完成，比如在需要的地方调用串行指令，而不像x86上有这么多隐性的带有串行特性指令（例如lock指令）。所以在risc平台下工作的朋友通常对串行化操作理解的容易些。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux kernel data types, alignment, compat_ioctl 数据类型，对齐问题和compat_ioctl]]></title>
    <link href="http://markzhang.cn/blog/2015/12/23/kernel-data-type-compat-ioctl/"/>
    <updated>2015-12-23T10:21:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/12/23/kernel-data-type-compat-ioctl</id>
    <content type="html"><![CDATA[<p>特别是在写IOCTL的时候，由于有32bit userspace + 64bit kernel的问题，而且由于architecture的不同，不同data type的length也不同，所以在IOCTL中建议用u32, u64, s32这样无视architecture fix size的data type。</p>

<p>这里是来自LDD的不同的architecture的data type的size：</p>

<!-- more -->


<p><img src="/downloads/image/kernel-u32-s32.png" alt="kernel architecture indepedent data types" /></p>

<p>此外有关IOCTL中structure的alignment的问题，注意添加padding使数据长度alignment，现在一般来说都是添加padding到64bit对齐。这里是为什么需要这么做（针对ARM，x86更不用说，因为x86-64早就有了）：</p>

<blockquote><p>Q: I&rsquo;m new in kernel development. Could you tell me or give me some
materials to read that why we need to align the size of IOCTL structures
to 64bit? I can understand if we&rsquo;re working in a 64bit kernel but why we
need to do this if we&rsquo;re in a 32bit arm kernel? Besides, why the
pointers in IOCTL structure should be declared as u64?</p>

<p>A: Because in a few years/months you&rsquo;ll have arm64, but still the same
driver with the same ioctls &hellip; and if the ioctls are not <em>exactly</em>
the same you get to write compat ioctl code which copies the old 32bit
struct into the 64bit struct the kernel understands. Hence your ioctl
must be laid out exactly the same for both 32bit and 64bit, which
happens if you naturally align/pad everything to 64bits and only use
fixed-sized integers and no pointers.</p>

<p>Mark: Ah, I see. Thanks. Yes, u64 still works as 32 bit pointer.</p></blockquote>

<p>参看LDD十一章中有关Nature Alignment的描述。Alignment主要是牵涉到性能问题，不对齐的数据在fetch的时候会有exception，从而降低performance。</p>

<p>这里是网上搜到的一些建议：</p>

<p>There are some rules that should be followed regardless:</p>

<ul>
<li><p>ioctl commands should never be written in an architecture specific
way. In the example of the OMAP driver, you definitely want to be
able ot use the same command when running Linux on the C6x DSP.</p></li>
<li><p>If possible, use only scalar values as ioctl arguments</p></li>
<li><p>Avoid types that are register sized: &lsquo;long&rsquo;, &lsquo;size_t&rsquo;, pointer.
Instead use only <strong>u8, </strong>u16, <strong>u32 and </strong>u64 and their signed
versions.</p></li>
<li><p>If you use structures, try very hard to avoid pointers in them,
it messes up all sorts of tools.</p></li>
<li><p>If you use structures, make all members naturally aligned, and pad
the size of the structures to a multiple of the maximum member size.</p></li>
<li><p>Never put sub-command numbers into a structure.</p></li>
</ul>


<p>有关compat_ioctl：支持64bit的driver必须要实现的ioctl，当有32bit的userspace application call 64bit kernel的IOCTL的时候，这个callback会被调用到。</p>

<p>Q: Suppose I have defined the following.</p>

<p>``` cpp</p>

<h1>define MY_IOCTL_CMD1 _IOR(MAGIC_NUMBER, 0x01, arg1)</h1>

<h1>define MY_IOCTL_CMD2 _IOW(MAGIC_NUMBER, 0x02, arg2)</h1>

<h1>ifdef CONFIG_COMPAT</h1>

<h1>define MY_COMPAT_IOCTL_CMD1 _IOR(MAGIC_NUMBER, 0x01, compat_arg1)</h1>

<h1>define MY_COMPAT_IOCTL_CMD2 _IOW(MAGIC_NUMBER, 0x02, compat_arg2)</h1>

<h1>endif</h1>

<p>```</p>

<p>Now when we do ioctl from user space, we usually do</p>

<p>ioctl(fd, MY_IOCTL_CMD1, &amp;arg1)</p>

<p>So do we really need to have an ioctl with MY_COMPAT_IOCTL_CMD1 as request?</p>

<p>In the devide code I have handlers defined as follows. ioctl: device_ioctl</p>

<p>``` cpp</p>

<h1>ifdef CONFIG_COMPAT</h1>

<p>compat_ioctl: device_compat_ioctl</p>

<h1>endif</h1>

<p>Can anybody please provide some explanations around this?</p>

<p>A: This compat stuff is for running a 32-bit program in a 64-bit kernel. When you call the ioctl(fd, MY_IOCTL_CMD1, &amp;arg1) from a 32-bit program on a 64-bit kernel, the kernel will divert the ioctl to the .compat_ioctl function in the file_operations struct. This compat_ioctl function is responsible for copying the user argument arg1 as if it were compat_arg1, which uses the 32-bit layout. The compat_arg1 typedef is defined in the kernel so that when compiled for 64-bit, the structure is exactly the same layout as the arg1 compiled for 32-bit.</p>

<p>The definition of MY_IOCTL_CMD1 will take the sizeof arg1 into account when creating the cmd id. When you compile a program for a 32-bit machine, the value for MY_IOCTL_CMD1 will be different than if you compiled it for a 64-bit machine. The 32-bit MY_IOCTL_CMD1 should have the same value as the 64-bit MY_COMPAT_IOCTL_CMD1 in the kernel, however.</p>

<p>There&rsquo;s never a need to use compat_arg1 or MY_COMPAT_IOCTL_CMD1 in a user-space application. Those are only for code compiled in the kernel.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Thunderbird配置 - for kernel maillist]]></title>
    <link href="http://markzhang.cn/blog/2015/12/21/kernel-thunderbird/"/>
    <updated>2015-12-21T14:22:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/12/21/kernel-thunderbird</id>
    <content type="html"><![CDATA[<p>From kernel: Documentation/email-clients.txt</p>

<!-- more -->


<p>Thunderbird (GUI)</p>

<p>Thunderbird is an Outlook clone that likes to mangle text, but there are ways
to coerce it into behaving.</p>

<ul>
<li>Allows use of an external editor:
The easiest thing to do with Thunderbird and patches is to use an
&ldquo;external editor&rdquo; extension and then just use your favorite $EDITOR
for reading/merging patches into the body text.  To do this, download
and install the extension, then add a button for it using
View->Toolbars->Customize&hellip; and finally just click on it when in the
Compose dialog.</li>
</ul>


<p>To beat some sense out of the internal editor, do this:</p>

<ul>
<li><p>Edit your Thunderbird config settings so that it won&rsquo;t use format=flowed.
Go to &ldquo;edit->preferences->advanced->config editor&rdquo; to bring up the
thunderbird&rsquo;s registry editor, and set &ldquo;mailnews.send_plaintext_flowed&rdquo; to
&ldquo;false&rdquo;.</p></li>
<li><p>Disable HTML Format: Set &ldquo;mail.identity.id1.compose_html&rdquo; to &ldquo;false&rdquo;.</p></li>
<li><p>Enable &ldquo;preformat&rdquo; mode: Set &ldquo;editor.quotesPreformatted&rdquo; to &ldquo;true&rdquo;.</p></li>
<li><p>Enable UTF8: Set &ldquo;prefs.converted-to-utf8&rdquo; to &ldquo;true&rdquo;.</p></li>
<li><p>Install the &ldquo;toggle wordwrap&rdquo; extension.  Download the file from:
  <a href="https://addons.mozilla.org/thunderbird/addon/2351/">https://addons.mozilla.org/thunderbird/addon/2351/</a>
Then go to &ldquo;tools->add ons&rdquo;, select &ldquo;install&rdquo; at the bottom of the screen,
and browse to where you saved the .xul file.  This adds an &ldquo;Enable
Wordwrap&rdquo; entry under the Options menu of the message composer.</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kernel Submitting Patches，有关ifdef和static inline & macro]]></title>
    <link href="http://markzhang.cn/blog/2015/12/21/kernel-ifdef-macros/"/>
    <updated>2015-12-21T14:19:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/12/21/kernel-ifdef-macros</id>
    <content type="html"><![CDATA[<p>From kernel: Documentation/SubmittingPatches</p>

<!-- more -->


<p>2) #ifdefs are ugly</p>

<p>Code cluttered with ifdefs is difficult to read and maintain.  Don&rsquo;t do
it.  Instead, put your ifdefs in a header, and conditionally define
&lsquo;static inline&rsquo; functions, or macros, which are used in the code.
Let the compiler optimize away the &ldquo;no-op&rdquo; case.</p>

<p>Simple example, of poor code:</p>

<p>``` cpp</p>

<pre><code>    dev = alloc_etherdev (sizeof(struct funky_private));
    if (!dev)
            return -ENODEV;
    #ifdef CONFIG_NET_FUNKINESS
    init_funky_net(dev);
    #endif
</code></pre>

<p>```</p>

<p>Cleaned-up example:</p>

<p>``` cpp
(in header)</p>

<pre><code>    #ifndef CONFIG_NET_FUNKINESS
    static inline void init_funky_net (struct net_device *d) {}
    #endif
</code></pre>

<p>(in the code itself)</p>

<pre><code>    dev = alloc_etherdev (sizeof(struct funky_private));
    if (!dev)
            return -ENODEV;
    init_funky_net(dev);
</code></pre>

<p>```</p>

<p>3) &lsquo;static inline&rsquo; is better than a macro</p>

<p>Static inline functions are greatly preferred over macros.
They provide type safety, have no length limitations, no formatting
limitations, and under gcc they are as cheap as macros.
Macros should only be used for cases where a static inline is clearly
suboptimal [there are a few, isolated cases of this in fast paths],
or where it is impossible to use a static inline function [such as
string-izing].</p>

<p>&lsquo;static inline&rsquo; is preferred over &lsquo;static <strong>inline</strong>&rsquo;, &lsquo;extern inline&rsquo;,
and &lsquo;extern <strong>inline</strong>&rsquo;.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[kernel: How to decompress the zImage?]]></title>
    <link href="http://markzhang.cn/blog/2015/12/21/kernel-decompress-zimage/"/>
    <updated>2015-12-21T14:00:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/12/21/kernel-decompress-zimage</id>
    <content type="html"><![CDATA[<p>zImage不是标准的gzip文件，需要自己strip掉开头的一些东西才可以gunzip。</p>

<p>基本上的思路就是找gzip的magic number &ldquo;1f 8b 08"。</p>

<!-- more -->


<p>具体步骤：</p>

<p><code>bash
$ mkdir -p /tmp/kernel-uncompressed/; cd /tmp/kernel-uncompressed/
$ cp /boot/vmlinuz-`uname -r` .
$ od -t x1 -A d vmlinuz-2.6.18-128.el5.uvm6PAE | grep "1f 8b 08"
0008320 1b 00 1f 8b 08 00 d5 c2 9a 49 02 03 ec 3b 7d 7c
$ dd bs=1 skip=8322 if=vmlinuz-2.6.18-128.el5.uvm6PAE | zcat &gt; vmlinux
</code></p>
]]></content>
  </entry>
  
</feed>
