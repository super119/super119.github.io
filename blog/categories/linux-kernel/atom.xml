<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux-kernel | Make Things Cool]]></title>
  <link href="http://markzhang.cn/blog/categories/linux-kernel/atom.xml" rel="self"/>
  <link href="http://markzhang.cn/"/>
  <updated>2015-12-21T14:30:43+08:00</updated>
  <id>http://markzhang.cn/</id>
  <author>
    <name><![CDATA[Mark Zhang]]></name>
    <email><![CDATA[super119@139.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Thunderbird配置 - for kernel maillist]]></title>
    <link href="http://markzhang.cn/blog/2015/12/21/kernel-thunderbird/"/>
    <updated>2015-12-21T14:22:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/12/21/kernel-thunderbird</id>
    <content type="html"><![CDATA[<p>From kernel: Documentation/email-clients.txt</p>

<!-- more -->


<p>Thunderbird (GUI)</p>

<p>Thunderbird is an Outlook clone that likes to mangle text, but there are ways
to coerce it into behaving.</p>

<ul>
<li>Allows use of an external editor:
The easiest thing to do with Thunderbird and patches is to use an
&ldquo;external editor&rdquo; extension and then just use your favorite $EDITOR
for reading/merging patches into the body text.  To do this, download
and install the extension, then add a button for it using
View->Toolbars->Customize&hellip; and finally just click on it when in the
Compose dialog.</li>
</ul>


<p>To beat some sense out of the internal editor, do this:</p>

<ul>
<li><p>Edit your Thunderbird config settings so that it won&rsquo;t use format=flowed.
Go to &ldquo;edit->preferences->advanced->config editor&rdquo; to bring up the
thunderbird&rsquo;s registry editor, and set &ldquo;mailnews.send_plaintext_flowed&rdquo; to
&ldquo;false&rdquo;.</p></li>
<li><p>Disable HTML Format: Set &ldquo;mail.identity.id1.compose_html&rdquo; to &ldquo;false&rdquo;.</p></li>
<li><p>Enable &ldquo;preformat&rdquo; mode: Set &ldquo;editor.quotesPreformatted&rdquo; to &ldquo;true&rdquo;.</p></li>
<li><p>Enable UTF8: Set &ldquo;prefs.converted-to-utf8&rdquo; to &ldquo;true&rdquo;.</p></li>
<li><p>Install the &ldquo;toggle wordwrap&rdquo; extension.  Download the file from:
  <a href="https://addons.mozilla.org/thunderbird/addon/2351/">https://addons.mozilla.org/thunderbird/addon/2351/</a>
Then go to &ldquo;tools->add ons&rdquo;, select &ldquo;install&rdquo; at the bottom of the screen,
and browse to where you saved the .xul file.  This adds an &ldquo;Enable
Wordwrap&rdquo; entry under the Options menu of the message composer.</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kernel Submitting Patches，有关ifdef和static inline & macro]]></title>
    <link href="http://markzhang.cn/blog/2015/12/21/kernel-ifdef-macros/"/>
    <updated>2015-12-21T14:19:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/12/21/kernel-ifdef-macros</id>
    <content type="html"><![CDATA[<p>From kernel: Documentation/SubmittingPatches</p>

<!-- more -->


<p>2) #ifdefs are ugly</p>

<p>Code cluttered with ifdefs is difficult to read and maintain.  Don&rsquo;t do
it.  Instead, put your ifdefs in a header, and conditionally define
&lsquo;static inline&rsquo; functions, or macros, which are used in the code.
Let the compiler optimize away the &ldquo;no-op&rdquo; case.</p>

<p>Simple example, of poor code:</p>

<p>``` cpp</p>

<pre><code>    dev = alloc_etherdev (sizeof(struct funky_private));
    if (!dev)
            return -ENODEV;
    #ifdef CONFIG_NET_FUNKINESS
    init_funky_net(dev);
    #endif
</code></pre>

<p>```</p>

<p>Cleaned-up example:</p>

<p>``` cpp
(in header)</p>

<pre><code>    #ifndef CONFIG_NET_FUNKINESS
    static inline void init_funky_net (struct net_device *d) {}
    #endif
</code></pre>

<p>(in the code itself)</p>

<pre><code>    dev = alloc_etherdev (sizeof(struct funky_private));
    if (!dev)
            return -ENODEV;
    init_funky_net(dev);
</code></pre>

<p>```</p>

<p>3) &lsquo;static inline&rsquo; is better than a macro</p>

<p>Static inline functions are greatly preferred over macros.
They provide type safety, have no length limitations, no formatting
limitations, and under gcc they are as cheap as macros.
Macros should only be used for cases where a static inline is clearly
suboptimal [there are a few, isolated cases of this in fast paths],
or where it is impossible to use a static inline function [such as
string-izing].</p>

<p>&lsquo;static inline&rsquo; is preferred over &lsquo;static <strong>inline</strong>&rsquo;, &lsquo;extern inline&rsquo;,
and &lsquo;extern <strong>inline</strong>&rsquo;.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[kernel: How to decompress the zImage?]]></title>
    <link href="http://markzhang.cn/blog/2015/12/21/kernel-decompress-zimage/"/>
    <updated>2015-12-21T14:00:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/12/21/kernel-decompress-zimage</id>
    <content type="html"><![CDATA[<p>zImage不是标准的gzip文件，需要自己strip掉开头的一些东西才可以gunzip。</p>

<p>基本上的思路就是找gzip的magic number &ldquo;1f 8b 08"。</p>

<!-- more -->


<p>具体步骤：</p>

<p><code>bash
$ mkdir -p /tmp/kernel-uncompressed/; cd /tmp/kernel-uncompressed/
$ cp /boot/vmlinuz-`uname -r` .
$ od -t x1 -A d vmlinuz-2.6.18-128.el5.uvm6PAE | grep "1f 8b 08"
0008320 1b 00 1f 8b 08 00 d5 c2 9a 49 02 03 ec 3b 7d 7c
$ dd bs=1 skip=8322 if=vmlinuz-2.6.18-128.el5.uvm6PAE | zcat &gt; vmlinux
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[kernel: 调用init程序的地方]]></title>
    <link href="http://markzhang.cn/blog/2015/12/21/kernel-calls-init/"/>
    <updated>2015-12-21T13:57:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/12/21/kernel-calls-init</id>
    <content type="html"><![CDATA[<p>start_kernel函数的最后一行：rest_init，调用了init程序。</p>

<p>看代码就很清楚了。有个地方值得注意的是，优先被调用的是initramfs中的init程序（可以通过rdinit=xxx来设定）。</p>

<p>然后才会去检查 <code>init=</code> 的设置。</p>

<p>如果这两个都没有设置的话，kernel就会挨个去尝试/sbin/init, /bin/init, /bin/sh&hellip;</p>

<p>这些都没有那就panic了</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux kernel: How to debug mutex deadlock 如何调试mutex死锁]]></title>
    <link href="http://markzhang.cn/blog/2015/12/16/kernel-debug-deadlock/"/>
    <updated>2015-12-16T15:47:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/12/16/kernel-debug-deadlock</id>
    <content type="html"><![CDATA[<p>和userspace调试lock一样，主要是要：</p>

<ol>
<li><p>找到lock死锁的地方，打印出调用栈</p></li>
<li><p>找出这个mutex目前被谁占用了</p></li>
</ol>


<!-- more -->


<p>针对1：在kernel config中，Kernel Hacking这个大项中，enable跟lock/mutex相关的config，比如CONFIG_DEBUG_MUTEX，以及CONFIG_DETECT_HUNG_TASKS, 这样当死锁发生时，稍微等待一段时间（默认120秒），kernel就会检测到死锁，同时打印出调用栈。在kernel hacking里面，包含了大量的有利于调试的config，可以一项一项都看一遍，总有一款适合您。</p>

<p>针对2：来到代码中死锁的地方，在enable了CONFIG_DEBUG_MUTEX的情况下，添加这样的代码：</p>

<p><code>cpp
show_stack(&lt;lock&gt;.owner, NULL);
</code></p>

<p><lock>是你的mutex的变量名，.owner是一个struct task_struct *，利用show_stack函数就可以打印出该mutex被谁占用了，而且占用该mutex时的调用栈。非常cool。</p>

<p>此外可以看一下struct mutex的定义，有一些实用的东西，比如mutex的name。struct task_struct中也有一些实用的东西，比如pid等。</p>

<p>所以总结来说，kernel中目前可以打印调用栈的有：</p>

<p>dump_stack：打印当前的backtrace</p>

<p>show_stack：打印指定task_struct的backtrace</p>
]]></content>
  </entry>
  
</feed>
