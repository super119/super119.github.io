<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Make Things Cool]]></title>
  <link href="http://www.markzhang.cn/atom.xml" rel="self"/>
  <link href="http://www.markzhang.cn/"/>
  <updated>2015-12-16T15:52:26+08:00</updated>
  <id>http://www.markzhang.cn/</id>
  <author>
    <name><![CDATA[Mark Zhang]]></name>
    <email><![CDATA[super119@139.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linux kernel: How to debug mutex deadlock 如何调试mutex死锁]]></title>
    <link href="http://www.markzhang.cn/blog/2015/12/16/kernel-debug-deadlock/"/>
    <updated>2015-12-16T15:47:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2015/12/16/kernel-debug-deadlock</id>
    <content type="html"><![CDATA[<p>和userspace调试lock一样，主要是要：</p>

<ol>
<li><p>找到lock死锁的地方，打印出调用栈</p></li>
<li><p>找出这个mutex目前被谁占用了</p></li>
</ol>


<!-- more -->


<p>针对1：在kernel config中，Kernel Hacking这个大项中，enable跟lock/mutex相关的config，比如CONFIG_DEBUG_MUTEX，以及CONFIG_DETECT_HUNG_TASKS, 这样当死锁发生时，稍微等待一段时间（默认120秒），kernel就会检测到死锁，同时打印出调用栈。在kernel hacking里面，包含了大量的有利于调试的config，可以一项一项都看一遍，总有一款适合您。</p>

<p>针对2：来到代码中死锁的地方，在enable了CONFIG_DEBUG_MUTEX的情况下，添加这样的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">show_stack</span><span class="p">(</span><span class="o">&lt;</span><span class="n">lock</span><span class="o">&gt;</span><span class="p">.</span><span class="n">owner</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><lock>是你的mutex的变量名，.owner是一个struct task_struct *，利用show_stack函数就可以打印出该mutex被谁占用了，而且占用该mutex时的调用栈。非常cool。</p>

<p>此外可以看一下struct mutex的定义，有一些实用的东西，比如mutex的name。struct task_struct中也有一些实用的东西，比如pid等。</p>

<p>所以总结来说，kernel中目前可以打印调用栈的有：</p>

<p>dump_stack：打印当前的backtrace</p>

<p>show_stack：打印指定task_struct的backtrace</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chromium OS相比Chrome OS缩水的地方]]></title>
    <link href="http://www.markzhang.cn/blog/2015/12/16/chromiumos-chromeos/"/>
    <updated>2015-12-16T14:44:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2015/12/16/chromiumos-chromeos</id>
    <content type="html"><![CDATA[<p>关于两者的区别，下面是Google官方的解释：</p>

<!-- more -->


<ol>
<li>Chromium OS人人都可下载、修改，并且免费使用。Chrome OS只提供给品牌厂商的特定笔记本机型（也就是Chromebook）使用。</li>
<li>Chrome OS具有需验证的引导和轻松恢复功能，Chromium OS则没有（也没需要）。</li>
<li>Chrome OS具有自动更新功能，可以保持你的系统是最新状态，Chromium OS则没有，要想更新系统只有下载新版来重装。</li>
<li>Chrome OS针对具体的笔记本硬件有特别优化，运行时性能更高，也更稳定（这个笔者有深刻体会）；Chromium OS则只包含一些早已存在的开源硬件驱动。</li>
<li>Chrome OS由Google公司和笔记本品牌厂商提供技术支持，Chromium OS则由开源社区提供支持。</li>
<li>Chrome OS内置Flash、PDF和Netflix Instant插件，并且有Google Talk软件，支持3G网络，Chromium OS则没有以上特性（没有Flash插件最要命啊）。</li>
<li>图标不一样，Chrome OS的图标是红黄蓝绿四色，Chromium OS只有蓝色。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Raspberry Pi + ArchLinux：网络dhcp不稳定，经常无法获取IP地址]]></title>
    <link href="http://www.markzhang.cn/blog/2015/12/16/raspberrypi-dhcp-timeout/"/>
    <updated>2015-12-16T14:40:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2015/12/16/raspberrypi-dhcp-timeout</id>
    <content type="html"><![CDATA[<p>经常发现树莓派开机之后网络没有起来，最终发现是因为dhcpcd的-t参数，也就是等待dhcp server响应的timeout时间太短导致的。</p>

<p>默认是30秒，但是ArchLinux中配置的是10秒。</p>

<p>查看了脚本，调用dhcpcd的是netcfg，netcfg本身也是一个脚本，所以最终发现这个-t是在/usr/lib/network/connections/ethernet中设置的。</p>

<p>于是在这个文件的开头加上了：<code>DHCP_TIMEOUT=300</code></p>

<p>这样超时就变成了5分钟，足够了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to HACK CISCO anyconnect secure mobile client]]></title>
    <link href="http://www.markzhang.cn/blog/2015/08/31/hack-cisco-anyconnect/"/>
    <updated>2015-08-31T08:31:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2015/08/31/hack-cisco-anyconnect</id>
    <content type="html"><![CDATA[<p>本文参考了以下两篇文章：</p>

<p><a href="http://superuser.com/questions/284709/how-to-allow-local-lan-access-while-connected-to-cisco-vpn">http://superuser.com/questions/284709/how-to-allow-local-lan-access-while-connected-to-cisco-vpn</a></p>

<p><a href="https://github.com/jbalint/dnsmasq/blob/master/run.sh">https://github.com/jbalint/dnsmasq/blob/master/run.sh</a></p>

<!-- more -->


<p>CISCO anyconnect secure mobile client（以下简称anyconnect）是CISCO的一个VPN客户端，很多公司都在采用。但是如果你尝试在一台机器上运行anyconnect，其他机器想通过这台机器也能访问公司内网的话，你就发现这是不行的。这是因为anyconnect做了三件令人恶心的事情：</p>

<h2>监控路由表</h2>

<p>Anyconnect客户端启动并连接VPN成功之后，是会监控系统的路由表的。此时，你可以添加路由（但是不好意思这不管用，因为Anyconnect已经添加了一条默认路由），但是无法删除路由。你可以运行 <code>route del default</code>，命令也不会出错，但是之后你用 <code>route -n</code> 看一下，发现没有效果 &mdash; 这是因为Anyconnect把路由又添加回来了。</p>

<p>事实上，是Anyconnect的 <code>vpnagentd</code> 这个守护进程在监控系统路由表。为此，网上有这么一个解决方案，我测试了一下是OK的：</p>

<p>编写这样一个程序：</p>

<figure class='code'><figcaption><span>hack.c</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;sys/socket.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;linux/netlink.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">_ZN27CInterfaceRouteMonitorLinux20routeCallbackHandlerEv</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">fd</span><span class="o">=</span><span class="mi">50</span><span class="p">;</span>          <span class="c1">// max fd to try</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">8192</span><span class="p">];</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">sockaddr_nl</span> <span class="n">sa</span><span class="p">;</span>
</span><span class='line'>    <span class="n">socklen_t</span> <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sa</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>       <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">getsockname</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sa</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">if</span> <span class="p">(</span><span class="n">sa</span><span class="p">.</span><span class="n">nl_family</span> <span class="o">==</span> <span class="n">AF_NETLINK</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>             <span class="n">ssize_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">recv</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="n">MSG_DONTWAIT</span><span class="p">);</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>       <span class="p">}</span>
</span><span class='line'>       <span class="n">fd</span><span class="o">--</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后编译：<code>gcc -o libhack.so -shared -fPIC hack.c</code>，最后利用 <code>LD_PRELOAD</code> 将其装载：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">LD_PRELOAD</span><span class="o">=</span>/opt/cisco/anyconnect/lib/libhack.so /opt/cisco/anyconnect/bin/vpnagentd
</span></code></pre></td></tr></table></div></figure>


<p>你可以通过修改 <code>/etc/init.d/vpnagentd</code> 这个脚本，添加上面的 <code>LD_PRELOAD</code> 部分。</p>

<p>所以原理其实很简单，就是要修改anyconnect监控路由表的那个函数。在上面的代码中，这个函数是：<code>_ZN27CInterfaceRouteMonitorLinux20routeCallbackHandlerEv</code>，在anyconnect 3.1版本测试是OK的。</p>

<p>那如果找出这个函数呢？毕竟anyconnect还有MACOS版，windows版等各种不同版本。对于这个，原作者也有一个办法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo gdb --pid &lt;vpnagentd pid&gt;
</span><span class='line'><span class="nb">break </span>socket
</span><span class='line'><span class="k">continue</span>
</span><span class='line'>bt
</span></code></pre></td></tr></table></div></figure>


<p>也就是说attach上 <code>vpnagentd</code> 进程，然后在 <code>socket</code> 这个函数上设置断点，当你设置了断点之后，输入 <code>continue</code> 让 <code>vpnagentd</code> 继续运行，然后你就可以在命令行下去执行：<code>sudo route del default</code>，这样 <code>vpnagentd</code> 就会撞上我们设置的断点了，此时用bt就可以看到调用栈了。</p>

<p>得到调用栈之后，你能看到的是类似这样的东西：<code>CInterfaceRouteMonitorLinux::routeCallbackHandle</code>，这并不是真正的symbol，这是GDB帮我们解析过的函数名，所以，可以用 <code>nm</code>, <code>objdump</code> 这样的工具去dump这个函数所在的文件（在我的anyconnect 3.1上，这个文件是：<code>/opt/cisco/anyconnect/lib/libvpnagentutilities.so</code>），在dump出来的symbol中去grep这个函数，就可以得到真正的symbol名字了。</p>

<p>如果 <code>nm</code> / <code>objdump</code> 无法显示出symbol的话，那就是这个库或者可执行文件是strip过的，那这个时候我们就只能用 <code>hexedit</code> 这样的工具打开二进制文件，在其中搜索GDB中我们得到的函数名字了。</p>

<h2>监控 /etc/resolv.conf</h2>

<p>这是为了防止我们修改DNS，对于此，解决方案要简单一些，毕竟这是针对文件的修改，而Linux kernel有一些对 <code>inotify</code> 的设置，所以可以这样做：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># go to great lengths to rewrite resolv.conf</span>
</span><span class='line'><span class="c"># the vpnagentd watches it with inotify and rewrites it immediately after I change it</span>
</span><span class='line'><span class="c"># set inotify limit to 0, first rewrite, vpnagentd will fix it, but then wont be able to set the watch again....</span>
</span><span class='line'><span class="nv">INOTIFYLIMIT</span><span class="o">=</span><span class="sb">`</span>cat /proc/sys/fs/inotify/max_user_watches<span class="sb">`</span>
</span><span class='line'>sudo bash -c <span class="s2">&quot;echo 0 &gt; /proc/sys/fs/inotify/max_user_watches&quot;</span>
</span><span class='line'>sudo bash -c <span class="s2">&quot;echo nameserver 127.0.0.1 &gt; /etc/resolv.conf&quot;</span>
</span><span class='line'>sleep 1
</span><span class='line'>sudo bash -c <span class="s2">&quot;echo nameserver 127.0.0.1 &gt; /etc/resolv.conf&quot;</span>
</span><span class='line'>sudo bash -c <span class="s2">&quot;echo $INOTIFYLIMIT &gt; /proc/sys/fs/inotify/max_user_watches&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个方案我没有测试过，所以我不敢保证一定管用。列在这里只是想说明，对于一个进程监控某个文件这种事情，可以利用kernel的 <code>inotify</code> 的一些设置，从而来绕过进程的这种行为。</p>

<h2>设置iptables</h2>

<p>Anyconnect是有设置iptables rules的，运行：<code>sudo iptables -vnL</code>，就可以看到anyconnect设置的所有rules。</p>

<p>这些rules中，有一个很讨厌的地方就是，它会约束anyconnect只服务于来自本地的请求，也就是说，如果局域网内其他机器想通过拨了anyconnect的机器共享访问VPN资源的话，这是不行的。</p>

<p>解决方法倒是异常简单：<code>sudo iptables -F</code> 搞定，貌似anyconnect并没有监控iptables的修改。</p>

<h2>最后</h2>

<p>虽然anyconnect有上述三条类似木马病毒的行为，但是实事求是的说，它本身工作的还是很好的，而且它有适应不同操作系统的各种版本也很不错。</p>

<p>回到开头的话题，在我们搞定了上述三条之后，如果想让其他机器通过拨了anyconnect的机器共享访问VPN资源的话，只需要在拨了anyconnect的机器上再运行两条命令即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">echo </span>1 &gt; /proc/sys/net/ipv4/ip_forward
</span><span class='line'>iptables -t nat -A POSTROUTING -o cscotun0 -j MASQUERADE
</span></code></pre></td></tr></table></div></figure>


<p>你可以将上面两条命令添加到：<code>/etc/rc.local</code> 即可在开机时自动执行了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[电动直升机的油门锁定（THRU HOLD）和油门熄火（THRU CUT）]]></title>
    <link href="http://www.markzhang.cn/blog/2015/07/24/throttle-hold-and-throttle-cut/"/>
    <updated>2015-07-24T11:43:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2015/07/24/throttle-hold-and-throttle-cut</id>
    <content type="html"><![CDATA[<p><code>油门锁定</code> 和 <code>油门熄火</code> 是不太容易理解的两个东西，关键是他们俩有什么区别。5IMX上有一篇帖子挺精彩的：</p>

<p><a href="http://bbs.5imx.com/bbs/forum.php?mod=viewthread&amp;tid=544614&amp;page=1">http://bbs.5imx.com/bbs/forum.php?mod=viewthread&amp;tid=544614&amp;page=1</a></p>

<!-- more -->


<p>看了上面的帖子，又看了看14SG的说明书，其实这两个功能涉及到的东西都是油门和桨距（pitch）这两个东西。我是这么理解的：</p>

<p>有关油门锁定：</p>

<ul>
<li>在14SG中，油门锁定是一个 <code>condition</code>，跟 <code>normal</code>, <code>idle up1</code>, <code>idle up2</code>一样，可以用开关来切换</li>
<li>顾名思义，油门锁定启动后，油门（THROTTLE）的值将会被锁定在设定值上，但是桨距曲线依然管用，这就是为什么油门锁定被设计成一个 <code>condition</code></li>
<li>所以我的理解，油门锁定可以用于一些固定油门通道，只控制桨距的场景。比如自旋，降落</li>
</ul>


<p>有关油门熄火：</p>

<p>貌似这个概念是从油机过来的。由于现在大家都在玩电直，没有油直的背景，所以对这个东西的理解就很费劲。我也不太理解这个东西，我只是看了下14SG上这个功能的设置，有这么几个理解：</p>

<ul>
<li>油门熄火不是一种 <code>condition</code>，所以和油门锁定不同，你无法针对油门熄火这种情况设定桨距曲线，也就是说，当油门熄火启动时，桨距曲线将遵循油门熄火启动之前的设定</li>
<li>14SG中的油门熄火设置中，有一项 <code>THRO</code> 的百分比设置，这个设置跟油门熄火中的 <code>THRO</code> 设定不同，这里的 <code>THRO</code> 不是指当油门熄火启动时，要将油门设定到什么值。这个设定指的是，当当前油门值小于该设定值时，油门熄火功能启动 &mdash; 当然，有一个前提就是对应的油门熄火开关拨到了启动位置</li>
<li>所以14SG上，要启动油门熄火有两个条件：开关打开、当前油门值低于设定的 <code>THRO</code> 值</li>
<li>当油门熄火功能启动后（满足上述两个条件），14SG会把油门设成0</li>
<li>针对电直，我没想到特别适合油门熄火这个功能的场景。我现在是把这个当调试机器的一个功能来用。比如起飞前，我启动油门熄火功能，然后就可以用控来测试桨距、副翼、升降、方向等所有通道，而电机是不会转动的（因为油门是0）。当然你可以把电机线拔掉做同样的测试。</li>
</ul>


<p>其实可以自己在控上琢磨琢磨大概就能搞清楚这两个功能的区别，控上的 <code>Servo</code> 这个功能很实用，你做了任何设置都可以在这里看到各个通道的变化。所以当你设置油门锁定和油门熄火之后，在 <code>Servo</code> 这里就可以很方便的观察油门和桨距两个通道的变化了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NVIDIA Linux驱动在Ubuntu 12.04上的安装]]></title>
    <link href="http://www.markzhang.cn/blog/2015/06/03/nvidia-linux-driver-on-ubuntu/"/>
    <updated>2015-06-03T21:35:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2015/06/03/nvidia-linux-driver-on-ubuntu</id>
    <content type="html"><![CDATA[<p>在Ubuntu上安装显卡驱动不是一件容易的事情，安装不是Ubuntu官方认证过的NVIDIA自家的驱动就更是困难，而我选择在一个老的Ubuntu版本上安装显卡驱动，事情就变的更加麻烦起来。</p>

<p>其实一开始我也不想安装NVIDIA自家的驱动，首先想尝试用 <code>nouveau</code>，但是悲剧的发现Ubuntu 12.04上的nouveau无法驱动我的GTX970，可能需要新版本的Ubuntu才可以。所以，被迫选择安装NVIDIA自家的驱动。</p>

<!-- more -->


<p>安装和使用N卡驱动中途遇到了很多的问题，这里来个总结。</p>

<h2>第一次安装</h2>

<p>现在总结起来，可以按照如下步骤来：</p>

<ul>
<li>禁用nouveau和其他相关的module：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo vi /etc/modprobe.d/blacklist.conf
</span><span class='line'>
</span><span class='line'>添加：
</span><span class='line'>
</span><span class='line'>blacklist vga16fb
</span><span class='line'>blacklist nouveau
</span><span class='line'>blacklist rivafb
</span><span class='line'>blacklist nvidiafb
</span><span class='line'>blacklist rivatv
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>卸载nvidia相关的package，否则NVIDIA驱动安装的时候会报错：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>dpkg -l|grep nvidia
</span><span class='line'>sudo apt-get remove &lt;nvidia packages&gt;
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>安装一些常用的package，比如：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo apt-get install build-essential
</span><span class='line'>sudo apt-get install ia32-libs
</span></code></pre></td></tr></table></div></figure>


<p>这是因为NVIDIA驱动安装的时候，会编译kernel module（nvidia.ko），所以需要一些常用的开发用的package。</p>

<ul>
<li><p>NVIDIA驱动安装的时候，X server不能运行，所以我是这么做的：</p></li>
<li><p>重启系统，在grub界面选择进入 <code>Recovery</code> 模式</p></li>
<li>进入Recovery之后，选择 <code>Enable Network</code></li>
<li>重新返回到Recovery界面，选择 <code>Drop to root console</code></li>
<li>运行NVIDIA驱动安装包，按照提示操作即可</li>
</ul>


<p>之所以要做一次 <code>Enable Network</code> 是因为，这个选项会mount一些必要的文件系统，比如 <code>/tmp</code>，NVIDIA驱动安装的时候是需要 <code>/tmp</code> 的。</p>

<h2>Ubuntu更新kernel之后</h2>

<p>如果你使用了Ubuntu的 <code>Update Manager</code> 更新了package之后，一定要注意是否有升级kernel，如果升级了kernel，那么很可能你需要重新安装一次NVIDIA的驱动。</p>

<p>这是因为上面也提到了，<code>nvidia.ko</code> 需要重新编译。所以，如果你更新了kernel，发现X server起不来了，那么就可以尝试这么来：</p>

<ol>
<li>重启系统，在grub界面选择进入 <code>Recovery</code> 模式</li>
<li>进入Recovery之后，选择 <code>Enable Network</code></li>
<li>重新返回到Recovery界面，选择 <code>Drop to root console</code></li>
<li>运行 <code>nvidia-uninstall</code> 卸载当前的NVIDIA驱动</li>
<li>重新运行NVIDIA驱动安装包，再安装一遍驱动</li>
</ol>


<p>之前我尝试过不运行 <code>nvidia-uninstall</code>，直接再次安装一遍驱动，发现这样做的话，安装包也会提醒你说发现当前已经安装了驱动，说是否需要卸载再重新安装。然后我就选择OK，但是发现这样操作下来之后有的时候还是不行，所以还是自己手动uninstall，然后再安装吧。</p>

<h2>如何看出错日志</h2>

<p>主要就是要看两个东西：</p>

<ul>
<li>dmesg：这是kernel的log，看nvidia的内核驱动是否有什么错误，crash，如果有，就Google一下错误信息看是否有帮助</li>
</ul>


<p>这里提一下，看到这个信息是正常的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="o">[</span>    1.222765<span class="o">]</span> nvidia: module license <span class="s1">&#39;NVIDIA&#39;</span> taints kernel.
</span><span class='line'><span class="o">[</span>    1.225367<span class="o">]</span> nvidia: module verification failed: signature and/or  required key missing - tainting kernel
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>/var/log/Xorg.0.log：这里主要是看NVIDIA的X server driver（nvidia_drv.so）是否有错误，crash</li>
</ul>


<h2>万般无奈怎么办</h2>

<ul>
<li><p>去 <a href="http://www.geforce.com/drivers">http://www.geforce.com/drivers</a> 看看有没有BETA版本的驱动下载，有的话下载下来试试。再说一次，记得先uninstall当前的驱动再安装新的。</p></li>
<li><p>去NVIDIA的论坛报bug，我没这么干，因为本身我用的Ubuntu就是老版本了，估计NVIDIA也不会理我，如果去报告Ubuntu 14.04上的bug，可能NVIDIA会创建bug并派人fix。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编译out-of-tree的kernel模块]]></title>
    <link href="http://www.markzhang.cn/blog/2015/05/12/build-out-of-tree-kernel-module/"/>
    <updated>2015-05-12T10:51:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2015/05/12/build-out-of-tree-kernel-module</id>
    <content type="html"><![CDATA[<p>所谓 <code>out-of-tree</code> 的内核模块，指的是源代码不在kernel tree里面的模块，比如 <code>nouveau</code> 的tree。</p>

<p>熟悉nouveau的都知道，nouveau的maintainer是单独维护nouveau tree的，所以，一般来说，我们会把nouveau的代码直接放在一个目录下，然后将nouveau编译成一个模块（.ko），这样来编译运行测试就都比较简单。</p>

<!-- more -->


<p>所以关于如何编译一个 <code>out-of-tree</code> 的内核模块，其实内核是有官方文档的：</p>

<p><a href="https://www.kernel.org/doc/Documentation/kbuild/modules.txt">https://www.kernel.org/doc/Documentation/kbuild/modules.txt</a></p>

<p>我一般是这么编译的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>make <span class="nv">ARCH</span><span class="o">=</span>arm64 <span class="nv">CROSS_COMPILE</span><span class="o">=</span>&lt;your toolchain&gt; <span class="nv">INSTALL_MOD_PATH</span><span class="o">=</span>&lt;kernel module install path&gt; <span class="nv">M</span><span class="o">=</span>~/nouveau/drm/nouveau/ -C &lt;the kernel root directory&gt; -j4 modules
</span><span class='line'>make <span class="nv">ARCH</span><span class="o">=</span>arm64 <span class="nv">CROSS_COMPILE</span><span class="o">=</span>&lt;your toolchain&gt; <span class="nv">INSTALL_MOD_PATH</span><span class="o">=</span>&lt;kernel module install path&gt; <span class="nv">M</span><span class="o">=</span>~/nouveau/drm/nouveau/ -C &lt;the kernel root directory&gt; modules_install
</span></code></pre></td></tr></table></div></figure>


<p>一些注意点：</p>

<ul>
<li><p>所谓 <code>kernel root directory</code> 就是能找到.config文件的那个目录</p></li>
<li><p>使用 <code>M=</code> 来指定nouveau在哪里，注意这里要指到 <code>KBuild</code> 所在的那个目录</p></li>
<li><p>kernel本身也有nouveau driver（位与drivers/gpu/drm/nouveau），所以在编译我们的nouveau之前，要先在kernel config中设置编译nouveau为module，然后编译kernel，这样就会出现一个nouveau.ko（来自drivers/gpu/drm/nouveau），这个时候才可以开始用上面的命令行来编译我们自己的nouveau。而我们的nouveau编译完成，module_install的时候，会被安装到 <code>extra</code> 目录下，所以不会和原来的nouveau.ko冲突。但是为了避免困扰，我们可以将原来的nouveau.ko删掉。</p></li>
<li><p>如果你曾经使用 <code>O=&lt;dir&gt;</code> 设置了kernel编译的output dir，那么上面的命令行有可能会不work</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git am失败的时候怎么办]]></title>
    <link href="http://www.markzhang.cn/blog/2015/05/11/deal-with-git-am-failures/"/>
    <updated>2015-05-11T10:15:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2015/05/11/deal-with-git-am-failures</id>
    <content type="html"><![CDATA[<p>本文主要参考了以下文章:</p>

<p><a href="http://www.pizzhacks.com/bugdrome/2011/10/deal-with-git-am-failures/">http://www.pizzhacks.com/bugdrome/2011/10/deal-with-git-am-failures/</a></p>

<p><code>git am</code> 或 <code>git am -3</code> 打patch的时候经常会遇到fail，就是因为patch不apply。但是 <code>git am</code> 不像 <code>git cherry-pick</code> 一样会显示冲突的地方从而让我们可以修改，很多时候 <code>git am</code> 并不显示冲突，只是让我们修正冲突，这就产生了麻烦。</p>

<!-- more -->


<p>于是上面的文章就很好的解决了这个问题，因为一般产生冲突的时候，并不是所有的改动都有冲突，往往冲突是比较少的（<code>patch</code> 本身是可以智能的自动解决一些冲突的），所以我们就可以先用 <code>git apply</code> 来打patch，并将冲突存为一个单独的文件，最后查看冲突文件再手动将冲突修正就可以了。</p>

<p>引用上面文章中的内容，当 <code>git am</code> 失败的时候，可以这么做：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>git apply PATCH --reject
</span><span class='line'><span class="nv">$ </span>edit edit edit
</span><span class='line'><span class="nv">$ </span>git add FIXED_FILES
</span><span class='line'><span class="nv">$ </span>git am --resolved
</span></code></pre></td></tr></table></div></figure>


<p>当 <code>git am</code> 失败的时候，它会告诉你patch文件被它放在了一个路径下面，所有，你只需要直接去 <code>git apply --reject</code> 这个patch就好了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>The copy of the patch that failed is found in...
</span><span class='line'>        xxxxxx
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[卓普大黑（C7、zp990）增大data分区]]></title>
    <link href="http://www.markzhang.cn/blog/2015/04/05/zopo-c7-increase-primary-partition/"/>
    <updated>2015-04-05T18:18:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2015/04/05/zopo-c7-increase-primary-partition</id>
    <content type="html"><![CDATA[<p>现在的Android APP对空间的使用是越来越大，APP本身一般都有几十M，再加上使用过程中也会消耗大量存储，比如微信就经常会使用到上百M空间。</p>

<p>卓普大黑的默认data分区大小是3G，随着安装的APP越来越多，data分区就经常会被耗尽。所以，增大data分区就顺理成章的成为一个需求。</p>

<!-- more -->


<p>卓普大黑使用的是MTK的方案，所以以下描述的方法对MTK 6589（6589T）的机器都适用。本文主要参考了：</p>

<p><a href="http://forum.xda-developers.com/showthread.php?t=2455850&amp;nocache=1">http://forum.xda-developers.com/showthread.php?t=2455850&amp;nocache=1</a></p>

<p>方法很简单，就是修改线刷包中的 <code>EBR1</code> 和 <code>EBR2</code> 这两个文件，因为这两个文件定义了System, cache, data等诸多分区的大小。所以，在上面给出的帖子中就有下载对应的 <code>EBR1</code> 和 <code>EBR2</code> 这两个文件的。我的大黑是32G的版本，选择的是将data分区扩大到7GB。</p>

<p>由于上述的帖子中将 <code>EBR1</code> 和 <code>EBR2</code> 这两个文件是放在了4share上，这个网站是被墙的，所以这里将我使用的 <code>EBR1</code> 和 <code>EBR2</code> 文件放在这里：</p>

<p><a href="http://www.markzhang.cn/downloads/file/ebr-mtk-6589-partizione-7gb.zip">ebr-mtk-6589-partizione-7gb.zip</a></p>

<p>再次重申这两个文件我是在我的大黑上测试OK的，虽然上面给出的帖子中说MTK的 6577/ 6582/ 6589 /6592 /8382 都可以，但是我只测试过6589。</p>

<p>使用这两个文件替换掉线刷包里面原来的同名文件，然后刷机即可。</p>

<p>没有使用过线刷的，可以看我之前的一篇文章：</p>

<p><a href="http://markzhang.cn/blog/2014/06/08/zopo-c7-flash/">卓普大黑（Zopo C7/zp990）刷原生ROM，root，升级触控屏，修改GPS</a></p>

<p>刷完之后就可以看到data分区变成了7GB：</p>

<p><img src="http://www.markzhang.cn/downloads/image/zopo-c7-7gb-data-partition.jpg" alt="Zopo C7 7GB data partition" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RouterOS：为什么我不用chnroutes]]></title>
    <link href="http://www.markzhang.cn/blog/2015/03/04/why-i-leave-chnroutes/"/>
    <updated>2015-03-04T09:28:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2015/03/04/why-i-leave-chnroutes</id>
    <content type="html"><![CDATA[<p>之前有一篇文章说了在RouterOS下配置chnroutes：</p>

<p><a href="http://markzhang.cn/blog/2014/08/20/ros-chnroutes/">RouterOS配置记录（二）：chnroutes</a></p>

<p>配置了chnroutes之后，国内IP不走VPN，国外的走VPN，一切看起来都很好。但是随着使用时间的增长，发现了一些问题：</p>

<!-- more -->


<ul>
<li><p>CDN的问题。由于翻墙的需要，所以我们不会使用ISP给我们提供的DNS server。一般来说，我们都会使用诸如 <code>8.8.8.8</code> 或者OpenDNS来作为我们的DNS server。但是由于这些地址本身就是国外地址，所以当访问这些DNS server的时候，根据chnroutes配置的策略，就会走VPN走。这样一来，对于你要访问的网站来说，它会认为你是一个国外的IP，从而无法给你正确的你想要的一个CDN IP。这就是为什么有的时候访问国内的一些在线直播的网站，挂上VPN和chnroutes就会卡，拿掉立马就好了的原因。</p></li>
<li><p>VPN的主要作用是用来访问被墙的网站，一般来说VPN本身的带宽都不会特别大（除非你很有钱买高档VPN），所以其实对于一些没有被墙的国外网站，不使用VPN其实更加快捷。</p></li>
<li><p>PSN（PlayStation Network，现在叫Sony Entertainment Network）无法登录，一些游戏在线搜索不到房间。具体原因我还不清楚，我的感觉可能是PSN的服务器和认证服务器不是同一个IP，而且一个是国内IP一个是国外IP。可能认证服务器需要验证客户端的IP地址，而认证服务器拿到的客户端的IP并不是之前我们连接PSN服务器的那个IP，这样导致了混乱。当然这是纯YY，很可能是其他原因。总之就是PSN无法登录，有一些游戏的在线联机也没法工作。</p></li>
</ul>


<p>基于此，我在想我是否真的需要chnroutes。现在想来其实我并不需要，因为我的需求基本上就只有一条：访问Google，包括gmail, google gerrit, plus, drive&hellip;</p>

<p>所以我开始构思不使用chnroutes的另外一条道路。</p>

<p>最一开始没想彻底抛弃chnroutes，就想先解决第一个问题，对于我来说，这个问题是最关键的。所以对于这个问题，很自然的就想到了 &mdash; 把DNS server的IP也加到chnroutes的地址表里面，假装成国内的IP不就OK了嘛&hellip; 试验了一下发现无效，因为这样一来，DNS的请求就会经过墙，DNS劫持就发生了，现象就是你访问google/youtube，出来的是另外一个网站，或者干脆就是连接不上。</p>

<p>有朋友建议我用TCP DNS，这样可以解决墙的DNS劫持的问题。但是这也不好做，因为我是配置ROS作为整个家里局域网的DNS server的，ROS本身是不支持TCP DNS的，为此有人（也是中国小伙）还在Mikrotik的论坛上发过类似的帖子：</p>

<p><a href="http://forum.mikrotik.com/viewtopic.php?t=68248">How to force DNS requests using tcp protocol!</a></p>

<p>其次，如果不使用ROS作为DNS server，也就是说让局域网内每台设备手动配置DNS（比如配置成OpenDNS的IP），这样貌似可行但其实也非常麻烦。因为TCP DNS毕竟是非常规需求，而且现在的设备早已不局限于电脑，还包括了手机、pad甚至各种嵌入式设备（比如树莓派、存储服务器等）。这些东西能否支持TCP DNS也是一个问题。</p>

<p>接下来我想到了autoproxy gfwlist：</p>

<p><a href="https://code.google.com/p/autoproxy-gfwlist/">https://code.google.com/p/autoproxy-gfwlist/</a></p>

<p>这张列表包含了天朝人民发现的被墙的网址和IP。我的想法很简单，既然chnroutes的IP列表太宽泛，那就找一张精准的表好了。结果把autoproxy这张表拿出来一看，傻了。因为这张表中包含了诸如：<code>*.google.com</code> 这样的网址，这样的东西在ROS里面如何处理？因为ROS作为路由设备，是只认识IP地址的，对域名它可是没有办法的。</p>

<p>虽然ROS的确是有一个叫做 <code>WebProxy</code> 的功能，但是通读了这个功能的manual之后，你会发现你只能针对域名设置 <code>Allow</code> 和 <code>Deny</code>，没有更多的动作可以做了。</p>

<p>如果你Google <code>routeros autoproxy gfwlist</code>，你会发现github上有一个项目叫 <code>gfwlist2routeros</code>：</p>

<p><a href="https://github.com/layerssss/gfwlist2routeos">https://github.com/layerssss/gfwlist2routeos</a></p>

<p>显然这也是国内某位大神的作品。但是就在项目的README中，也写到了：</p>

<blockquote><p>gfwlist 中包含一些通配符规则，如 <em>.google.com.</em> 之类的，该项目无法识别</p></blockquote>

<p>再次受挫感觉心灰意冷。在决定要放弃之前想到了最后一个笨办法。因为我的需求相对简单，主要就是要使用Google，所以我想我就自己建一个网站list，然后在路由器上写一个脚本，定时去解析这些网站然后将IP地址储存下来。这样当脚本运行了一定次数之后，我想可能绝大部分Google的这些IP就都能采集到，然后设置这些IP地址走VPN即可。</p>

<p>花了几个小时写完了脚本，然后设置了定时执行，睡了一觉之后起来之后测试发现还是不行。现象还是一样，要不就是网站被劫持了要不就是连不上。</p>

<p>分析了一下大致是这么几个原因：</p>

<ul>
<li><p>脚本在ROS上run，做DNS解析的时候也必须要从VPN走，否则就会被墙劫持。虽然我对OpenDNS的IP做了处理，但是我发现那些规则是在Firewall里面做的，对于ROS来说，它是不通过Firewall的&hellip;</p></li>
<li><p>修改了脚本，脚本一开始，将OpenDNS的IP加入到了静态路由中，解析完成后删除，发现还是不行。后来一想，局域网中有很多设备都是开着的，只要这些设备一访问Google，就会在ROS的DNS server中产生cache，这样我的脚本取到的IP地址就不正确了，因为这些地址都是墙参与产生的&hellip;</p></li>
</ul>


<p>到此彻底没了脾气。休息了一天之后发现ROS的DNS有静态DNS的功能（<code>/ip dns static</code>），于是又想到了可能可以对上面的方案做一点改进来达到目的。最终目的达成测试OK，具体来说我的做法是这样的：</p>

<ul>
<li>首先我写了一个脚本，在我的VPS上定时运行。这个脚本非常简单，就是去解析我给定的一个网站list，解析出每个网站的IP地址然后存成文件。将脚本放在VPS上执行而不是在ROS上执行的好处就是：彻底回避了墙。而且最后这些IP地址要从VPS走，所以在VPS上做DNS解析是最正确的做法了。脚本是这样的：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#!/bin/bash</span>
</span><span class='line'><span class="nv">HOSTS</span><span class="o">=(</span>
</span><span class='line'>  <span class="s1">&#39;www.google.com&#39;</span>
</span><span class='line'>  <span class="s1">&#39;www.googleapis.com&#39;</span>
</span><span class='line'>  <span class="s1">&#39;www.gstatic.com&#39;</span>
</span><span class='line'>  <span class="s1">&#39;mail.google.com&#39;</span>
</span><span class='line'>  <span class="s1">&#39;accounts.google.com&#39;</span>
</span><span class='line'>  <span class="s1">&#39;plus.google.com&#39;</span>
</span><span class='line'>  <span class="s1">&#39;play.google.com&#39;</span>
</span><span class='line'>  <span class="s1">&#39;www.gmail.com&#39;</span>
</span><span class='line'>  <span class="s1">&#39;drive.google.com&#39;</span>
</span><span class='line'><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="nb">echo</span> -n <span class="s2">&quot;&quot;</span> &gt; /home/mark/vpn-hosts-ips
</span><span class='line'>
</span><span class='line'><span class="k">for </span>i in <span class="k">${</span><span class="nv">HOSTS</span><span class="p">[@]</span><span class="k">}</span>; <span class="k">do</span>
</span><span class='line'><span class="k">  </span><span class="nv">ip</span><span class="o">=</span><span class="sb">`</span>ping -c 1 <span class="k">${</span><span class="nv">i</span><span class="k">}</span> |grep PING|cut -d <span class="s2">&quot; &quot;</span> -f3|tail -c +2|head -c -2<span class="sb">`</span>
</span><span class='line'>  <span class="nb">echo</span> <span class="k">${</span><span class="nv">ip</span><span class="k">}</span> &gt;&gt; /home/mark/vpn-hosts-ips
</span><span class='line'><span class="k">done</span>
</span><span class='line'>
</span><span class='line'>cp /home/mark/vpn-hosts-ips /Public/pub
</span><span class='line'>chmod 644 /Public/pub/vpn-hosts-ips
</span></code></pre></td></tr></table></div></figure>


<p>使用Cron将这个脚本定时执行。脚本的最后将生成的文件放到了 <code>/Public/pub</code> 目录下，这是一个FTP的目录，作用就是接下来ROS可以下载到这个文件。</p>

<ul>
<li>在ROS上写一个脚本，这个脚本也是定时执行。脚本会通过FTP，去download上面步骤中生成的IP地址列表文件，然后将这些IP地址添加到静态DNS中，同时也将这些IP添加到一个address list中。这样通过 <code>/ip firewall mangle</code> 和路由表的设定，设置好这些IP地址从VPN走。ROS上的脚本是这个样子的：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>:global hosts <span class="o">{</span><span class="se">\</span>
</span><span class='line'><span class="s2">&quot;www.google.com&quot;</span>;<span class="se">\</span>
</span><span class='line'><span class="s2">&quot;www.googleapis.com&quot;</span>;<span class="se">\</span>
</span><span class='line'><span class="s2">&quot;www.gstatic.com&quot;</span>;<span class="se">\</span>
</span><span class='line'><span class="s2">&quot;mail.google.com&quot;</span>;<span class="se">\</span>
</span><span class='line'><span class="s2">&quot;accounts.google.com&quot;</span>;<span class="se">\</span>
</span><span class='line'><span class="s2">&quot;plus.google.com&quot;</span>;<span class="se">\</span>
</span><span class='line'><span class="s2">&quot;play.google.com&quot;</span>;<span class="se">\</span>
</span><span class='line'><span class="s2">&quot;www.gmail.com&quot;</span>;<span class="se">\</span>
</span><span class='line'><span class="s2">&quot;drive.google.com&quot;</span>;<span class="o">}</span>;
</span><span class='line'>
</span><span class='line'>/tool fetch <span class="nv">mode</span><span class="o">=</span>ftp <span class="nv">url</span><span class="o">=</span><span class="s2">&quot;ftp://&lt;vps ip&gt;/pub/vpn-hosts-ips&quot;</span>
</span><span class='line'>
</span><span class='line'>:global content <span class="o">[</span>/file get <span class="o">[</span>/file find <span class="nv">name</span><span class="o">=</span>vpn-hosts-ips<span class="o">]</span> contents<span class="o">]</span>
</span><span class='line'>:global contentLen <span class="o">[</span> :len <span class="nv">$content</span> <span class="o">]</span>
</span><span class='line'>:global lineEnd 0
</span><span class='line'>:global line <span class="s2">&quot;&quot;</span>
</span><span class='line'>:global lastEnd 0
</span><span class='line'>:global index 0
</span><span class='line'>
</span><span class='line'>/ip dns static remove <span class="o">[</span>/ip dns static find<span class="o">]</span>
</span><span class='line'>/ip firewall address-list remove <span class="o">[</span>/ip firewall address-list find<span class="o">]</span>
</span><span class='line'>
</span><span class='line'>:do <span class="o">{</span>
</span><span class='line'>    :set lineEnd <span class="o">[</span>:find <span class="nv">$content</span> <span class="s2">&quot;\n&quot;</span> <span class="nv">$lastEnd</span><span class="o">]</span>
</span><span class='line'>    :set line <span class="o">[</span>:pick <span class="nv">$content</span> <span class="nv">$lastEnd</span> <span class="nv">$lineEnd</span><span class="o">]</span>
</span><span class='line'>    :set lastEnd <span class="o">(</span> <span class="nv">$lineEnd</span> + 1 <span class="o">)</span>
</span><span class='line'>
</span><span class='line'>    /ip dns static add <span class="nv">address</span><span class="o">=</span><span class="nv">$line</span> <span class="nv">name</span><span class="o">=[</span>:pick <span class="nv">$hosts</span> <span class="nv">$index</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'>    :local found <span class="nb">false</span>
</span><span class='line'>    :foreach j <span class="nv">in</span><span class="o">=[</span>/ip firewall address-list find <span class="nv">address</span><span class="o">=</span><span class="nv">$line</span><span class="o">]</span> <span class="k">do</span><span class="o">={</span>
</span><span class='line'>        :set found <span class="nb">true</span>;
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    :if <span class="o">(</span><span class="nv">$found</span> <span class="o">=</span> <span class="nb">false</span><span class="o">)</span> <span class="k">do</span><span class="o">={</span>
</span><span class='line'>        /ip firewall address-list add <span class="nv">list</span><span class="o">=</span><span class="s2">&quot;vpn-list&quot;</span> <span class="nv">address</span><span class="o">=</span><span class="nv">$line</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    :set index <span class="o">(</span> <span class="nv">$index</span> + 1 <span class="o">)</span>
</span><span class='line'><span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="nv">$lineEnd</span> &lt; <span class="nv">$contentLen</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>/ip dns cache flush
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>在客户端的机器上刷新DNS缓存。如果是windows，那么打开 <code>CMD</code>，输入：<code>ipconfig /flushdns</code> 即可。</li>
</ul>


<p>这样一来结果基本上满意了，测试访问google都一切正常。而且在ROS上，我也不再需要使用任何其他DNS了，使用ISP提供的DNS就可以了。</p>

<p>唯一的缺点就是，我们需要手动维护一张网站list，所以如果要翻墙的网站很多的话，这个方法是不适合的。我想如果谁有一个比较全的常用的Google的site list的话，不妨共享一下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux定时任务 - Cron]]></title>
    <link href="http://www.markzhang.cn/blog/2015/03/03/cron/"/>
    <updated>2015-03-03T17:09:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2015/03/03/cron</id>
    <content type="html"><![CDATA[<ul>
<li><p>crontab -e编辑定时任务，crontab -l查看。最后的cron任务文件保存在/var/spool/cron/crontab目录下</p></li>
<li><p>cron会切换到/var/spool/cron/crontab目录下cron文件的owner这个用户，然后执行定义的定时任务。</p></li>
</ul>


<!-- more -->


<ul>
<li>但是cron切换用户的时候，任何环境变量，包括.bashrc都不会被执行到。所以诸如$HOME这样的变量也是没有定义的。所以，一般在定时任务的脚本中，我们会这样处理：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#!/bin/bash</span>
</span><span class='line'><span class="nv">HOME</span><span class="o">=</span>/home/markz
</span><span class='line'><span class="nb">source</span> <span class="k">${</span><span class="nv">HOME</span><span class="k">}</span>/.bashrc
</span><span class='line'><span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span>/usr/local/bin:<span class="nv">$PATH</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后才是具体的要执行的任务。</p>

<p>有一点注意，~/.bashrc往往都含有大量的定义和脚本执行，这有可能会影响到source的成功执行。我们之所以在需要cron的脚本中加入这句source，大多数情况下是为了定义一些环境变量。所以为了让source能保证成功，一般我们都会把需要的环境变量单独存放到一个文件中，然后去source那个文件即可。直接source ~/.bashrc不是一个好的做法。</p>

<ul>
<li><p>/var/log/syslog保存了cron的log，查看该log可以方便的知道定时任务执行的一些情况。</p></li>
<li><p>不要assume cron会在你想要的目录下执行脚本/程序，所以，奔放但是有效的做法是，在你的定时脚本和程序中，请全部使用绝对路径。</p></li>
<li><p>貌似crontab -e的时候，命令行中不能使用>&amp;，否则会导致命令不会被定时触发。可以使用这个来代替：</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;cmd...&gt; &gt;&gt; /home/super/cmd.log 2&gt;&amp;1
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>定义定时任务（crontab -e）的几个例子：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># 每小时执行一次</span>
</span><span class='line'>0 * * * * /script/path
</span><span class='line'>
</span><span class='line'><span class="c"># 每五分钟执行一次</span>
</span><span class='line'>0,5,10,15,20,25,30,35,40,45,50,55 * * * * /script/path
</span><span class='line'>
</span><span class='line'><span class="c"># 每五分钟执行一次</span>
</span><span class='line'><span class="c"># 这种写法不保证在所有Linux distribution上都能work</span>
</span><span class='line'>0-59/5 * * * * /script/path
</span><span class='line'>
</span><span class='line'><span class="c"># 每分钟执行一次</span>
</span><span class='line'>0-59 * * * * /script/path
</span><span class='line'>
</span><span class='line'><span class="c"># 每天执行一次</span>
</span><span class='line'>* 0 * * * /script/path
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[有关DMABUF/DMA Mapping/IOMMU/CMA/TTM/GEM/GART/SMMU]]></title>
    <link href="http://www.markzhang.cn/blog/2015/03/02/dmabuf-dma-mapping-iommu-gem/"/>
    <updated>2015-03-02T11:06:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2015/03/02/dmabuf-dma-mapping-iommu-gem</id>
    <content type="html"><![CDATA[<ol>
<li><p>DMABUF can be used as a wrapper to encapsulate other memory management frameworks. All these memory management framework(I mean mostly for graphics), buffer is the keypoint. DMABUF defines a standard buffer structure. So DMABUF can be used as a wrapper for TTM/GEM/Android ION&hellip; and etc. Notice DMABUF can&rsquo;t replace these things, cause it doesn&rsquo;t cover everything. E.g: DMABUF has no userspace interfaces, right now only kernel interfaces(can be used in device driver).</p></li>
<li><p>Kernel has DMA mapping API from origin. ARM defines IOMMU which can be used to connect scattered physical memory as a continuous region for devices which needs continue address to work(e.g: DMA). So IOMMU implementations &amp; CMA should work behind kernel DMA mapping API. E.g: dma_alloc_from_contiguous can be implemented by CMA; dma_alloc_coherent can be implemented by IOMMU or by the normal case(just call __get_free_pages). So for device drivers need dma buffers, we should use dma mapping APIs, not call iommu api directly.</p></li>
<li><p>For tegra, GART &amp; SMMU can be used to implement IOMMU apis.</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux graphics stack 随便写写]]></title>
    <link href="http://www.markzhang.cn/blog/2015/03/02/linux-graphics-stack-notes/"/>
    <updated>2015-03-02T11:03:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2015/03/02/linux-graphics-stack-notes</id>
    <content type="html"><![CDATA[<ul>
<li><p>Display and mode setting: DRM. DRM defines connector/encoder/crtc to support display(including multi-monitor). And KMS makes mode setting happens in kernel space.</p></li>
<li><p>2D acceleration: X server EXA/UXA extension. Vendor should write a X server driver which implements EXA or UXA(should be upstreamed). UXA is an enhancement design of EXA, proposed by intel, so GEM is used in UXA. DRM has no direct 2D acceleration interface definitions(e.g: memory copy/move, blit, color space conversion&hellip;), this is defined in EXA/UXA extensions. But vendor&rsquo;s X server driver will use drm functions, mostly is buffer manipulations.</p></li>
<li><p>3D acceleration: via Mesa. Mesa has 2 parts:</p></li>
</ul>


<!-- more -->


<ol>
<li>libGL.so &mdash; the implementation of OpenGL spec, the default OpenGL implementation library in Linux. This libGL.so translates OpenGL callings to Mesa-specified instructions.</li>
<li>DRI driver &mdash; the driver accepts the Mesa-specified instructions generated by libGL.so and call drm functions to get them accelerated in GPU. Should be upstreamed.</li>
</ol>


<p>DRM: has userspace libdrm &amp; kernel space drm driver.</p>

<p>libdrm: Implemented drm APIs. Vendor can hook it&rsquo;s implementations as well as add more APIs which used by EXA/UXA driver(2D) or DRI driver(3D). That&rsquo;s why the build result of libdrm normally has 2 libraries(e.g: libdrm.so &amp; libdrm_intel.so). Vendor codes of libdrm should be upstreamed.</p>

<p>Kernel drm driver: Works under kernel drm framework, should be upstreamed. Cause vendor can add APIs in libdrm, so kernel drm driver can handle vendor specified ioctls.</p>

<p>GLX: X server extension of OpenGL. X server has DRI/DRI2 extensions as well.</p>

<p>They&rsquo;re working with libGL.so in Mesa. By these extensions, Mesa can do:</p>

<ol>
<li><p>Direct rendering: libGL.so in Mesa try to figure out whether DRI driver is ready in Mesa. If so, GLX returns some infos(such as window size, position&hellip;) or create off-screen buffers(via DRI/DRI2 X extension) for Mesa. The rendering is handled in Mesa&rsquo;s DRI driver &mdash; no relations with X server.</p></li>
<li><p>Indirect rendering: libGL.so in Mesa can&rsquo;t find out Mesa&rsquo;s DRI driver. So it queries whether DRI is available in X server. If so, it pass the Mesa-specified instructions which generated by libGL.so to X server. And GLX/DRI/DRI2 extensions of X server handles the rest things. Normally it&rsquo;s software rendering which implemented by Mesa as well. AIGLX(Accelerated Indirect GLX) seems has some solutions to accelerate this.</p></li>
</ol>


<p>So Mesa handles a lot of works in linux 3D graphics stack. And it has lots of relations with X server as well(GLX and DRI X extensions).</p>

<p>An important reason that why we involve so many components is, decouple the dependencies of all of these guys. According to this design, DRM is not related with X server so it works with other programs as well(e.g: Wayland). Mesa is the same.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[32/64的问题：32bit指针转换成64bit - Sign Extension]]></title>
    <link href="http://www.markzhang.cn/blog/2014/12/16/convert-32bit-pointer-to-64bit/"/>
    <updated>2014-12-16T15:09:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2014/12/16/convert-32bit-pointer-to-64bit</id>
    <content type="html"><![CDATA[<p>32/64有很多问题，指针转换是其中一个，比如这个例子：</p>

<!-- more -->




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mh">0xc8f68000</span><span class="p">;</span>
</span><span class='line'><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个时候得到的 <code>v</code> 是： <code>0xffffffffc8f68000</code> 而不是 <code>0x00000000c8f68000</code></p>

<p>以上例子来自：</p>

<p><a href="http://stackoverflow.com/questions/22239752/convert-32-bit-pointer-to-64-bit-integer">http://stackoverflow.com/questions/22239752/convert-32-bit-pointer-to-64-bit-integer</a></p>

<p>最近就碰到了好几次类似的问题。原因非常简单，就是编译器看到我们要把一个指针转换成 <code>unsigned long long</code>，而 <code>p</code> 的最高位是1，编译器认为这是负数，所以编译器就启动了 <code>Sign Extension</code>，将高32bit全部设置成1，这样最终你看到的高32bit就是全F了。</p>

<p>所以当做32bit &ndash;> 64bit指针转换的时候，要使用 <code>intptr_t</code> 和 <code>uintptr_t</code>。这样编译器就知道这是指针的转换，高32bit就会是全0了。同样，这也就说明了，为什么 <code>stdint.h</code> 里面要定义这么些个typedef了:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mh">0xc8f68000</span><span class="p">;</span>
</span><span class='line'><span class="n">uint64_t</span> <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">uintptr_t</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>事实上，无论何时都尽量要避免指针和Integer之间的转换，因为Integer是有正负的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RouterOS/远程启动/控制家里的PC]]></title>
    <link href="http://www.markzhang.cn/blog/2014/12/09/ros-rdp-wol/"/>
    <updated>2014-12-09T17:35:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2014/12/09/ros-rdp-wol</id>
    <content type="html"><![CDATA[<h2>远程启动</h2>

<p>远程启动其实就是 <code>WOL(Wake on Lan)</code>，现在的PC机基本上都支持。需要两个东西：</p>

<ul>
<li>在BIOS里面打开 <code>WOL</code></li>
<li>使用一个程序，发送WOL的一个包（所谓magic packet）给PC机</li>
</ul>


<p>先说第一个，在我的PC机上，这个设置是 Advanced Options &ndash;> APM &ndash;> Power on PCIE，设成 <code>Enabled</code> 即可。</p>

<!-- more -->


<p>再说第二个，很酷的是ROS就支持这个，这样你就不需要另外一台PC机常年开着了，ROS路由一直开着即可。在ROS中，打开 <code>New Terminal</code>，输入：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>/tool wol <span class="nv">interface</span><span class="o">=</span>&lt;连着你要唤醒的PC机的那个网口&gt; <span class="nv">mac</span><span class="o">=</span>&lt;要唤醒PC机的网卡的MAC地址&gt;
</span></code></pre></td></tr></table></div></figure>


<p><img src="http://www.markzhang.cn/downloads/image/ros-wol.png" alt="ROS Wake on Lan" /></p>

<p>如果你的路由器不是ROS，或是没有WOL功能的话，那就需要另外一台PC来执行WOL的程序了。在Linux下，可以使用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo apt-get install etherwake
</span><span class='line'>wakeonlan &lt;mac address&gt;
</span></code></pre></td></tr></table></div></figure>


<p>Windows下也一样，下载一个Wake on Lan的程序使用就行了。</p>

<h2>远程控制</h2>

<p>首先就是打开Windows的远程桌面功能。在 <code>高级系统设置 -&gt; 远程</code> 标签页里面：</p>

<p><img src="http://www.markzhang.cn/downloads/image/windows-rdp.png" alt="Windows RDP" /></p>

<p>完了就是在ROS里面打开端口映射，这样你才可以从Internet上远程RDP到家里的PC机，需要映射的是著名的3389端口：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">chain</span><span class="o">=</span>dstnat <span class="nv">action</span><span class="o">=</span>dst-nat to-addresses<span class="o">=</span>&lt;xxx.xxx.xxx.xxx&gt; to-ports<span class="o">=</span>3389 <span class="nv">protocol</span><span class="o">=</span>tcp dst-port<span class="o">=</span>3389
</span><span class='line'><span class="nv">chain</span><span class="o">=</span>dstnat <span class="nv">action</span><span class="o">=</span>dst-nat to-addresses<span class="o">=</span>&lt;xxx.xxx.xxx.xxx&gt; to-ports<span class="o">=</span>3389 <span class="nv">protocol</span><span class="o">=</span>udp dst-port<span class="o">=</span>3389
</span></code></pre></td></tr></table></div></figure>


<p>这样就可以远程登录了。Ubuntu下面有自带的 <code>Remmina Remote Desktop</code> 可以使用，Mac下我用的是 <code>Jump Desktop</code>，个人感觉很好用。</p>

<p>最后一个小问题，有关远程登录机器开始菜单中没有 <code>关机</code> 这个功能，只需要打开 <code>Windows CMD</code>，也就是命令行界面，输入：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>shutdown /f /s
</span></code></pre></td></tr></table></div></figure>


<p>就可以了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Thunderbird 80(72) column - 邮件在80(72)列处line break]]></title>
    <link href="http://www.markzhang.cn/blog/2014/11/25/thunderbird-72-column/"/>
    <updated>2014-11-25T11:13:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2014/11/25/thunderbird-72-column</id>
    <content type="html"><![CDATA[<p>这个需求做linux kernel upstream的人都懂的&hellip;&hellip;要设置Thunderbird在80列正确换行，只需要这样：</p>

<!-- more -->


<ul>
<li><p>Thunderbird如果撰写的邮件是plain text格式（在这里设置：Edit &ndash;> Account Settings &ndash;> Composition &amp; Addressing, you should uncheck Compose in HTML format for all accounts），那么自动就会在72列处做line wrap。但是需要注意的是，这里的line wrap只是在display邮件内容和撰写邮件时，你可以看到。当你发出邮件的时候，这个line wrap就没有了，换句话说，别人看到的你的邮件内容，还是很长的一行行的文字。所以需要下面一步。</p></li>
<li><p>以下内容来自：</p></li>
</ul>


<p><a href="http://arapulido.com/2009/12/01/enabling-line-wrapping-in-thunderbird/#comment-807">http://arapulido.com/2009/12/01/enabling-line-wrapping-in-thunderbird/#comment-807</a></p>

<p>下文中提到的option设置在：Edit &ndash;> Preferences &ndash;> Advanced (General tab) &ndash;> Configure Editor：</p>

<blockquote><p>I am a happy user of the daily build of Thunderbird 3. Although it is still under development, is the best email client for Linux I’ve tried so far, at least, the one that better works for me. Email search &amp; filtering is fast and reliable.</p>

<p>The only thing I don’t like is that wrapping your emails to 72 characters when sending plain text is not straightforward. Once you have selected to send your emails as plain text and have set the line wrap option to 72, there is still one more option to tweak.</p>

<p>Thunderbird has a “feature” that sends by default all plain text with the option format=flowed, which unwraps the email in the client receiver. To turn this feature off, you have to toggle one of the options in the chrome editor:</p>

<p>To disable flowed paragraphs, enforcing line breaks as formatted in the message, set the preference:</p>

<p>mailnews.display.disable_format_flowed_support true
(<a href="http://kb.mozillazine.org/Mail_content_types#Plain_text">http://kb.mozillazine.org/Mail_content_types#Plain_text</a>)</p>

<p>To disable paragraph flow when you send plain text messages, and in the plain text part of multipart messages, set the preference:</p>

<p>mailnews.send_plaintext_flowed false
(<a href="http://kb.mozillazine.org/Mail_content_types#Disabling_paragraph_flow">http://kb.mozillazine.org/Mail_content_types#Disabling_paragraph_flow</a>)</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ChromeOS配置SSH Server]]></title>
    <link href="http://www.markzhang.cn/blog/2014/10/17/chromeos-enable-ssh-server/"/>
    <updated>2014-10-17T12:52:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2014/10/17/chromeos-enable-ssh-server</id>
    <content type="html"><![CDATA[<p>ChromeOS是一个相当&#8221;Linux&#8221;的OS。现在一般能拿到手的ChromeOS的设备很多都是Chromebook，所以本文是在一台Chromebook上做的测试。</p>

<p>ChromeOS默认的零售版本是什么开发类工具都没有的，包括ssh client都没有。要enable SSH client/server，首先要将ChromeOS切换到 <code>Developer Mode</code>。在我手上的这台Chromebook上，做法很简单，就是三键同按开机即可（ESC + Refresh + Power）。</p>

<p>具体的切换到 <code>Developer Mode</code> 的做法可以参考Google的ChromeOS网站上的文章。接下来来看怎么enable SSH Server。</p>

<!-- more -->


<p>以下内容完全参考了文章：</p>

<p><a href="http://www.de7ec7ed.com/2013/05/ssh-daemon-samsung-chromebook-exynos.html">http://www.de7ec7ed.com/2013/05/ssh-daemon-samsung-chromebook-exynos.html</a></p>

<p>所以在这里基本上是做一个英翻中的工作。</p>

<ul>
<li><p>首先启动Chrome浏览器，按下 <code>ctrl + alt + t</code>，开启Crosh（浏览器界面的一个Terminal程序）。Crosh也是只有将ChromeOS切换成 <code>Developer Mode</code> 之后才有的。</p></li>
<li><p>输入：<code>shell</code>，得到一个bash，然后输入 <code>sudo -i</code>，就可以得到root权限了。</p></li>
<li><p>mkdir -p /mnt/stateful_partition/etc/ssh</p></li>
<li><p>ssh-keygen -t dsa -f /mnt/stateful_partition/etc/ssh/ssh_host_dsa_key</p></li>
<li><p>ssh-keygen -t rsa -f /mnt/stateful_partition/etc/ssh/ssh_host_rsa_key</p></li>
<li><p>vi /etc/ssh/sshd_config，将 <code>PasswordAuthentication</code> 改成 <code>yes</code>。在这里也可以看到，为什么我们要在/mnt/stateful_partition下面创建etc/ssh目录，并在里面生成keys。就是因为在这个配置文件中指定了ssh key的路径。</p></li>
<li><p>/sbin/iptables -A INPUT -p tcp &mdash;dport 22 -j ACCEPT</p></li>
<li><p>给root用户设置一个密码，输入passwd即可。</p></li>
<li><p>/usr/sbin/sshd，这样SSH server就启动起来了，可以从其他机器登录过来了。</p></li>
</ul>


<p>题外话：如果你是 <code>cd /usr/sbin;./sshd</code>，或者 <code>/usr/sbin</code> 在PATH里面，直接输入 <code>sshd</code> 启动，你会发现sshd无法启动，错误是：</p>

<blockquote><p>sshd re-exec requires execution with an absolute path</p></blockquote>

<p>Stackexchange有这个问题的回答，很有意思，有两点：</p>

<blockquote><p>This is specific to OpenSSH from version 3.9 onwards.</p>

<p>For every new connection, sshd will re-execute itself, to ensure that all execute-time randomisations are re-generated for each new connection. In order for sshd to re-execute itself, it needs to know the full path to itself.</p>

<p>Here&rsquo;s a quote from the release notes for 3.9:</p>

<p>Make sshd(8) re-execute itself on accepting a new connection. This security measure ensures that all execute-time randomisations are reapplied for each connection rather than once, for the master process&#8217; lifetime. This includes mmap and malloc mappings, shared library addressing, shared library mapping order, ProPolice and StackGhost cookies on systems that support such things</p></blockquote>

<p>另外一个说法也有一定道理：</p>

<blockquote><p>This is to prevent someone from injecting a sshd program somewhere in one of the directories in your PATH and you inadvertently executing it.</p></blockquote>

<p>回到SSH server的配置上来，如果想ChromeOS开机的时候启动SSHD，写这样一个脚本放到 <code>/etc/init</code> 目录下面即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>start on started system-services
</span><span class='line'>script
</span><span class='line'>     /sbin/iptables -A INPUT -p tcp --dport 22 -j ACCEPT
</span><span class='line'>     /usr/sbin/sshd
</span><span class='line'>end script
</span></code></pre></td></tr></table></div></figure>


<p>最后，突然想到，要做上面的所有的事情，要求ChromeOS的root partition是可写的，但是默认情况下，ChromeOS的root partition是read-only的。需要修改的话这样做：</p>

<ul>
<li><p>/usr/share/vboot/bin/make_dev_ssd.sh &mdash;remove_rootfs_verification &mdash;partitions 2</p></li>
<li><p>做完上述命令后，需要重启ChromeOS</p></li>
<li><p>重启完成之后，再开启一个Crosh，执行：mount -o rw,remount /，就可以将root partition变成可写的了。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PS3 KillZone 3（杀戮地带3）黑屏死机问题]]></title>
    <link href="http://www.markzhang.cn/blog/2014/09/17/killzone-3-freezing-issue/"/>
    <updated>2014-09-17T10:34:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2014/09/17/killzone-3-freezing-issue</id>
    <content type="html"><![CDATA[<p>PS3上的杀戮地带3，当升级了1.14（最新版本）之后，有一个黑屏死机的问题：</p>

<p><a href="http://community.killzone.com/t5/Killzone-3-PS3/Patch-1-14-freezing-issues/td-p/1351164">http://community.killzone.com/t5/Killzone-3-PS3/Patch-1-14-freezing-issues/td-p/1351164</a></p>

<!-- more -->


<p>最近我也买了一张二手的杀戮地带3，也碰到了这个问题。为此我Google看了好多帖子，基本上这些帖子七嘴八舌的都说这个问题的原因是：</p>

<p><strong> 你的PS3更换过硬盘，而且更换的是一个高速的（比如7200 RPM），大容量的硬盘。</strong></p>

<p>没错，我的PS3的确换过硬盘，因为原装的250G的坏掉了，所以我换了一个500G的7200 RPM的。但是我也不想就因为这个就再换一次硬盘啊，于是我继续Google看看有没有其他的办法，结果是我试了这么几种方法：</p>

<ul>
<li>进入PS3的恢复模式，重建Database</li>
<li>进入PS3的恢复模式，格式化PS3</li>
<li>完全格式化PS3（在PS3的XMB界面下）</li>
</ul>


<p>试验下来，以上三种方法均无效。最后没办法我找来一块以前用过的一块5400转160G的硬盘，换到PS3上，开机：</p>

<ul>
<li>PS3提示系统软件丢失</li>
<li>PS3提示插入一个带有最新firmware的USB key，然后同时按下 <code>start</code> + <code>select</code> 开始重新往硬盘上安装系统软件</li>
<li>于是我去download了一个4.65的firmware，放到U盘的 <code>PS3</code> &ndash;> <code>UPDATE</code> 目录下，就像给PS3升级系统软件一样</li>
<li>PS3会给硬盘重新分区并安装系统软件</li>
</ul>


<p>完成之后，登录PSN，插入杀戮地带3，再升级1.14，果然就好了。。。已无力吐槽，GG的程序员是临时工吧？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RouterOS配置记录（四）：OpenVPN Client]]></title>
    <link href="http://www.markzhang.cn/blog/2014/09/01/ros-openvpn/"/>
    <updated>2014-09-01T15:42:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2014/09/01/ros-openvpn</id>
    <content type="html"><![CDATA[<p>OpenVPN是现在使用相当广泛的一种VPN solution。它不使用特定协议（比如PPTP依赖于GRE协议，如果GRE协议被墙，PPTP就完了），也不使用特定端口，TCP/UDP都支持，性能表现也相当优异（UDP）。所以现在使用OpenVPN作为VPN的solution很多，在Mikrotik的论坛上可以找到大量赞美OpenVPN的帖子。</p>

<p>但是，事实上当我把OpenVPN全部配置完成之后，发现两个问题：</p>

<!-- more -->


<ul>
<li>OpenVPN已被墙，应该就是2013年（或者更早）的事情。虽然上面提到了OpenVPN不使用特定协议，不使用特定端口，但是聪明的GFW还是找到了OpenVPN TLS验证时的特征并墙之。所以如果你辛辛苦苦配置好了服务器端和客户端，客户端拨号的时候发现：&#8221;Peer disconnected/Connection reset&#8221;，那就是被墙的标志。OpenVPN TLS验证的时候，连接直接被reset了。</li>
</ul>


<p>针对这个问题，当然也有解决方案，那就是模糊TLS验证的数据，让GFW寻不到TLS的特征，比如：</p>

<p><a href="http://igfw.net/archives/13018">http://igfw.net/archives/13018</a></p>

<p>但是这种做法是没法在ROS上实现的。因为这要求修改OpenVPN sever和client的代码，而我们是无法修改ROS中的OpenVPN的实现的。</p>

<ul>
<li>ROS不支持UDP模式的OpenVPN。这个已经被广大ROS用户诟病已久，但不知道为什么Mikrotik就是不改：</li>
</ul>


<p><a href="http://forum.mikrotik.com/viewtopic.php?f=1&amp;t=26499">http://forum.mikrotik.com/viewtopic.php?f=1&amp;t=26499</a></p>

<p>TCP模式的OpenVPN延迟（latency）很高，不适合诸如电话会议、在线游戏等场景。</p>

<p>所以坦白说，有上述的两个问题，ROS+OpenVPN，已经没有太多的使用价值了。但是既然我已经将其配置完成了，所以本文还是将过程记录了下来。</p>

<h2>OpenVPN server侧配置</h2>

<p>OpenVPN server侧的配置稍微复杂一些，关键是要生成一堆证书、秘钥。但是也不是复杂到没法忍，关键是要有一篇好的turtorial。所以这里是我找到的一篇很好的文章，照做就行：</p>

<p><a href="https://www.linode.com/docs/networking/vpn/secure-communications-with-openvpn-on-ubuntu-12-04-precise-and-debian-7">Secure communications with OpenVPN on Ubuntu 12.04</a></p>

<p>照着上面的文章做就可以了，这里再给出我最终的OpenVPN server的配置文件作为一个参考：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>port 3389
</span><span class='line'>proto tcp
</span><span class='line'>dev tun
</span><span class='line'>
</span><span class='line'><span class="c">#Keys</span>
</span><span class='line'>ca /etc/openvpn/easy-rsa/2.0/keys/ca.crt
</span><span class='line'>cert /etc/openvpn/easy-rsa/2.0/keys/server.crt
</span><span class='line'>key /etc/openvpn/easy-rsa/2.0/keys/server.key
</span><span class='line'>dh /etc/openvpn/easy-rsa/2.0/keys/dh1024.pem
</span><span class='line'>
</span><span class='line'><span class="c"># This will be the internal tun0 connection IP</span>
</span><span class='line'>server 10.8.0.0 255.255.255.0
</span><span class='line'>ifconfig-pool-persist ipp.txt
</span><span class='line'>
</span><span class='line'><span class="c"># This will send all of a client&#39;s 10.x.x.x traffic through the VPN</span>
</span><span class='line'><span class="c"># push &quot;route 10.0.0.0 255.0.0.0&quot;</span>
</span><span class='line'>keepalive 10 120
</span><span class='line'>
</span><span class='line'><span class="c"># Mikrotik does not support LZO compression</span>
</span><span class='line'><span class="c">#comp-lzo</span>
</span><span class='line'>
</span><span class='line'>auth SHA1
</span><span class='line'><span class="c"># Select a cryptographic cipher.</span>
</span><span class='line'><span class="c">#cipher BF-CBC        # Blowfish (default)</span>
</span><span class='line'>cipher AES-256-CBC
</span><span class='line'>
</span><span class='line'><span class="c">#user nobody</span>
</span><span class='line'><span class="c">#group nogroup</span>
</span><span class='line'>status /var/log/openvpn/openvpn-status.log
</span><span class='line'>
</span><span class='line'>persist-key
</span><span class='line'>persist-tun
</span><span class='line'>verb 3
</span></code></pre></td></tr></table></div></figure>


<p>几点解释：</p>

<ol>
<li>ROS的OpenVPN client只支持TCP，所以这里使用TCP模式：<code>proto tcp</code>。</li>
<li>被注释的那句：<code>push "route 10.0.0.0 255.0.0.0"</code> 是可以用来给客户端设置路由表的，但是由于我的ROS有chnroutes，所以我会在我的ROS上设置路由表，所以我的OpenVPN server侧就没有push路由表给客户端了。</li>
<li><code>comp-lzo</code> 一定要注释掉，这是因为ROS OpenVPN client不支持这个。所以ROS的OpenVPN UDP不支持，数据压缩又不支持，你就可以想想Mikrotik论坛上大家的怨气有多大了。有空可以上去搜看相关的帖子，相当欢乐。</li>
<li>有关cipher，Blowfish, AES这些ROS OpenVPN client都是支持的，所以可以自由选择。使用默认的Blowfish就挺好。</li>
<li>最后的 <code>verb 3</code> 可以改成诸如 <code>verb 6</code>，这样在 <code>/var/log/syslog</code> 中可以得到很多的log，客户端连不上OpenVPN server的时候，可以帮助调试和定位。</li>
</ol>


<p>配置完成之后，<code>sudo service openvpn restart</code>，OpenVPN server就ready了。</p>

<h2>OpenVPN client侧配置（ROS）</h2>

<p>相比server侧，ROS上client的配置就相对简单了很多。</p>

<p>首先是上传证书和秘钥到ROS上：</p>

<p><img src="http://www.markzhang.cn/downloads/image/ros-system-certificates.png" alt="Certificates" /></p>

<p>这里其实是3个文件，client的公钥和私钥，还有就是server的证书，这三个文件首先upload到ROS上，然后在上图中点击 <code>Import</code> 按钮就可以导入了。</p>

<p>然后就是创建一个OpenVPN的client了：</p>

<p><img src="http://www.markzhang.cn/downloads/image/ros-ppp-openvpn.png" alt="PPP Create OpenVPN Client" /></p>

<p>几点说明：</p>

<ol>
<li><code>Connect To</code> 和 <code>Port</code> 不用说了</li>
<li><code>Mode</code> ，这个有两个选项：<code>IP</code> 和 <code>Ethernet</code>，这表示数据是走layer 3还是layer 2，反映到VPN创建出来的本地虚拟网卡，就是tun还是tap，一般来说OpenVPN都是tun，所以这里是选择 <code>IP</code>。如果你使用PPTP，就可以看到虚拟网卡是tap。</li>
<li><code>User</code>，这个其实不需要，因为OpenVPN是使用证书来识别client的，每个client都会有一个证书。但是这里ROS需要填一个用户名，所以随便填一个就好（貌似OpenVPN也可以支持username/password的那种验证的，我没去调查）。</li>
<li><code>Profile</code>，因为在下面会选择加密方式等，所以profile就选default就好，default意思就是按照server的默认设置来。</li>
<li><code>Certificate</code>，这里要选择你upload到ROS上的，client的私钥，这个私钥是用来解密数据的。</li>
<li><code>Auth</code> / <code>Cipher</code>，这个就选成跟server端的配置一致即可。</li>
</ol>


<h2>结束</h2>

<p>所以总的来说，OpenVPN的配置并不复杂，只是ROS不支持UDP的OpenVPN，所以用来翻墙看看网页还是可以的，玩游戏啥的就要差不少。不过OpenVPN作为一个free的，性能优良的VPN solution，在国内网络中使用也是相当不错的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RouterOS配置记录（三）：DDNS]]></title>
    <link href="http://www.markzhang.cn/blog/2014/08/21/ros-ddns/"/>
    <updated>2014-08-21T15:26:00+08:00</updated>
    <id>http://www.markzhang.cn/blog/2014/08/21/ros-ddns</id>
    <content type="html"><![CDATA[<p>配置动态DNS主要是为了能让你的RouterBoard在Internet上被访问到，这样我就可以远程控制我的RouterBoard，同时也可以开始做端口映射，在内网做server&hellip;等。</p>

<p>在ROS上配置DDNS非常简单，就是写一个script然后放到ROS的 <code>System</code> &ndash;> <code>Scheduler</code> 中就好了。不过在此之前，先去申请一个DDNS，我用的是3322的。</p>

<p>不过在开始之前，你要先确保你的宽带连接拨号之后，得到的是一个真实的IP地址。现在电信/联通/移动宽带有的时候拨号会得到一个假IP地址，比如 <code>192.168.x.x</code>，<code>10.x.x.x</code>，甚至之前我得到过 <code>100.x.x.x</code>，这个也不是真实的IP地址（RFC编号为6598。RFC 6598 &ndash; IANA-Reserved IPv4 Prefix for Shared Address Space）。判断自己拨号得到的IP是否是真实IP很简单，打开 www.ipaddress.com，网站会告诉你你目前的IP地址，把这个IP跟你在ROS里面看到的你拨号得到的IP比较是不是一样就知道了。</p>

<p>如果你得到的不是真实的IP地址，那就说明在运营商那边还有一层NAT，那么你做DDNS就没有用了，除非你用花生壳客户端这种专门的软件，但是花生壳客户端软件是没法装在ROS上的。可以打电话给宽带运营商投诉，让它给你分配真实的IP地址，如果它不从你可以打工信部电话投诉（我没试过，网友们说可以）。</p>

<!-- more -->


<p>所以先来看一下这个script是长什么模样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>:global ednsuser <span class="s2">&quot;xxxxxxxx&quot;</span>
</span><span class='line'>:global ednspass <span class="s2">&quot;xxxxxxxx&quot;</span>
</span><span class='line'>:global ednshost <span class="s2">&quot;xxxxxxxx.3322.org&quot;</span>
</span><span class='line'>:global ednsinterface <span class="s2">&quot;SHUnicom&quot;</span>
</span><span class='line'>:global members <span class="s2">&quot;http://members.3322.net/dyndns/update\?system=dyndns&quot;</span>
</span><span class='line'>:global status
</span><span class='line'>:global status <span class="o">[</span>/interface get <span class="o">[</span>/interface find <span class="nv">name</span><span class="o">=</span><span class="nv">$ednsinterface</span><span class="o">]</span> running<span class="o">]</span>
</span><span class='line'>
</span><span class='line'>:if <span class="o">(</span><span class="nv">$status</span>!<span class="o">=</span><span class="nb">false</span><span class="o">)</span> <span class="k">do</span><span class="o">={</span>
</span><span class='line'>:global ednslastip <span class="o">[</span>:resolve <span class="nv">$ednshost</span><span class="o">]</span>
</span><span class='line'>:if <span class="o">([</span> :typeof <span class="nv">$ednslastip</span> <span class="o">]</span> <span class="o">=</span> nil <span class="o">)</span> <span class="k">do</span><span class="o">={</span> :global ednslastip <span class="s2">&quot;0&quot;</span> <span class="o">}</span>
</span><span class='line'>:global ednsiph <span class="o">[</span> /ip address get <span class="o">[</span>/ip address find <span class="nv">interface</span><span class="o">=</span><span class="nv">$ednsinterface</span> <span class="o">]</span> address <span class="o">]</span>
</span><span class='line'>:global ednsip <span class="o">[</span>:pick <span class="nv">$ednsiph</span> 0 <span class="o">[</span>:find <span class="nv">$ednsiph</span> <span class="s2">&quot;/&quot;</span><span class="o">]]</span>
</span><span class='line'>:global ednsstr <span class="s2">&quot;&amp;hostname=$ednshost&amp;myip=$ednsip&quot;</span>
</span><span class='line'>:if <span class="o">(</span><span class="nv">$ednslastip</span> !<span class="o">=</span> <span class="nv">$ednsip</span><span class="o">)</span> <span class="k">do</span><span class="o">={</span>
</span><span class='line'>/tool fetch <span class="nv">url</span><span class="o">=</span><span class="s2">&quot;$members$ednsstr&quot;</span> <span class="nv">mode</span><span class="o">=</span>http <span class="nv">user</span><span class="o">=</span><span class="nv">$ednsuser</span> <span class="nv">password</span><span class="o">=</span><span class="nv">$ednspass</span> dst-path<span class="o">=</span><span class="nv">$ednshost</span>
</span><span class='line'>:delay 4
</span><span class='line'>:global result <span class="o">[</span>/file get <span class="nv">$ednshost</span> contents<span class="o">]</span>
</span><span class='line'>:log info <span class="o">(</span><span class="nv">$ednshost</span> . <span class="s2">&quot; &quot;</span> .<span class="nv">$result</span><span class="o">)</span>
</span><span class='line'>/file remove <span class="nv">$ednshost</span> ;
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>以上script来自：<a href="http://h2appy.blog.51cto.com/609721/776837">ROS DDNS update script</a></p>

<p>修改一下 <code>ednsuser</code>/<code>ednspass</code>/<code>ednshost</code>就可以使用了。</p>

<p>简单来说这个script就是利用ROS的 <code>/tool fetch</code> 来访问一个网页：</p>

<p><a href="http://members.3322.net/dyndns/update?system=dyndns&amp;hostname=xxx&amp;myip=xxx">http://members.3322.net/dyndns/update?system=dyndns&amp;hostname=xxx&amp;myip=xxx</a></p>

<p>这个方法也是3322官方提供的，3322的server就可以从这个http请求中得到你的真实IP地址了。</p>

<p>然后就是来到ROS的 <code>System</code> &ndash;> <code>Scheduler</code>，点击加号按钮：</p>

<p><img src="http://www.markzhang.cn/downloads/image/ros-system-scheduler.png" alt="ROS Add scheduler" /></p>

<p>把上面的你修改好的script贴到 <code>OnEvent</code> 那个编辑框里面，设定好名字和Interval就OK了。</p>
]]></content>
  </entry>
  
</feed>
