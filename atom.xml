<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Make Things Cool]]></title>
  <link href="http://markzhang.cn/atom.xml" rel="self"/>
  <link href="http://markzhang.cn/"/>
  <updated>2016-06-09T20:00:10+08:00</updated>
  <id>http://markzhang.cn/</id>
  <author>
    <name><![CDATA[Mark Zhang]]></name>
    <email><![CDATA[super119@139.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[安装Ubuntu/Windows双系统后恢复grub]]></title>
    <link href="http://markzhang.cn/blog/2016/06/09/restore-grub-tutorial/"/>
    <updated>2016-06-09T19:38:00+08:00</updated>
    <id>http://markzhang.cn/blog/2016/06/09/restore-grub-tutorial</id>
    <content type="html"><![CDATA[<p>重装系统这个事情发现每两年就要搞一次，windows经常莫名其妙的就起不来了。。。</p>

<p>而对于安装了双系统的机器来说，重装了windows之后如何恢复grub重新实现双启动就是一个问题。网上的方法很多，但是一直没有总结一套能完全解决问题的步骤。所以这次在重装完windows之后将步骤记录如下。</p>

<!-- more -->


<p>这次我是删掉了原来安装的windows 7，换成了windows 10。话说现在windows 10可以在微软的官方网站下载的到，激活码上某宝花个几十块钱也就轻松搞定了。毫无意外的，windows 10安装完成之后，机器启动就看不到grub了，只能启动到windows。接下来就是恢复grub的步骤了。</p>

<ul>
<li>首先需要一个恢复系统，或者说Live ISO，或者说rescue system，都是一个意思。以前我都是用Ubuntu的安装ISO，这次Google了一下，发现有一个boot repair的系统也不错，是开源项目，在这里：</li>
</ul>


<p><a href="https://sourceforge.net/projects/boot-repair-cd/">https://sourceforge.net/projects/boot-repair-cd/</a></p>

<p>下载这个ISO，然后烧录到U盘上从U盘启动即可。Linux下烧录U盘可以用：<code>Universal USB installer</code>，windows下可以用：<code>UltraISO</code>。<code>Universal USB installer</code> 有针对boot repair的支持，烧录的时候选择boot repair即可。</p>

<ul>
<li>U盘启动之后，就能看到一个图形界面（U盘启动会看到一个普通启动项和一个EFI启动项，如果普通启动项不工作那就选择EFI启动），在这里能看到boot repair提供了一个一键修复的按钮，但是这个一键修复对于我的机器不行，有Error报错：<code>GPT detected. Please create a BIOS-Boot partition......</code>，Google了一下貌似要解决还挺麻烦，所以决定还是手工来做：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo umount /mnt/boot-sav/sd*   <span class="c"># boot-repair会将机器上所有它发现的分区都自动mount起来，所以我们先全部umount，然后我们自己操作</span>
</span><span class='line'>sudo mount /dev/sda2 /mnt  <span class="c"># mount Ubuntu root分区，可以用boot repair自带的GParted工具来查看具体是哪个分区</span>
</span><span class='line'><span class="k">for </span>i in /sys /proc /run /dev; <span class="k">do </span>sudo mount --bind <span class="s2">&quot;$i&quot;</span> <span class="s2">&quot;/mnt$i&quot;</span>; <span class="k">done</span>
</span><span class='line'>sudo chroot /mnt
</span><span class='line'>update-grub
</span><span class='line'>grub-install /dev/sdb  <span class="c"># 按照自己机器的配置，看把grub安装到哪个硬盘上</span>
</span><span class='line'>update-grub
</span><span class='line'>grub-mkconfig -o /boot/grub/grub.cfg
</span><span class='line'><span class="nb">exit</span>
</span><span class='line'>sudo reboot
</span></code></pre></td></tr></table></div></figure>


<p>这样重启就OK了，注意这样做了之后默认是不会出现grub界面的，第一次要在BIOS启动完毕之后，按住 <code>左shift</code> ，然后就能看到grub界面了，做过一次之后以后每次启动都会自动出现grub界面，等待读秒。</p>

<p>还有就是上面有一句：<code>grub-mkconfig</code>，这是一定要做的，否则你在grub的界面中会看不到windows的启动项。<code>grub-mkconfig</code> 会自动分析机器中所有的分区然后给出一个完整的启动列表，非常的好用。</p>

<p>如果担心 <code>grub-mkconfig</code> 会覆盖之前的 <code>/boot/grub/grub.cfg</code>，可以将之前的 <code>grub.cfg</code> 先备份然后再操作。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSTask Tips (swift)]]></title>
    <link href="http://markzhang.cn/blog/2016/04/12/swift-cocoa-nstask/"/>
    <updated>2016-04-12T12:51:00+08:00</updated>
    <id>http://markzhang.cn/blog/2016/04/12/swift-cocoa-nstask</id>
    <content type="html"><![CDATA[<p>NSTask是常用的一个Foundation class，它相当于Linux中的popen，可以用来fork执行一个程序，然后将程序的输入输出重定向。然而我在使用这个class的时候，遇到了一些问题，记录在此。</p>

<!-- more -->


<h2>如何取得程序的输出（比如stdout）</h2>

<p>这个比较容易，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">let</span> <span class="n">task</span> <span class="o">=</span> <span class="n">NSTask</span><span class="o">()</span>
</span><span class='line'><span class="n">task</span><span class="o">.</span><span class="na">launchPath</span> <span class="o">=</span> <span class="n">xxx</span>
</span><span class='line'><span class="n">task</span><span class="o">.</span><span class="na">arguments</span> <span class="o">=</span> <span class="n">xxx</span>
</span><span class='line'>
</span><span class='line'><span class="n">let</span> <span class="n">outPipe</span> <span class="o">=</span> <span class="n">NSPipe</span><span class="o">()</span>
</span><span class='line'><span class="n">task</span><span class="o">.</span><span class="na">standardOutput</span> <span class="o">=</span> <span class="n">outPipe</span>
</span><span class='line'><span class="n">let</span> <span class="n">errPipe</span> <span class="o">=</span> <span class="n">NSPipe</span><span class="o">()</span>
</span><span class='line'><span class="n">task</span><span class="o">.</span><span class="na">standardError</span> <span class="o">=</span> <span class="n">errPipe</span>
</span><span class='line'>
</span><span class='line'><span class="n">outPipe</span><span class="o">.</span><span class="na">fileHandleForReading</span><span class="o">.</span><span class="na">readabilityHandler</span> <span class="o">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="o">(</span><span class="nl">handle:</span> <span class="n">NSFileHandle</span><span class="o">)</span> <span class="n">in</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">data</span> <span class="o">=</span> <span class="n">handle</span><span class="o">.</span><span class="na">readDataOfLength</span><span class="o">(</span><span class="mi">128</span><span class="o">)</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="n">your</span> <span class="n">String</span><span class="o">&gt;.</span><span class="na">appendContentsOf</span><span class="o">(</span><span class="n">String</span><span class="o">(</span><span class="nl">data:</span> <span class="n">data</span><span class="o">,</span> <span class="nl">encoding:</span> <span class="n">NSUTF8StringEncoding</span><span class="o">)!)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">task</span><span class="o">.</span><span class="na">launch</span><span class="o">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>当然你也可以用NSPipe.fileHandleForReading的readToEndOfFile来一次性读出来（等待task执行完毕之后）。</p>

<h2>如何知道程序执行结束</h2>

<p>根据NSTask的manual，有两种方法：</p>

<ul>
<li><p>设置NSTask的terminationHandler</p></li>
<li><p>使用NSNotificationCenter，注册监听消息：NSTaskDidTerminateNotification</p></li>
</ul>


<p>这两种方法都可以，但是有一些区别：</p>

<ul>
<li><p>terminationHandler是在NSTask的线程中被调用的，所以如果我们要在程序执行结束后去update UI，那么在这里做是不行的，运行的时候xcode会告诉你，UI被另外一个background thread修改，会出一个assertion。</p></li>
<li><p>NSTaskDidTerminateNotification就没有上述的问题，因为我们注册的NSTaskDidTerminateNotification的observer就是在程序的主线程（main）被调用的。</p></li>
</ul>


<p>我们可以通过在terminationHandler和NSTaskDidTerminateNotification observer函数中加入这样的代码来看出区别：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">NSLog</span><span class="o">(</span><span class="s">&quot;Current thread is: %@&quot;</span><span class="o">,</span> <span class="n">NSThread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">())</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过打印当前thread的信息，就可以看出terminationHandler是在一条非main的线程中被call的，而notification则不是。</p>

<p>由此可以猜测，NSTask应该是首先create一条thread，然后在这条thread中去执行fork，最后调用类似waitpid这样的函数等待被执行的程序执行完毕，并且同时调用我们注册的terminationHandler。</p>

<p>需要注意的是，注册的notification observer一定要及时的remove（可以在observer function里面去remove），否则一旦你多注册一次，你的observer function就会被多call一次。很显然，notification center是用一张list来记录所有的observer的，当有notification发生时，这个list上所有的observer function都会被call一遍。</p>

<p>此外还有一点：如果我们有设置terminationHandler，那么NSTaskDidTerminateNotification就不会被发送了。</p>

<h2>如何得知程序的return value</h2>

<p>按照NSTask的manual，可以通过读取：terminationStatus来得知。但是我做下来发现这个property读取出来的值不一定正确。</p>

<p>也就是说，terminationStatus和我们手动执行：<code>run xxx program; echo $?</code> 这样出来的结果是不同的。</p>

<p>目前还不知道这个问题的原因和解决方法。</p>

<h2>有关Swift的selector</h2>

<p>在注册notification的时候，需要填写一个名为selector的param，也就是我们的notification observer的function。</p>

<p>在swift 2.1中，这里可以直接写function的名字（作为一个字符串），但是一定要注意和objective-C一样，function name是要带参数的，比如：<code>myNotificationObserverFunction:</code>，最后的冒号就表示这个function有一个参数。</p>

<p>漏写这个冒号就会导致runtime 程序无法找到这个function：unknown selector&hellip;.</p>

<p>在Swift 2.2中，有一个新的语法可以显式的生成一个selector：<code>#selector(function name)</code>，不过貌似目前最新的Xcode还只支持到swift 2.1，所以目前还只能用上面的方法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Top中是如何取到Linux内核中的Hertz的？CPU使用率到底是怎么算出来的？]]></title>
    <link href="http://markzhang.cn/blog/2016/02/15/top-calculation-linux-hz/"/>
    <updated>2016-02-15T10:29:00+08:00</updated>
    <id>http://markzhang.cn/blog/2016/02/15/top-calculation-linux-hz</id>
    <content type="html"><![CDATA[<p>首先来看CPU使用率到底是怎么算出来的。依据的是这个公式：</p>

<!-- more -->




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="o">(</span>process jiffies<span class="o">)</span> * 100.0f / <span class="o">((</span>float<span class="o">)</span>Hertz * <span class="o">(</span>float<span class="o">)</span>et * <span class="o">(</span>Rc.mode_irixps ? 1 : Cpu_tot<span class="o">))</span>;
</span></code></pre></td></tr></table></div></figure>


<p>process jiffies是内核提供的该进程在DeltaT时间内消耗的jiffies。具体是/proc/<pid>/stat文件的第14-17 token。14－17token分别是utime, stime, cutime, cstime。cutime/cstime分别是该进程spawn的子进程在用户态和内核态消耗的jiffies。/proc/<pid>/task目录下有该进程所有线程的数据，也是在stat文件中读取，格式和process的是一样的，因为Linux内核中线程和进程区别不大的。所以 也完全可以将该进程所有线程消耗的jiffies累加起来，从而得到该进程的jiffies。man proc可以看到/proc下所有内容的解释。</p>

<p>注意stat中的jiffies是一个绝对累计值，所以要取两个时间点，算DeltaT中消耗的jiffies。</p>

<p>那 什么是jiffies呢？其实就是Linux内核定义的一个时间单位，值就是1/Hertz。Linux内核中，进程/线程消耗的时间，单位都是这个 jiffies。Linux内核没有开放什么系统调用，让程序可以直接取得这个Hertz，从而算出jiffies，为此，Top自己写了一个函数来算 Hertz这个值（不同的硬件平台，这个Hertz是不一样的。而且这个jiffies就是Linux内核调度进程的时间片大小）。最后会给出这个 Hertz在top中是如何计算出来的函数。</p>

<p>OK，回到上面的公式。et表示流逝的时间，单位是秒。最后一个部分是CPU/core数。</p>

<p>所以，总结来看，CPU使用率其实就是在DeltaT时间内，进程一共消耗了多少jiffies，消耗的越多，自然该进程的CPU使用率就越高了。更抽象一点来说，一个进程在单位时间内，被分配到的时间片越多，那么这个进程的CPU占用率就越高。</p>

<p>最后给出Top中是如何计算这个Hertz的，一般现在这个Hertz都是100，也就是jiffies就代表10ms，这也是linux内核中调度时间片的大小。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cm">/***********************************************************************</span>
</span><span class='line'><span class="cm">* Some values in /proc are expressed in units of 1/HZ seconds, where HZ</span>
</span><span class='line'><span class="cm">* is the kernel clock tick rate. One of these units is called a jiffy.</span>
</span><span class='line'><span class="cm">* The HZ value used in the kernel may vary according to hacker desire.</span>
</span><span class='line'><span class="cm">* According to Linus Torvalds, this is not true. He considers the values</span>
</span><span class='line'><span class="cm">* in /proc as being in architecture-dependant units that have no relation</span>
</span><span class='line'><span class="cm">* to the kernel clock tick rate. Examination of the kernel source code</span>
</span><span class='line'><span class="cm">* reveals that opinion as wishful thinking.</span>
</span><span class='line'><span class="cm">*</span>
</span><span class='line'><span class="cm">* In any case, we need the HZ constant as used in /proc. (the real HZ value</span>
</span><span class='line'><span class="cm">* may differ, but we don&#39;t care) There are several ways we could get HZ:</span>
</span><span class='line'><span class="cm">*</span>
</span><span class='line'><span class="cm">* 1. Include the kernel header file. If it changes, recompile this library.</span>
</span><span class='line'><span class="cm">* 2. Use the sysconf() function. When HZ changes, recompile the C library!</span>
</span><span class='line'><span class="cm">* 3. Ask the kernel. This is obviously correct...</span>
</span><span class='line'><span class="cm">*</span>
</span><span class='line'><span class="cm">* Linus Torvalds won&#39;t let us ask the kernel, because he thinks we should</span>
</span><span class='line'><span class="cm">* not know the HZ value. Oh well, we don&#39;t have to listen to him.</span>
</span><span class='line'><span class="cm">* Someone smuggled out the HZ value. :-)</span>
</span><span class='line'><span class="cm">*</span>
</span><span class='line'><span class="cm">* This code should work fine, even if Linus fixes the kernel to match his</span>
</span><span class='line'><span class="cm">* stated behavior. The code only fails in case of a partial conversion.</span>
</span><span class='line'><span class="cm">*</span>
</span><span class='line'><span class="cm">* Recent update: on some architectures, the 2.4 kernel provides an</span>
</span><span class='line'><span class="cm">* ELF note to indicate HZ. This may be for ARM or user-mode Linux</span>
</span><span class='line'><span class="cm">* support. This ought to be investigated. Note that sysconf() is still</span>
</span><span class='line'><span class="cm">* unreliable, because it doesn&#39;t return an error code when it is</span>
</span><span class='line'><span class="cm">* used with a kernel that doesn&#39;t support the ELF note. On some other</span>
</span><span class='line'><span class="cm">* architectures there may be a system call or sysctl() that will work.</span>
</span><span class='line'><span class="cm">*/</span>
</span><span class='line'><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">Hertz</span><span class="p">;</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="n">old_Hertz_hack</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">user_j</span><span class="p">,</span> <span class="n">nice_j</span><span class="p">,</span> <span class="n">sys_j</span><span class="p">,</span> <span class="n">other_j</span><span class="p">;</span>  <span class="cm">/* jiffies (clock ticks) */</span>
</span><span class='line'>  <span class="kt">double</span> <span class="n">up_1</span><span class="p">,</span> <span class="n">up_2</span><span class="p">,</span> <span class="n">seconds</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">jiffies</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="n">h</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">char</span> <span class="o">*</span><span class="k">restrict</span> <span class="n">savelocale</span><span class="p">;</span>
</span><span class='line'>  <span class="n">savelocale</span> <span class="o">=</span> <span class="n">setlocale</span><span class="p">(</span><span class="n">LC_NUMERIC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>  <span class="n">setlocale</span><span class="p">(</span><span class="n">LC_NUMERIC</span><span class="p">,</span> <span class="s">&quot;C&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">do</span><span class="p">{</span>
</span><span class='line'>    <span class="n">FILE_TO_BUF</span><span class="p">(</span><span class="n">UPTIME_FILE</span><span class="p">,</span><span class="n">uptime_fd</span><span class="p">);</span>  <span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%lf&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">up_1</span><span class="p">);</span>
</span><span class='line'>    <span class="cm">/* uptime(&amp;up_1, NULL); */</span>
</span><span class='line'>    <span class="n">FILE_TO_BUF</span><span class="p">(</span><span class="n">STAT_FILE</span><span class="p">,</span><span class="n">stat_fd</span><span class="p">);</span>
</span><span class='line'>    <span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;cpu %Lu %Lu %Lu %Lu&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">user_j</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nice_j</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sys_j</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">other_j</span><span class="p">);</span>
</span><span class='line'>    <span class="n">FILE_TO_BUF</span><span class="p">(</span><span class="n">UPTIME_FILE</span><span class="p">,</span><span class="n">uptime_fd</span><span class="p">);</span>  <span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%lf&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">up_2</span><span class="p">);</span>
</span><span class='line'>    <span class="cm">/* uptime(&amp;up_2, NULL); */</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">while</span><span class="p">((</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)(</span> <span class="p">(</span><span class="n">up_2</span><span class="o">-</span><span class="n">up_1</span><span class="p">)</span><span class="o">*</span><span class="mf">1000.0</span><span class="o">/</span><span class="n">up_1</span> <span class="p">));</span> <span class="cm">/* want under 0.1% error */</span>
</span><span class='line'>  <span class="n">setlocale</span><span class="p">(</span><span class="n">LC_NUMERIC</span><span class="p">,</span> <span class="n">savelocale</span><span class="p">);</span>
</span><span class='line'>  <span class="n">jiffies</span> <span class="o">=</span> <span class="n">user_j</span> <span class="o">+</span> <span class="n">nice_j</span> <span class="o">+</span> <span class="n">sys_j</span> <span class="o">+</span> <span class="n">other_j</span><span class="p">;</span>
</span><span class='line'>  <span class="n">seconds</span> <span class="o">=</span> <span class="p">(</span><span class="n">up_1</span> <span class="o">+</span> <span class="n">up_2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>  <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)(</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">jiffies</span><span class="o">/</span><span class="n">seconds</span><span class="o">/</span><span class="n">smp_num_cpus</span> <span class="p">);</span>
</span><span class='line'>  <span class="cm">/* actual values used by 2.4 kernels: 32 64 100 128 1000 1024 1200 */</span>
</span><span class='line'>  <span class="k">switch</span><span class="p">(</span><span class="n">h</span><span class="p">){</span>
</span><span class='line'>  <span class="k">case</span>    <span class="mi">9</span> <span class="p">...</span>   <span class="mi">11</span> <span class="o">:</span>  <span class="n">Hertz</span> <span class="o">=</span>   <span class="mi">10</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span> <span class="cm">/* S/390 (sometimes) */</span>
</span><span class='line'>  <span class="k">case</span>   <span class="mi">18</span> <span class="p">...</span>   <span class="mi">22</span> <span class="o">:</span>  <span class="n">Hertz</span> <span class="o">=</span>   <span class="mi">20</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span> <span class="cm">/* user-mode Linux */</span>
</span><span class='line'>  <span class="k">case</span>   <span class="mi">30</span> <span class="p">...</span>   <span class="mi">34</span> <span class="o">:</span>  <span class="n">Hertz</span> <span class="o">=</span>   <span class="mi">32</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span> <span class="cm">/* ia64 emulator */</span>
</span><span class='line'>  <span class="k">case</span>   <span class="mi">48</span> <span class="p">...</span>   <span class="mi">52</span> <span class="o">:</span>  <span class="n">Hertz</span> <span class="o">=</span>   <span class="mi">50</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</span><span class='line'>  <span class="k">case</span>   <span class="mi">58</span> <span class="p">...</span>   <span class="mi">61</span> <span class="o">:</span>  <span class="n">Hertz</span> <span class="o">=</span>   <span class="mi">60</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</span><span class='line'>  <span class="k">case</span>   <span class="mi">62</span> <span class="p">...</span>   <span class="mi">65</span> <span class="o">:</span>  <span class="n">Hertz</span> <span class="o">=</span>   <span class="mi">64</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span> <span class="cm">/* StrongARM /Shark */</span>
</span><span class='line'>  <span class="k">case</span>   <span class="mi">95</span> <span class="p">...</span>  <span class="mi">105</span> <span class="o">:</span>  <span class="n">Hertz</span> <span class="o">=</span>  <span class="mi">100</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span> <span class="cm">/* normal Linux */</span>
</span><span class='line'>  <span class="k">case</span>  <span class="mi">124</span> <span class="p">...</span>  <span class="mi">132</span> <span class="o">:</span>  <span class="n">Hertz</span> <span class="o">=</span>  <span class="mi">128</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span> <span class="cm">/* MIPS, ARM */</span>
</span><span class='line'>  <span class="k">case</span>  <span class="mi">195</span> <span class="p">...</span>  <span class="mi">204</span> <span class="o">:</span>  <span class="n">Hertz</span> <span class="o">=</span>  <span class="mi">200</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span> <span class="cm">/* normal &lt;&lt; 1 */</span>
</span><span class='line'>  <span class="k">case</span>  <span class="mi">253</span> <span class="p">...</span>  <span class="mi">260</span> <span class="o">:</span>  <span class="n">Hertz</span> <span class="o">=</span>  <span class="mi">256</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</span><span class='line'>  <span class="k">case</span>  <span class="mi">393</span> <span class="p">...</span>  <span class="mi">408</span> <span class="o">:</span>  <span class="n">Hertz</span> <span class="o">=</span>  <span class="mi">400</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span> <span class="cm">/* normal &lt;&lt; 2 */</span>
</span><span class='line'>  <span class="k">case</span>  <span class="mi">790</span> <span class="p">...</span>  <span class="mi">808</span> <span class="o">:</span>  <span class="n">Hertz</span> <span class="o">=</span>  <span class="mi">800</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span> <span class="cm">/* normal &lt;&lt; 3 */</span>
</span><span class='line'>  <span class="k">case</span>  <span class="mi">990</span> <span class="p">...</span> <span class="mi">1010</span> <span class="o">:</span>  <span class="n">Hertz</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span> <span class="cm">/* ARM */</span>
</span><span class='line'>  <span class="k">case</span> <span class="mi">1015</span> <span class="p">...</span> <span class="mi">1035</span> <span class="o">:</span>  <span class="n">Hertz</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span> <span class="cm">/* Alpha, ia64 */</span>
</span><span class='line'>  <span class="k">case</span> <span class="mi">1180</span> <span class="p">...</span> <span class="mi">1220</span> <span class="o">:</span>  <span class="n">Hertz</span> <span class="o">=</span> <span class="mi">1200</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span> <span class="cm">/* Alpha */</span>
</span><span class='line'>  <span class="k">default</span><span class="o">:</span>
</span><span class='line'><span class="cp">#ifdef HZ</span>
</span><span class='line'>    <span class="n">Hertz</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">HZ</span><span class="p">;</span>    <span class="cm">/* &lt;asm/param.h&gt; */</span>
</span><span class='line'><span class="cp">#else</span>
</span><span class='line'>    <span class="cm">/* If 32-bit or big-endian (not Alpha or ia64), assume HZ is 100. */</span>
</span><span class='line'>    <span class="n">Hertz</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="o">==</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">||</span> <span class="n">htons</span><span class="p">(</span><span class="mi">999</span><span class="p">)</span><span class="o">==</span><span class="mi">999</span><span class="p">)</span> <span class="o">?</span> <span class="mi">100UL</span> <span class="o">:</span> <span class="mi">1024UL</span><span class="p">;</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'>    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Unknown HZ value! (%d) Assume %Ld.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">Hertz</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>代码很简单，其实就是计算单位1秒内，每CPU/core产生了多少了jiffies。这个方法就和具体的硬件平台没有关系了。所以这是一个取得Linux内核Hertz的好方法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fortran77如何调用C代码]]></title>
    <link href="http://markzhang.cn/blog/2016/01/20/fortran77-call-c/"/>
    <updated>2016-01-20T15:37:00+08:00</updated>
    <id>http://markzhang.cn/blog/2016/01/20/fortran77-call-c</id>
    <content type="html"><![CDATA[<p>比如C的代码（文件名：test.c）如下（注意C源代码里不能有main函数，编译时也一定要加-c开关）：</p>

<!-- more -->




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#define sub1 sub1_</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">sub1</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">num</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">num</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Fortran的代码（文件名：testf.f）如下（Fortran调用C的sub1函数）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>  program main
</span><span class='line'>  implicit none
</span><span class='line'>
</span><span class='line'>  integer a
</span><span class='line'>  <span class="nv">a</span> <span class="o">=</span> 10
</span><span class='line'>
</span><span class='line'>  call sub1<span class="o">(</span>a<span class="o">)</span>
</span><span class='line'>
</span><span class='line'>  end
</span></code></pre></td></tr></table></div></figure>


<p>这样就OK 了！编译的时候，这样操作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>g77 -c testf.f -o testf.o
</span><span class='line'>gcc -c test.c -o test.o
</span><span class='line'>g77 test.o testf.o -o <span class="nb">test</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后运行test程序就可以了。</p>

<p>相关说明：</p>

<ol>
<li><p>C代码被编译后会在函数名前面或后面加上下划线，各编译器实现不同，这段代码是在gcc和intel的编译器上测试的，所以，在C的代码里要做一个define的动作</p></li>
<li><p>Fortran默认的函数参数传递方式是传址操作，所以，被调用的C函数的参数必须都是指针</p></li>
<li><p>在Fortran90里，Fortran和C的函数互调基本上没有上述的限制</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mpirun的p4pg参数的用法示例]]></title>
    <link href="http://markzhang.cn/blog/2016/01/20/mpirun-p4pg/"/>
    <updated>2016-01-20T15:34:00+08:00</updated>
    <id>http://markzhang.cn/blog/2016/01/20/mpirun-p4pg</id>
    <content type="html"><![CDATA[<p>./MPI程序名 -p4pg 文件名 [MPI程序参数]</p>

<p>这种方式可以精确控制在每台结点机上启动的MPI 进程数与进程序号，并且允许在不同结点机上启动不同的可执行文件(适用于Master/Slave 模式的并行程序)。文件文件名中按下列格式列出各结点机上启动的程序名:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>结点机名1 0 可执行文件名1
</span><span class='line'>结点机名2 1 可执行文件名2
</span><span class='line'>结点机名3 1 可执行文件名3
</span><span class='line'>... ...
</span><span class='line'>结点机名n 1 可执行文件名n
</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<p>其中结点机名1 必须是运行该命令时所在的结点机, 可执行文件名1 必须与命令行上的MPI程序名为同一文件。所有可执行文件名必须使用绝对路径(如/home/zlb/test/cpi)。通常情况下，所有可执行文件名是一样的。而当同一结点机名出现多次时表示在该结点机上启动多个进程。</p>

<p>例如，假设用户在结点机node1 的 /home/zlb/test 目录下，该目录中有已经编译好的MPI程序cpi。在该目录下创建一个名为p4file 的文件，它包含如下内容:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>node1 0 /home/zlb/test/cpi
</span><span class='line'>node2 1 /home/zlb/test/cpi
</span><span class='line'>node1 1 /home/zlb/test/cpi
</span><span class='line'>node2 1 /home/zlb/test/cpi
</span></code></pre></td></tr></table></div></figure>


<p>则命令 <code>./cpi -p4pg p4file</code> 将在node1, node2 上运行四个进程, 其中进程0 和进程2 在node1上, 进程1 和进程3 在node2 上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fortran90 代码书写注意点]]></title>
    <link href="http://markzhang.cn/blog/2016/01/20/fortran-90-code-tips/"/>
    <updated>2016-01-20T15:28:00+08:00</updated>
    <id>http://markzhang.cn/blog/2016/01/20/fortran-90-code-tips</id>
    <content type="html"><![CDATA[<p>if语句后面的条件表达式一定要用（）括 起来，如</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">if</span> <span class="p">(</span> <span class="n">salary</span> <span class="o">&lt;</span> <span class="mi">1000</span> <span class="p">)</span> <span class="n">then</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">salary</span> <span class="o">&gt;=</span> <span class="mi">1000</span><span class="p">)</span> <span class="p">.</span><span class="n">AND</span><span class="p">.</span> <span class="p">(</span> <span class="n">salary</span> <span class="o">&lt;=</span> <span class="mi">5000</span><span class="p">)</span> <span class="p">)</span> <span class="n">then</span>
</span></code></pre></td></tr></table></div></figure>


<p>没有括号的话编译会产生错误</p>

<!-- more -->


<hr />

<p>if－else if从句不用end if语句。也就是说，虽然 <code>if－else if</code> 这个从句中含有两个if判断，但在最后条件判断结束后，只需要写一个 <code>end if</code> 就OK了，不用写多个，如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">if</span> <span class="p">(</span> <span class="n">salary</span> <span class="o">&lt;</span> <span class="mi">1000</span> <span class="p">)</span> <span class="n">then</span>
</span><span class='line'><span class="o">!</span> <span class="k">do</span> <span class="n">something</span>
</span><span class='line'><span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">salary</span> <span class="o">&gt;</span> <span class="mi">5000</span><span class="p">)</span> <span class="n">then</span>
</span><span class='line'><span class="o">!</span> <span class="k">do</span> <span class="n">something</span>
</span><span class='line'><span class="n">end</span> <span class="k">if</span>
</span></code></pre></td></tr></table></div></figure>


<hr />

<p>如果if语句后只有一句代码，那么要注意then和end if都应该省略不写，如 <code>if (salary &lt; 1000) exit !</code> 没有then和end if，如果exit写在下一行，那么就应该写上then和end if</p>

<hr />

<p>DO循环中：<code>do counter=1, 10, 1</code> 需要注意的是这里的第二个参数不要写成counter&lt;=10</p>

<p>Fortran中自动会添加counter&lt;=这样的描述</p>

<p>如果要实现递减的循环，可以将递变参数改成负数</p>

<hr />

<p>Fortran中使用write可以控制格式化的输出，如write(*, 10)表示取行号为10行的FORMAT语句中的格式化，但一般来说，我们会写在write语句中，这样可读性好，此时的write应该这样写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span> <span class="s">&quot;(&#39;Hello World! This is &#39;, I2, &#39; Processes!&#39;)&quot;</span><span class="p">)</span> <span class="n">process_number</span>
</span></code></pre></td></tr></table></div></figure>


<p>也就是说，首先要用&#8221;( )&ldquo;将格式化字符串包起来，然后在中间，常量字符串用单引号包住，格式控制代码使用,号分割开</p>

<hr />

<p>Fortran中非常容易混淆的两个元素是“字符串”和“字符数组”！这样声明的是一个字符串：</p>

<p>character(len=20) string</p>

<p>而这样声明的，就是一个字符数组：</p>

<p>character :: string(20)</p>

<p>对于字符串，是不可以通过string(i)这样来引用元素的，因为这是数组的做法，对于字符串来说，</p>

<p>要想取得其中的一个或部分元素，需要使用string(i:i)或string(i:i+4)这样的代码</p>

<p>对于数组来说，上面的方法一样可以用，另外，还可以通过string(i)这样的方法来直接引用其中的元素</p>

<hr />

<p>Fortran的所有变量声明都必须放在代码的一开始，不可以在某句代码之后又出现变量的定义，这和C是相同的。但对于C来说，gcc编译器在这一点上做的比较好，gcc编译器允许c代码的变量随处定义，并且允许使用//而不是/<em> </em>/来注释一行。注释使用！符号</p>

<hr />

<p>一行写不完的代码，在行末加上 &amp;，表示下一行和本行是一行代码；也可以在某行的开头使用 &amp;，表示，本行和上一行是一行代码</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[链接装载和库读书笔记 - 未初始化的全局变量是弱符号]]></title>
    <link href="http://markzhang.cn/blog/2016/01/12/uninitialized-global-variable/"/>
    <updated>2016-01-12T09:43:00+08:00</updated>
    <id>http://markzhang.cn/blog/2016/01/12/uninitialized-global-variable</id>
    <content type="html"><![CDATA[<p>代码见文章末尾。</p>

<p>a是未初始化的全局变量，编译成.o的时候不会被放入.bss段，是一个弱符号。当有2个或多个弱符号的时候，linkder会挑选占用空间最大的弱符号。所以，这里最后链接完成后，a占用8个字节。但是在a.c中，a的类型仍然是int，在b.c中，a的类型是double。只是占用空间是8个字节。</p>

<!-- more -->


<p>至于输出结果，由于b.c给a赋值了300，而且b.c中a是double类型，所以内存中a是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="o">(</span>gdb<span class="o">)</span> x/1xg 0x601030
</span><span class='line'>0x601030 &lt;a&gt;:    0x4072c00000000000
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>这就是为什么最后在a.c中打印a，出来的值是0。</p>

<p>更多解释看链接装载和库的P111 &mdash; common块。</p>

<p>BTW：如果两个a都是初始化了的全局变量，则链接会失败，因为两个强符号无法共存。如果一个初始化一个不初始化，则一个强符号一个弱符号，则以强符号占用的空间为准。</p>

<p>测试代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">super</span><span class="err">@</span><span class="n">super</span><span class="o">-</span><span class="nl">desktop:</span><span class="o">~</span><span class="err">$</span> <span class="n">cat</span> <span class="n">a</span><span class="p">.</span><span class="n">c</span>
</span><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="cp">#include &quot;b.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">a</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span><span class='line'>    <span class="n">b_process</span><span class="p">();</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;A in main is: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">super</span><span class="err">@</span><span class="n">super</span><span class="o">-</span><span class="nl">desktop:</span><span class="o">~</span><span class="err">$</span> <span class="n">cat</span> <span class="n">b</span><span class="p">.</span><span class="n">c</span>
</span><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">double</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">b_process</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">a</span> <span class="o">=</span> <span class="mi">300</span><span class="p">;</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;A in b is: %f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">super</span><span class="err">@</span><span class="n">super</span><span class="o">-</span><span class="nl">desktop:</span><span class="o">~</span><span class="err">$</span> <span class="n">cat</span> <span class="n">b</span><span class="p">.</span><span class="n">h</span>
</span><span class='line'><span class="cp">#ifndef _B_H</span>
</span><span class='line'><span class="cp">#define _B_H</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">b_process</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出是：</p>

<p>A in b is: 300.000000</p>

<p>A in main is: 0</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[链接装载和库读书笔记 - 在动态库中尽量少使用全局变量，要使用请加上static]]></title>
    <link href="http://markzhang.cn/blog/2016/01/12/global-variable-in-shared-lib/"/>
    <updated>2016-01-12T09:39:00+08:00</updated>
    <id>http://markzhang.cn/blog/2016/01/12/global-variable-in-shared-lib</id>
    <content type="html"><![CDATA[<p>动态共享库编译的时候，对于全局变量，一律视为模块间变量访问。变量会通过数据段的GOT表来访问。而且，当可执行文件中（由于可执行文件不是PIC的）有同名全局变量时，共享库中定义的变量会被ignore，进程中只会存在可执行程序中的super_a。</p>

<!-- more -->


<p>所以，编写动态库的时候，尽量少用全局变量，如果要用，请加上static，这样就不会有问题。</p>

<p>参考链接装载和库的P198 &mdash; 共享模块的全局变量问题。</p>

<p>BTW：如果是静态链接，链接会失败报错 &mdash; multiple definition of super_a。</p>

<p>以下是测试代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">super</span><span class="err">@</span><span class="n">super</span><span class="o">-</span><span class="nl">desktop:</span><span class="o">~</span><span class="err">$</span> <span class="n">cat</span> <span class="n">lib</span><span class="p">.</span><span class="n">h</span>
</span><span class='line'><span class="cp">#ifndef _LIB_H</span>
</span><span class='line'><span class="cp">#define _LIB_H</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">lib_func</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'><span class="n">super</span><span class="err">@</span><span class="n">super</span><span class="o">-</span><span class="nl">desktop:</span><span class="o">~</span><span class="err">$</span> <span class="n">cat</span> <span class="n">lib</span><span class="p">.</span><span class="n">c</span>
</span><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">super_a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">lib_func</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;A is: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">super_a</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">super</span><span class="err">@</span><span class="n">super</span><span class="o">-</span><span class="nl">desktop:</span><span class="o">~</span><span class="err">$</span> <span class="n">cat</span> <span class="n">main</span><span class="p">.</span><span class="n">c</span>
</span><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="cp">#include &quot;lib.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">super_a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">super_a</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span><span class='line'>    <span class="n">lib_func</span><span class="p">();</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;A in main is: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">super_a</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>super@super-desktop:~<span class="nv">$ </span>gcc -shared -fPIC -g -o liblib.so lib.c
</span><span class='line'>super@super-desktop:~<span class="nv">$ </span>gcc -o main main.c -L. -llib
</span><span class='line'>super@super-desktop:~<span class="nv">$ </span>./main
</span><span class='line'>A is: 100
</span><span class='line'>A in main is: 100
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[并行编程优化Tips]]></title>
    <link href="http://markzhang.cn/blog/2016/01/08/parallel-programming-optimization/"/>
    <updated>2016-01-08T09:56:00+08:00</updated>
    <id>http://markzhang.cn/blog/2016/01/08/parallel-programming-optimization</id>
    <content type="html"><![CDATA[<p>编程优化：</p>

<ul>
<li><p>编程优化，比如Fortran二维数组中，要按行存放，按列访问，这样可以让cache工作更高效。</p></li>
<li><p>循环展开，如CPU一拍能做四次浮点运算，那么可以将一个浮点计算循环（计算内容简单的）拆分成每次循环step为4，循环体内手动做四次循环代码。这样代码不好看，但是能得到性能提高。</p></li>
</ul>


<!-- more -->


<ul>
<li><p>运算顺序的调整，减少CPU流水线的迟滞。可以和循环展开配合，得到更好的性能。</p></li>
<li><p>针对Cache的优化。</p>

<ol>
<li><p>数组合并: 利用块长，改善空间局部性</p></li>
<li><p>循环交换: 改变嵌套循环中访问内存的次序</p></li>
<li><p>循环合并: 增强数据的可重用性（时间局部性）</p></li>
<li><p>分块: 集中访问可取入cache的块状矩阵，避免全行或全列的读写，以增强时间局部性。&mdash; 计算一个Cache中能放下的子矩阵。</p></li>
</ol>
</li>
<li><p>做MPI通讯的时候，将小数据量多次通讯变成整合式少次通讯。这样回避网络latency的问题。</p></li>
<li><p>文件I/O要尽量减少，除非是不能回避的。</p></li>
<li><p>考虑OpenMP+MPI的并行编码方式，这样在单机内可以避免使用MPI。</p></li>
</ul>


<p>编译等其他辅助性优化：</p>

<ul>
<li><p>Intel compiler &ndash; 针对硬件架构的优化，比如MMX/SSE等指令集的优化。可以优化一些looper等。Prefetch, loop interchange, cache blocking等。</p></li>
<li><p>使用高效的数学库（BLAS/GOTO等）。</p></li>
<li><p>利用vtunes等类似性能调试软件来调试性能热点。比如vtunes/Intel cluster toolkits可以看出计算/通讯的时间占用比。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为什么包含多句代码的宏要用do while包括起来？]]></title>
    <link href="http://markzhang.cn/blog/2016/01/07/kernel-do-while-macro/"/>
    <updated>2016-01-07T11:05:00+08:00</updated>
    <id>http://markzhang.cn/blog/2016/01/07/kernel-do-while-macro</id>
    <content type="html"><![CDATA[<p>为了看起来更清晰，这里用一个简单点的宏来演示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#define SAFE_DELETE(p) do{ delete p; p = NULL} while(0)</span>
</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<p>假设这里去掉 <code>do...while(0)</code>,</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#define SAFE_DELETE(p) delete p; p = NULL;</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么以下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">p</span><span class="p">)</span> <span class="n">SAFE_DELETE</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</span><span class='line'><span class="k">else</span>   <span class="p">...</span><span class="k">do</span> <span class="n">sth</span><span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>就有两个问题，</p>

<ol>
<li><p>因为if分支后有两个语句，else分支没有对应的if，编译失败</p></li>
<li><p>假设没有else, SAFE_DELETE中的第二个语句无论if测试是否通过，会永远执行。</p></li>
</ol>


<p>你可能发现，为了避免这两个问题，我不一定要用这个令人费解的do&hellip;while,  我直接用{}括起来就可以了</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#define SAFE_DELETE(p) { delete p; p = NULL;}</span>
</span></code></pre></td></tr></table></div></figure>


<p>的确，这样的话上面的问题是不存在了，但是我想对于C++程序员来讲，在每个语句后面加分号是一种约定俗成的习惯，这样的话，以下代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">p</span><span class="p">)</span> <span class="n">SAFE_DELETE</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span><span class='line'><span class="k">else</span>   <span class="p">...</span><span class="k">do</span> <span class="n">sth</span><span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>其else分支就无法通过编译了（原因同上），所以采用 <code>do...while(0)</code> 是做好的选择了。</p>

<p>也许你会说，我们代码的习惯是在每个判断后面加上{}, 就不会有这种问题了，也就不需要do&hellip;while了，如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">if</span><span class="p">(...)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>诚然，这是一个好的，应该提倡的编程习惯，但一般这样的宏都是作为library的一部分出现的，而对于一个library的作者，他所要做的就是让其库具有通用性，强壮性，因此他不能有任何对库的使用者的假设，如其编码规范，技术水平等。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[netstat -na输出中Recv-Q和Send-Q两项的值不为零需要注意程序是否有问题]]></title>
    <link href="http://markzhang.cn/blog/2016/01/07/recv-q-send-q/"/>
    <updated>2016-01-07T10:59:00+08:00</updated>
    <id>http://markzhang.cn/blog/2016/01/07/recv-q-send-q</id>
    <content type="html"><![CDATA[<p>Recv-Q：表示收到的数据中还有多少没有被进程取走（通过recv）</p>

<p>Send-Q：表示需要发送的数据还有多少没有被发出</p>

<p>所以，一般来说这两个值都是0，如果不为0且持续增长，那就表明程序出现了问题。</p>

<p>比如Recv-Q的数字持续增长，表示没有进程去取这些收到的数据。比如使用select+recv来收数据的时候，由于select有1024这个限制，所以如果socket的FD大于1024的时候，就会导致这个socket FD上的数据不会被select检测到从而导致recv不会被调用。</p>

<p>所以，通过netstat的这两个值就可以简单判断程序收不到包到底是包没到还是包没有被进程recv。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kernel suspend的逻辑]]></title>
    <link href="http://markzhang.cn/blog/2016/01/06/kernel-suspend-description/"/>
    <updated>2016-01-06T09:44:00+08:00</updated>
    <id>http://markzhang.cn/blog/2016/01/06/kernel-suspend-description</id>
    <content type="html"><![CDATA[<p>代码位于：power/suspend.c，从函数pm_suspend开始。</p>

<p>suspend的逻辑和driver相关的主要就是遍历所有device，并调用他们相关driver的suspend函数指针（包括该device的class，bus这些的suspend函数指针）。</p>

<!-- more -->


<p>至于device调用的先后次序是这样的：当我们执行device_add的时候，这些device会被加到一个dpm_list的list中，而且晚add的device会出现在list的靠前位置。也就是说，早add的device会晚一点被suspend，最后add的device会第一个被suspend。</p>

<p>resume的时候就正好反过来，最后add的device会第一个被resume。</p>

<p>而具体在suspend一个device的时候，会依次调用这些函数指针：device所属的power domain，device的type，device所属的class，device所属的bus。</p>

<p>在上述的逻辑之前，会有一个名为suspend_prepare的调用，在这里会freeze userspace（不schedule了就OK了），会freeze有freezable属性的workqueue。在上述逻辑之后，kernel就会转到arch层继续做suspend的动作。在这里就是每种arch，每种mach各不相同了。在这里一般就是针对具体的硬件，做state saving，clock gate，power gate，prepare cpu reset handler这样的一些动作了。</p>

<p>上面提到的有Freezable属性的这个workqueue比较实用，在suspend的时候会freeze，这样就会避免当suspend的时候，一些设备被关闭（或者clock被gate，或者power被gate），但是workqueue中还有work在运行从而导致一些问题。</p>

<p>跟了一下代码，这个system_freezable_wq主要就是在create workqueue的时候加上了一个FREEZABLE的flag，然后当suspend发生的时候，在没有开始真正suspend device之前，有一个suspend_prepare会调用suspend_freeze_processes，这样一路调用下来，最终会调用到freeze_workqueues_begin，在这里会将workqueue的maxactive设成0，这样workqueue里面的work就无法执行到了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kernel resume的逻辑]]></title>
    <link href="http://markzhang.cn/blog/2016/01/05/kernel-suspend-resume-description/"/>
    <updated>2016-01-05T15:59:00+08:00</updated>
    <id>http://markzhang.cn/blog/2016/01/05/kernel-suspend-resume-description</id>
    <content type="html"><![CDATA[<p>Resume的时候，其实最开始是从bootrom启动，再到uboot，然后再到kernel，到kernel的common code的时候，arch相关的代码都已经跑完，此时CPU已经起来了（其实CPU起来之后执行的第一句代码位于设定好的CPU reset handler指定地方的代码，一般这是一段汇编，在这里会去读取suspend结束的时候的一些系统状态，从而可以顺利的转到kernel层继续）。</p>

<!-- more -->


<p>所以到了kernel这边的时候，是从suspend结束时的下一条指令开始继续执行。具体就位于suspend.c的suspend_enter的下半部分代码。</p>

<p>在这里就可以看到，比如dpm_resume_noirq就是关键函数。在这里就会依次去调用所有device对应的driver的resume方法，顺序是先suspend的后被resume，后suspend的先resume。</p>

<p>结合之前说的suspend的逻辑，综合一下就是：</p>

<p>device_add的时候：</p>

<p>先被add的device，后被suspend，先被resume</p>

<p>后被add的device，先被suspend，后被resume</p>

<p>不过这不是绝对的，细节一点来说，这里面还分noirq的device resume list和irq enabled device resume list，具体的可以去看源代码。</p>

<p>然后suspend_enter函数就会被执行完成，按照之前suspend时候的调用栈，就会回到函数：suspend_devices_and_enter这个函数中调用suspend_enter的下一句继续执行，在这里又会做一些resume的工作，比如console resume就在这里。</p>

<p>最后就回到了调用suspend_devices_and_enter的函数enter_state，在这里会调用suspend_finish，这个函数里面就会调用到suspend_thaw_processes，这个函数就会thaw workqueues, thaw tasks，然后调用schedule开始进程调度，到这个时候userspace也就活过来了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Cron的一些小Tips]]></title>
    <link href="http://markzhang.cn/blog/2016/01/04/cron-tips/"/>
    <updated>2016-01-04T10:08:00+08:00</updated>
    <id>http://markzhang.cn/blog/2016/01/04/cron-tips</id>
    <content type="html"><![CDATA[<ul>
<li><p>crontab -e编辑定时任务，crontab -l查看。最后的cron任务文件保存在/var/spool/cron/crontab目录下</p></li>
<li><p>cron会切换到/var/spool/cron/crontab目录下cron文件的owner这个用户，然后执行定义的定时任务。</p></li>
<li><p>但是cron切换用户的时候，任何环境变量，包括.bashrc都不会被执行到。所以诸如$HOME这样的变量也是没有定义的。所以，一般在定时任务的脚本中，我们会这样处理：</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#!/bin/bash</span>
</span><span class='line'><span class="nv">HOME</span><span class="o">=</span>/home/markz
</span><span class='line'><span class="nb">source</span> <span class="k">${</span><span class="nv">HOME</span><span class="k">}</span>/.bashrc
</span><span class='line'><span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span>/usr/local/bin:<span class="nv">$PATH</span>
</span><span class='line'>.... &lt;tasks&gt;
</span></code></pre></td></tr></table></div></figure>


<p>有一点注意，~/.bashrc往往都含有大量的定义和脚本执行，这有可能会影响到source的成功执行。我们之所以在需要cron的脚本中加入这句source，大多数情况下是为了定义一些环境变量。所以为了让source能保证成功，一般我们都会把需要的环境变量单独存放到一个文件中，然后去source那个文件即可。直接source ~/.bashrc不是一个好的做法。</p>

<ul>
<li>/var/log/syslog保存了cron的log，查看该log可以方便的知道定时任务执行的一些情况。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Compile: what is softfp & hardfp?]]></title>
    <link href="http://markzhang.cn/blog/2016/01/04/softfp-hardfp/"/>
    <updated>2016-01-04T09:56:00+08:00</updated>
    <id>http://markzhang.cn/blog/2016/01/04/softfp-hardfp</id>
    <content type="html"><![CDATA[<p>hardfp compiles inline FP instructions.  If you have an FPU this will be fastest.  If you don&rsquo;t, every FP instruction will trap to an emulation routine (assuming your runtime supports this).</p>

<!-- more -->


<p>softfp will compile a library call for every FP operation.  Use this if you never run on a system with an FPU.</p>

<p>来自gcc的manual：</p>

<blockquote><p>-mfloat-abi=name       Specifies which floating-point ABI to use.  Permissible values are: soft, softfp and hard.</p>

<p>Specifying soft causes GCC to generate output containing library calls for floating-point operations.  softfp allows the generation of code using hardware floating-point instructions, but still uses the soft-float calling conventions.  hard allows generation of floating-point instructions and uses FPU-specific calling conventions.</p>

<p>The default depends on the specific target configuration.  Note that the hard-float and soft-float ABIs are not link-compatible; you must compile your entire program with the same ABI, and link with a compatible set of libraries.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UTF-8 Encoding rules]]></title>
    <link href="http://markzhang.cn/blog/2016/01/03/utf8-encoding-rules/"/>
    <updated>2016-01-03T11:38:00+08:00</updated>
    <id>http://markzhang.cn/blog/2016/01/03/utf8-encoding-rules</id>
    <content type="html"><![CDATA[<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cm">/* UTF-8 encoding</span>
</span><span class='line'><span class="cm">00000000-01111111  00-7F  US-ASCII (single byte)</span>
</span><span class='line'><span class="cm">10000000-10111111  80-BF  Second, third, or fourth byte of a multi-byte sequence</span>
</span><span class='line'><span class="cm">11000000-11011111  C0-DF  Start of 2-byte sequence</span>
</span><span class='line'><span class="cm">11100000-11101111  E0-EF  Start of 3-byte sequence</span>
</span><span class='line'><span class="cm">11110000-11110100  F0-F4  Start of 4-byte sequence</span>
</span><span class='line'><span class="cm">*/</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为什么linux的TTY登录程序getty/agetty一般都会设置一个-L的option？]]></title>
    <link href="http://markzhang.cn/blog/2016/01/03/getty-l/"/>
    <updated>2016-01-03T11:36:00+08:00</updated>
    <id>http://markzhang.cn/blog/2016/01/03/getty-l</id>
    <content type="html"><![CDATA[<p>-L option表示程序不等待DCD信号。DCD信号是串口通讯时的一个信号，表示Data Carrier Detected，一般是modem连通之后会发送回来的一个信号，表示数据载波OK，可以继续通信了。</p>

<!-- more -->


<p>但是，在现在的串口通信中，特别是嵌入式开发的时候，开发板上的串口，DCD这个pin一般都不会连线的，一般只连tx/rx/cts/rts四根线就OK了。</p>

<p>所以，如果getty或者agetty没有指定-L选项，那么open /dev/ttyS0就会block在那里，因为kernel会wait在一个waitqueue上，等待串口的DCD信号上来（通过中断）。</p>

<p>事实上，在getty/agetty程序中，指定-L option之后，代码中就会以NON_BLOCK的方式来打开/dev/ttyS0，这样kernel就不会去等待DCD信号了，从而打开串口就不会block了。</p>

<p>对于local的开发板上的串口来说，不连DCD线是合理的。因为这是local设备，不是要和远程的一个modem进行通信，所以需要DCD。本地的串口连上述那四根线就OK了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DMABUF/DMA Mapping/IOMMU/CMA/TTM/GEM/GART/SMMU]]></title>
    <link href="http://markzhang.cn/blog/2015/12/30/dmabuf-slash-dma-mapping-slash-iommu-slash-cma-slash-ttm-slash-gem-slash-gart-slash-smmu/"/>
    <updated>2015-12-30T09:24:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/12/30/dmabuf-slash-dma-mapping-slash-iommu-slash-cma-slash-ttm-slash-gem-slash-gart-slash-smmu</id>
    <content type="html"><![CDATA[<ol>
<li><p>DMABUF can be used as a wrapper to encapsulate other memory management frameworks. All these memory management framework(I mean mostly for graphics), buffer is the keypoint. DMABUF defines a standard buffer structure. So DMABUF can be used as a wrapper for TTM/GEM/Android ION&hellip; and etc. Notice DMABUF can&rsquo;t replace these things, cause it doesn&rsquo;t cover everything. E.g: DMABUF has no userspace interfaces, right now only kernel interfaces(can be used in device driver).</p></li>
<li><p>Kernel has DMA mapping API from origin. ARM defines IOMMU which can be used to connect scattered physical memory as a continuous region for devices which needs continue address to work(e.g: DMA). So IOMMU implementations &amp; CMA should work behind kernel DMA mapping API. E.g: dma_alloc_from_contiguous can be implemented by CMA; dma_alloc_coherent can be implemented by IOMMU or by the normal case(just call __get_free_pages). So for device drivers need dma buffers, we should use dma mapping APIs, not call iommu api directly.</p></li>
<li><p>For tegra, GART &amp; SMMU can be used to implement IOMMU apis.</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux graphics stack 理解]]></title>
    <link href="http://markzhang.cn/blog/2015/12/29/linux-graphics-stack/"/>
    <updated>2015-12-29T14:09:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/12/29/linux-graphics-stack</id>
    <content type="html"><![CDATA[<p>Display and mode setting: DRM. DRM defines connector/encoder/crtc to support display(including multi-monitor). And KMS makes mode setting happens in kernel space.</p>

<!-- more -->


<hr />

<p>2D acceleration: X server EXA/UXA extension. Vendor should write a X server driver which implements EXA or UXA(should be upstreamed). UXA is an enhancement design of EXA, proposed by intel, so GEM is used in UXA. DRM has no direct 2D acceleration interface definitions(e.g: memory copy/move, blit, color space conversion&hellip;), this is defined in EXA/UXA extensions. But vendor&rsquo;s X server driver will use drm functions, mostly is buffer manipulations.</p>

<p>3D acceleration: via Mesa. Mesa has 2 parts:</p>

<p>libGL.so &mdash; the implementation of OpenGL spec, the default OpenGL implementation library in Linux. This libGL.so translates OpenGL callings to Mesa-specified instructions.</p>

<p>DRI driver &mdash; the driver accepts the Mesa-specified instructions generated by libGL.so and call drm functions to get them accelerated in GPU. Should be upstreamed.</p>

<p>DRM: has userspace libdrm &amp; kernel space drm driver.</p>

<p>libdrm: Implemented drm APIs. Vendor can hook it&rsquo;s implementations as well as add more APIs which used by EXA/UXA driver(2D) or DRI driver(3D). That&rsquo;s why the build result of libdrm normally has 2 libraries(e.g: libdrm.so &amp; libdrm_intel.so). Vendor codes of libdrm should be upstreamed.</p>

<p>Kernel drm driver: Works under kernel drm framework, should be upstreamed. Cause vendor can add APIs in libdrm, so kernel drm driver can handle vendor specified ioctls.</p>

<p>GLX: X server extension of OpenGL. X server has DRI/DRI2 extensions as well.</p>

<p>They&rsquo;re working with libGL.so in Mesa. By these extensions, Mesa can do:</p>

<ol>
<li><p>Direct rendering: libGL.so in Mesa try to figure out whether DRI driver is ready in Mesa. If so, GLX returns some infos(such as window size, position&hellip;) or create off-screen buffers(via DRI/DRI2 X extension) for Mesa. The rendering is handled in Mesa&rsquo;s DRI driver &mdash; no relations with X server.</p></li>
<li><p>Indirect rendering: libGL.so in Mesa can&rsquo;t find out Mesa&rsquo;s DRI driver. So it queries whether DRI is available in X server. If so, it pass the Mesa-specified instructions which generated by libGL.so to X server. And GLX/DRI/DRI2 extensions of X server handles the rest things. Normally it&rsquo;s software rendering which implemented by Mesa as well. AIGLX(Accelerated Indirect GLX) seems has some solutions to accelerate this.</p></li>
</ol>


<p>So Mesa handles a lot of works in linux 3D graphics stack. And it has lots of relations with X server as well(GLX and DRI X extensions).</p>

<p>An important reason that why we involve so many components is, decouple the dependencies of all of these guys. According to this design, DRM is not related with X server so it works with other programs as well(e.g: Wayland). Mesa is the same.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux通过sendmsg在进程中共享FD]]></title>
    <link href="http://markzhang.cn/blog/2015/12/25/share-fd-by-sendmsg/"/>
    <updated>2015-12-25T10:57:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/12/25/share-fd-by-sendmsg</id>
    <content type="html"><![CDATA[<p>对于现代Linux来说，FD的使用变的越来越广泛。FD不光用于一个文件或设备的打开句柄，现在FD还往往会用于一些其他数据类型的句柄，比如一块buffer。</p>

<p>对于一些要避免拷贝的buffer来说（比如一块用于display的buffer，或者一块用于render的buffer），使用FD来表示这块buffer并在不同进程中传递就被使用的越来越广泛。而且进程退出（不管是正常退出还是被杀）的时候，FD还能被kernel回收，再加上 <code>reference count</code>，这块buffer就不会有泄漏的问题。看看Android和Linux kernel的代码就会发现，现在使用FD的这种例子是越来越多了。</p>

<p>在userspace，进程共享FD可以通过 <code>sendmsg</code> 来实现：</p>

<!-- more -->


<p>man 7 unix</p>

<p>man sendmsg</p>

<p>sendmsg可以发送control message，也就是不是普通的regular数据。看sendmsg的manual可以知道。</p>

<p>control message其实也是指定一个指针和一个长度，和普通数据一样。</p>

<p>有趣的事，control message可以发送一个FD（或一组，以数组方式组织）给另外一个进程。不是说把FD这个数字发给了别人，而是这个FD真正的另外一个进程中存在，而且和发送进程的FD指向的是一个struct file</p>

<p>简单来说，就好象接收进程dup了发送进程的那个FD一样。事实上嘛，大家都懂的，其实就是kernel帮助接收进程dup了一下而已。。。</p>

<p>在man 7 unix中搜索SCM_RIGHTS可以看到具体用法和信息。</p>

<p>有个条件是：必须工作在UNIX这个socket domain上（AF_UNIX），TCP/IP socket domain是不行的。</p>
]]></content>
  </entry>
  
</feed>
