<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Make Things Cool]]></title>
  <link href="http://markzhang.cn/atom.xml" rel="self"/>
  <link href="http://markzhang.cn/"/>
  <updated>2015-12-23T10:32:15+08:00</updated>
  <id>http://markzhang.cn/</id>
  <author>
    <name><![CDATA[Mark Zhang]]></name>
    <email><![CDATA[super119@139.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Kernel barrier/wmb/mb宏的作用]]></title>
    <link href="http://markzhang.cn/blog/2015/12/23/kernel-barrier-mb-wmb/"/>
    <updated>2015-12-23T10:28:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/12/23/kernel-barrier-mb-wmb</id>
    <content type="html"><![CDATA[<p>内存屏障主要解决的问题是编译器的优化和CPU的乱序执行。</p>

<p>编译器在优化的时候，生成的汇编指令可能和c语言程序的执行顺序不一样，在需要程序严格按照c语言顺序执行时，需要显式的告诉编译不需要优化，这在linux下是通过barrier()宏完成的，它依靠volidate关键字和memory关键字，前者告诉编译barrier()周围的指令不要被优化，后者作用是告诉编译器汇编代码会使内存里面的值更改，编译器应使用内存里的新值而非寄存器里保存的老值。</p>

<p>同样，CPU执行会通过乱序以提高性能。汇编里的指令不一定是按照我们看到的顺序执行的。linux中通过mb()系列宏来保证执行的顺序。具体做法是通过mfence/lfence指令（它们是奔4后引进的，早期x86没有）以及x86指令中带有串行特性的指令（这样的指令很多，例如linux中实现时用到的lock指令，I/O指令，操作控制寄存器、系统寄存器、调试寄存器的指令、iret指令等等）。简单的说，如果在程序某处插入了mb()/rmb()/wmb()宏，则宏之前的程序保证比宏之后的程序先执行，从而实现串行化。wmb的实现和barrier()类似，是因为在x86平台上，写内存的操作不会被乱序执行。</p>

<p>实际上在RSIC平台上，这些串行工作都有专门的指令由程序员显式的完成，比如在需要的地方调用串行指令，而不像x86上有这么多隐性的带有串行特性指令（例如lock指令）。所以在risc平台下工作的朋友通常对串行化操作理解的容易些。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux kernel data types, alignment, compat_ioctl 数据类型，对齐问题和compat_ioctl]]></title>
    <link href="http://markzhang.cn/blog/2015/12/23/kernel-data-type-compat-ioctl/"/>
    <updated>2015-12-23T10:21:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/12/23/kernel-data-type-compat-ioctl</id>
    <content type="html"><![CDATA[<p>特别是在写IOCTL的时候，由于有32bit userspace + 64bit kernel的问题，而且由于architecture的不同，不同data type的length也不同，所以在IOCTL中建议用u32, u64, s32这样无视architecture fix size的data type。</p>

<p>这里是来自LDD的不同的architecture的data type的size：</p>

<!-- more -->


<p><img src="http://markzhang.cn/downloads/image/kernel-u32-s32.png" alt="kernel architecture indepedent data types" /></p>

<p>此外有关IOCTL中structure的alignment的问题，注意添加padding使数据长度alignment，现在一般来说都是添加padding到64bit对齐。这里是为什么需要这么做（针对ARM，x86更不用说，因为x86-64早就有了）：</p>

<blockquote><p>Q: I&rsquo;m new in kernel development. Could you tell me or give me some
materials to read that why we need to align the size of IOCTL structures
to 64bit? I can understand if we&rsquo;re working in a 64bit kernel but why we
need to do this if we&rsquo;re in a 32bit arm kernel? Besides, why the
pointers in IOCTL structure should be declared as u64?</p>

<p>A: Because in a few years/months you&rsquo;ll have arm64, but still the same
driver with the same ioctls &hellip; and if the ioctls are not <em>exactly</em>
the same you get to write compat ioctl code which copies the old 32bit
struct into the 64bit struct the kernel understands. Hence your ioctl
must be laid out exactly the same for both 32bit and 64bit, which
happens if you naturally align/pad everything to 64bits and only use
fixed-sized integers and no pointers.</p>

<p>Mark: Ah, I see. Thanks. Yes, u64 still works as 32 bit pointer.</p></blockquote>

<p>参看LDD十一章中有关Nature Alignment的描述。Alignment主要是牵涉到性能问题，不对齐的数据在fetch的时候会有exception，从而降低performance。</p>

<p>这里是网上搜到的一些建议：</p>

<p>There are some rules that should be followed regardless:</p>

<ul>
<li><p>ioctl commands should never be written in an architecture specific
way. In the example of the OMAP driver, you definitely want to be
able ot use the same command when running Linux on the C6x DSP.</p></li>
<li><p>If possible, use only scalar values as ioctl arguments</p></li>
<li><p>Avoid types that are register sized: &lsquo;long&rsquo;, &lsquo;size_t&rsquo;, pointer.
Instead use only <strong>u8, </strong>u16, <strong>u32 and </strong>u64 and their signed
versions.</p></li>
<li><p>If you use structures, try very hard to avoid pointers in them,
it messes up all sorts of tools.</p></li>
<li><p>If you use structures, make all members naturally aligned, and pad
the size of the structures to a multiple of the maximum member size.</p></li>
<li><p>Never put sub-command numbers into a structure.</p></li>
</ul>


<p>有关compat_ioctl：支持64bit的driver必须要实现的ioctl，当有32bit的userspace application call 64bit kernel的IOCTL的时候，这个callback会被调用到。</p>

<p>Q: Suppose I have defined the following.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#define MY_IOCTL_CMD1 _IOR(MAGIC_NUMBER, 0x01, arg1)</span>
</span><span class='line'><span class="cp">#define MY_IOCTL_CMD2 _IOW(MAGIC_NUMBER, 0x02, arg2)</span>
</span><span class='line'><span class="cp">#ifdef CONFIG_COMPAT</span>
</span><span class='line'><span class="cp">#define MY_COMPAT_IOCTL_CMD1 _IOR(MAGIC_NUMBER, 0x01, compat_arg1)</span>
</span><span class='line'><span class="cp">#define MY_COMPAT_IOCTL_CMD2 _IOW(MAGIC_NUMBER, 0x02, compat_arg2)</span>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now when we do ioctl from user space, we usually do</p>

<p>ioctl(fd, MY_IOCTL_CMD1, &amp;arg1)</p>

<p>So do we really need to have an ioctl with MY_COMPAT_IOCTL_CMD1 as request?</p>

<p>In the devide code I have handlers defined as follows. ioctl: device_ioctl</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#ifdef CONFIG_COMPAT</span>
</span><span class='line'><span class="nl">compat_ioctl:</span> <span class="n">device_compat_ioctl</span>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<p>Can anybody please provide some explanations around this?</p>

<hr />

<p>A: This compat stuff is for running a 32-bit program in a 64-bit kernel. When you call the ioctl(fd, MY_IOCTL_CMD1, &amp;arg1) from a 32-bit program on a 64-bit kernel, the kernel will divert the ioctl to the .compat_ioctl function in the file_operations struct. This compat_ioctl function is responsible for copying the user argument arg1 as if it were compat_arg1, which uses the 32-bit layout. The compat_arg1 typedef is defined in the kernel so that when compiled for 64-bit, the structure is exactly the same layout as the arg1 compiled for 32-bit.</p>

<p>The definition of MY_IOCTL_CMD1 will take the sizeof arg1 into account when creating the cmd id. When you compile a program for a 32-bit machine, the value for MY_IOCTL_CMD1 will be different than if you compiled it for a 64-bit machine. The 32-bit MY_IOCTL_CMD1 should have the same value as the 64-bit MY_COMPAT_IOCTL_CMD1 in the kernel, however.</p>

<p>There&rsquo;s never a need to use compat_arg1 or MY_COMPAT_IOCTL_CMD1 in a user-space application. Those are only for code compiled in the kernel.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[家庭安防 - 一套萤石设备组建的家庭安防]]></title>
    <link href="http://markzhang.cn/blog/2015/12/22/ezviz-family-protection/"/>
    <updated>2015-12-22T15:07:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/12/22/ezviz-family-protection</id>
    <content type="html"><![CDATA[<p>智能硬件的火热也加速了安防产业的发展。家庭安防现在也成为了很多家庭考虑的一个方面。特别是对于楼层较低的家庭来说，安装一套安防系统还是相当之有必要。</p>

<p>之前也试用过360智能摄像机、小蚁智能摄像机，但是只有一个摄像头始终还是觉得单薄了一些，在二手卖掉这两个摄像头之后，购买了一套萤石的安防设备。</p>

<!-- more -->


<p>之所以说只有一个摄像头显的方案单薄主要是因为以下一些原因：</p>

<ul>
<li><p>没有录像设备。不管是出于隐私考虑还是容量/上传带宽的考虑，将24小时的录像上传到云端并不是一个最佳的方案。所以如果有一个24小时的录像设备，那么摄像头的存在才有意义。而且万一发生盗窃，就算摄像头被盗走，也还有录像设备保存了所有的录像资料。</p></li>
<li><p>没有报警设备。只有一个摄像头的话，唯一的报警设备就是手机。但是手机上的这些APP不能发出高分贝的报警音，而且由于系统的原因，在我测试的时候，安装在手机上的APP并不能及时的上报报警。比如Android系统由于 <code>Low memory Killer</code> 的存在，导致很多后台进程会在用户未感知的情况下被杀掉从而导致不报警。还有现在很多国内的安卓系统都有安全中心这样的东西，它会控制哪些APP不能启动后台Service等。手机报警唯一的适用场景是外出，如果是晚上睡觉，那你还要一直开着手机否则就收不到报警信息了。。。</p></li>
<li><p>摄像头有覆盖不到的区域，比如阳台。一般摄像头都是放在客厅，那么其实家里其他一些地方并覆盖不到。</p></li>
<li><p>我买的这两款摄像头处于成本售价的原因，夜视效果都不好。对于安防来说，其实要的就是夜视效果。。。</p></li>
</ul>


<p>还有其实有一些功能其实是没有必要的，比如所谓的双向对讲。就是可以在手机上说话然后让摄像头播放出来，我想说这个其实是娱乐功能吧？谁会整天用这功能？</p>

<p>回到主题，基于以上一些考虑，在Google了一番之后，重新采购了以下设备：</p>

<ul>
<li><p>萤石C3C商铺宝摄像机</p></li>
<li><p>萤石N1互联网硬盘录像机</p></li>
<li><p>萤石A1C互联网报警盒子套装</p></li>
</ul>


<p>不是给萤石打广告，实在是我懒的去找多家的产品然后进行比较，所以就都在萤石一家买了。。。</p>

<p>首先来说摄像机和录像机。选用C3C主要是它有WIFI，而且超强夜视（看看镜头里面的红外灯珠就懂了）。挂在客厅的角落天花板上就可以覆盖到整个客厅。再配合N1录像机，就做到了监控录像两不误。我买的N1是最便宜的一款，最多支持4路输入。放入一块1T的硬盘，如果是移动侦测录像（就是只有探测到移动产生才会录像）的话，估计能录个几个月。C3C的唯一缺点就是它是针对商铺用的，所以没有录音，只有录像。此外由于我的C3C配合N1录像，所以C3C本身里面就不需要再插SD卡了。</p>

<p>C3C和N1的配置也非常简单，通过手机上的 <code>萤石视频</code> 就可以非常轻松的配置上，N1也能自动检测到C3C并开启录像。并且也支持定时计划，比如晚上11点之后就开启移动侦测报警，早上7点就关闭移动侦测报警等，总体来说还不错。</p>

<p>借用一下萤石官网的图片，如果侵犯到了萤石的权益请告知，我会删除：</p>

<p><img src="http://markzhang.cn/downloads/image/c3c.png" alt="C3C" /></p>

<p><img src="http://markzhang.cn/downloads/image/n1.png" alt="N1" /></p>

<p>不过也不是没有可以吐槽的地方，比如N1。N1做为录像机，出于安全考虑，自然我们会把它摆到不显眼的地方。但是N1上的三个灯是要闹哪样？一个电源红色灯常亮，一个硬盘灯如果开启24小时录像那是不停的闪（因为要写硬盘嘛），还有一个蓝色的网络灯那就不说了。。。就跟黑暗中的灯塔一样能闪瞎眼。而且还没有配置项可以关闭这些灯。显然研发人员是把N1当作一台电脑来设计的了。还有C3C，随机配的电源线只有一米，如果家庭装修的时候没考虑到监控的话，这一米的线能干嘛？摆在茶几上监控么？但凡要吊在天花板上的话，至少也要五米的线。所以我很无奈的又在淘宝上买了一根电源延长线。</p>

<p>再来说说所谓的A1C互联网报警盒子套装，名字很长而且唬人。其实就是一个报警盒子A1C，加上一个红外探测器和一个单体门磁。</p>

<p>借用一下萤石官网的图片，如果侵犯到了萤石的权益请告知，我会删除：</p>

<p><img src="http://markzhang.cn/downloads/image/a1c-collection.png" alt="a1c collection" /></p>

<p>A1C相当与是所有传感器（或者说探测设备）的网关，自带WIFI。其他的探测器比如我买的红外探测器和单体门磁，通过无线射频与A1C传递信息。再结合A1C上配置的报警策略，来决定是否要报警。</p>

<p>只有A1C上有高分贝的报警喇叭，探测器本身是不会报警的，探测器只是发送信号给A1C，所以光买探测器不买A1C是没有任何用处的。</p>

<p>有关红外探测器，装上电池，添加到A1C上，放在高处就可以了，非常简单。至于探测器如何添加到A1C上，说明书上有详细说明，而且A1C也有语音提示，这方面做的还是很不错的，简单易用。只需要注意说明书上告知要将红外探测器放到1.8m &ndash; 2.3m的高处，而且最好是用泡沫胶粘贴在墙角位置，探测器随机还附送了泡棉胶，这点萤石还是很贴心的。</p>

<p>所以这个红外探测器就可以成为摄像头的一个很好的补充设备，比如阳台。阳台一般都有很多扇窗户，每扇窗户上都安装门磁不经济管理也不方便，所以在阳台墙上安装一个红外探测，就把整个阳台管上了。此外放在房间也是一个不错的选择，因为探测器和A1C是射频方式连接的，所以只要不是隔了很多堵墙的话，一般信号传输都是没有问题的。</p>

<p>再说单体门磁。萤石有两种门磁，一种就是常见的两个一套的，这两个玩意一旦分离就报警，需要面对面的安装在门和门框上。我买的这个是单体门磁（因为套装中就是这个），高级一点，只有一个设备，贴在门上即可。它会感应门的位置从而报警。实际使用下来来看报警还是相当准确的。</p>

<p>实际使用下来，这套套装工作的还是不错的。出门的时候设置成 <code>外出模式</code>，红外和门磁一旦检测到异常A1C就会报警并发送消息到手机。晚上的时候设置成 <code>睡眠模式</code>，同样可以监测报警。A1C也支持跟摄像头一样的定时计划，比如到晚上11点，就可以挨个设定每个探测器上发的报警是否启动，到早上7点就可以恢复（也就是取消所有报警）。</p>

<p>最后说到报警的话，还要再提一点，那就是摄像机的移动监测报警。这个功能其实不如红外探测和无线门磁这样的报警准确。因为摄像机的移动监测其实就是检测画面是否有变化，有变化就会报警。所以一般晚上的时候，如果外面的光线传到室内，也会导致画面变化从而报警。比如你家对面有个KTV，晚上正是灯火辉煌的时候，各种霓虹灯乱闪，这个时候如果你开启摄像头的移动监测报警。。。你就等着手机一直叫吧。所以其实摄像机的主要任务还是记录下家中的情况，真正的准确报警还是要依赖各种传感器。</p>

<p>吐槽：一开始买来的A1C，开机就提示要升级，结果升级完了之后语音就没了。。。客服态度倒是很好，还把研发找来，研发给我打电话一通询问，感觉就是我跟他一起解bug。这其实挺好，说明萤石还是乐意听取用户的声音的，我要吐槽的是，为毛申请产品换货需要5-7天的审核？你没看错，就是说你在萤石官网提交了售后申请之后，至少要五天，这个申请才会被批准（果然我的申请第五天“准时”被批准了），然后你才能填快递单号将东西寄回，而且快递费还要自己先垫付，事情全部结束后再打萤石热线去要这个快递费。</p>

<p>好在萤石的客服和研发还是不错，早早的给了我换货的寄送地址，所以我一早就把有问题的A1C寄回了，完了之后过了大概一周收到电话说新的可以寄给我了。。。问了一下研发说语音没有了的原因是不知道为什么，升级的时候语音包丢了。。。</p>

<p>作为用户来说，买了东西自然希望第一时间安装调试好然后开始使用，所以当发现产品质量有问题的时候，应该是尽快帮用户解决问题，可能商家也有商家的难处，但是站在用户角度来说，我表示这点萤石做的不如360这样的互联网公司。到现在我还在等萤石的客服给我打电话，告知我什么时候能给我快递费。。。从我买这套萤石产品开始到现在，我少说已经打了近十次萤石热线了吧。。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[repo init 中指定manifest和branch的含义]]></title>
    <link href="http://markzhang.cn/blog/2015/12/22/repo-init-manifest-branch/"/>
    <updated>2015-12-22T14:59:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/12/22/repo-init-manifest-branch</id>
    <content type="html"><![CDATA[<p>比如：</p>

<p>repo init -u git://xxx/xxx/manifest.git -b <BRANCH> -m <MANIFEST></p>

<!-- more -->


<p></p>

<p>这里-m和-b的含义是：</p>

<ol>
<li><p>注意到manifest.git本身也是一个git project</p></li>
<li><p>所以，-b指定的是使用#1中这个git project的哪个branch</p></li>
<li><p>-m指定的是，下载该git project中的哪个文件（应该是首先切换了branch，然后再下载该文件）。</p></li>
</ol>


<p>repo init这样做过了之后，其实本地就建立起来了一个.repo目录，里面核心文件就是manifest.xml，这个xml中就定义了：</p>

<ul>
<li><p>包含哪些git project</p></li>
<li><p>每个git project使用什么branch</p></li>
<li><p>每个git project在本地磁盘上的路径和远端服务器上该git project的路径。</p></li>
</ul>


<p>事实上，当repo init完成，在本地的.repo/manifests目录下就可以看到manifest这个git project，可以用git branch -av来查看branch，用git log来查看日志。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Thunderbird配置 - for kernel maillist]]></title>
    <link href="http://markzhang.cn/blog/2015/12/21/kernel-thunderbird/"/>
    <updated>2015-12-21T14:22:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/12/21/kernel-thunderbird</id>
    <content type="html"><![CDATA[<p>From kernel: Documentation/email-clients.txt</p>

<!-- more -->


<p>Thunderbird (GUI)</p>

<p>Thunderbird is an Outlook clone that likes to mangle text, but there are ways
to coerce it into behaving.</p>

<ul>
<li>Allows use of an external editor:
The easiest thing to do with Thunderbird and patches is to use an
&ldquo;external editor&rdquo; extension and then just use your favorite $EDITOR
for reading/merging patches into the body text.  To do this, download
and install the extension, then add a button for it using
View->Toolbars->Customize&hellip; and finally just click on it when in the
Compose dialog.</li>
</ul>


<p>To beat some sense out of the internal editor, do this:</p>

<ul>
<li><p>Edit your Thunderbird config settings so that it won&rsquo;t use format=flowed.
Go to &ldquo;edit->preferences->advanced->config editor&rdquo; to bring up the
thunderbird&rsquo;s registry editor, and set &ldquo;mailnews.send_plaintext_flowed&rdquo; to
&ldquo;false&rdquo;.</p></li>
<li><p>Disable HTML Format: Set &ldquo;mail.identity.id1.compose_html&rdquo; to &ldquo;false&rdquo;.</p></li>
<li><p>Enable &ldquo;preformat&rdquo; mode: Set &ldquo;editor.quotesPreformatted&rdquo; to &ldquo;true&rdquo;.</p></li>
<li><p>Enable UTF8: Set &ldquo;prefs.converted-to-utf8&rdquo; to &ldquo;true&rdquo;.</p></li>
<li><p>Install the &ldquo;toggle wordwrap&rdquo; extension.  Download the file from:
  <a href="https://addons.mozilla.org/thunderbird/addon/2351/">https://addons.mozilla.org/thunderbird/addon/2351/</a>
Then go to &ldquo;tools->add ons&rdquo;, select &ldquo;install&rdquo; at the bottom of the screen,
and browse to where you saved the .xul file.  This adds an &ldquo;Enable
Wordwrap&rdquo; entry under the Options menu of the message composer.</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kernel Submitting Patches，有关ifdef和static inline & macro]]></title>
    <link href="http://markzhang.cn/blog/2015/12/21/kernel-ifdef-macros/"/>
    <updated>2015-12-21T14:19:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/12/21/kernel-ifdef-macros</id>
    <content type="html"><![CDATA[<p>From kernel: Documentation/SubmittingPatches</p>

<!-- more -->


<p>2) #ifdefs are ugly</p>

<p>Code cluttered with ifdefs is difficult to read and maintain.  Don&rsquo;t do
it.  Instead, put your ifdefs in a header, and conditionally define
&lsquo;static inline&rsquo; functions, or macros, which are used in the code.
Let the compiler optimize away the &ldquo;no-op&rdquo; case.</p>

<p>Simple example, of poor code:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'>    <span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_etherdev</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">funky_private</span><span class="p">));</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
</span><span class='line'>            <span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
</span><span class='line'>    <span class="err">#</span><span class="n">ifdef</span> <span class="n">CONFIG_NET_FUNKINESS</span>
</span><span class='line'>    <span class="n">init_funky_net</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
</span><span class='line'>    <span class="err">#</span><span class="n">endif</span>
</span></code></pre></td></tr></table></div></figure>


<p>Cleaned-up example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="p">(</span><span class="n">in</span> <span class="n">header</span><span class="p">)</span>
</span><span class='line'>        <span class="err">#</span><span class="n">ifndef</span> <span class="n">CONFIG_NET_FUNKINESS</span>
</span><span class='line'>        <span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">init_funky_net</span> <span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'>        <span class="err">#</span><span class="n">endif</span>
</span><span class='line'><span class="p">(</span><span class="n">in</span> <span class="n">the</span> <span class="n">code</span> <span class="n">itself</span><span class="p">)</span>
</span><span class='line'>        <span class="n">dev</span> <span class="o">=</span> <span class="n">alloc_etherdev</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">funky_private</span><span class="p">));</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
</span><span class='line'>                <span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
</span><span class='line'>        <span class="n">init_funky_net</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>3) &lsquo;static inline&rsquo; is better than a macro</p>

<p>Static inline functions are greatly preferred over macros.
They provide type safety, have no length limitations, no formatting
limitations, and under gcc they are as cheap as macros.
Macros should only be used for cases where a static inline is clearly
suboptimal [there are a few, isolated cases of this in fast paths],
or where it is impossible to use a static inline function [such as
string-izing].</p>

<p>&lsquo;static inline&rsquo; is preferred over &lsquo;static <strong>inline</strong>&rsquo;, &lsquo;extern inline&rsquo;,
and &lsquo;extern <strong>inline</strong>&rsquo;.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[kernel: How to decompress the zImage?]]></title>
    <link href="http://markzhang.cn/blog/2015/12/21/kernel-decompress-zimage/"/>
    <updated>2015-12-21T14:00:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/12/21/kernel-decompress-zimage</id>
    <content type="html"><![CDATA[<p>zImage不是标准的gzip文件，需要自己strip掉开头的一些东西才可以gunzip。</p>

<p>基本上的思路就是找gzip的magic number &ldquo;1f 8b 08&#8221;。</p>

<!-- more -->


<p>具体步骤：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>mkdir -p /tmp/kernel-uncompressed/; <span class="nb">cd</span> /tmp/kernel-uncompressed/
</span><span class='line'><span class="nv">$ </span>cp /boot/vmlinuz-<span class="sb">`</span>uname -r<span class="sb">`</span> .
</span><span class='line'><span class="nv">$ </span>od -t x1 -A d vmlinuz-2.6.18-128.el5.uvm6PAE | grep <span class="s2">&quot;1f 8b 08&quot;</span>
</span><span class='line'>0008320 1b 00 1f 8b 08 00 d5 c2 9a 49 02 03 ec 3b 7d 7c
</span><span class='line'><span class="nv">$ </span>dd <span class="nv">bs</span><span class="o">=</span>1 <span class="nv">skip</span><span class="o">=</span>8322 <span class="k">if</span><span class="o">=</span>vmlinuz-2.6.18-128.el5.uvm6PAE | zcat &gt; vmlinux
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[kernel: 调用init程序的地方]]></title>
    <link href="http://markzhang.cn/blog/2015/12/21/kernel-calls-init/"/>
    <updated>2015-12-21T13:57:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/12/21/kernel-calls-init</id>
    <content type="html"><![CDATA[<p>start_kernel函数的最后一行：rest_init，调用了init程序。</p>

<p>看代码就很清楚了。有个地方值得注意的是，优先被调用的是initramfs中的init程序（可以通过rdinit=xxx来设定）。</p>

<p>然后才会去检查 <code>init=</code> 的设置。</p>

<p>如果这两个都没有设置的话，kernel就会挨个去尝试/sbin/init, /bin/init, /bin/sh&hellip;</p>

<p>这些都没有那就panic了</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android system.img: yaffs or ext4?]]></title>
    <link href="http://markzhang.cn/blog/2015/12/17/android-system-dot-img-yaffs-or-ext4/"/>
    <updated>2015-12-17T11:18:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/12/17/android-system-dot-img-yaffs-or-ext4</id>
    <content type="html"><![CDATA[<p>随着现在手机的内部存储从NAND转变到eMMC，现在的system.img已经越来越多的使用ext4作为文件系统，而不是以前的yaffs2。</p>

<p>使用file命令查看system.img，如果输出是：VMS Alpha Exectutable，那么这是yaffs</p>

<!-- more -->


<p>如果输出是data，那么很可能是ext4的。只不过这个image是一个spare image，含有一些spare数据，所以需要先用simg2img处理一下，然后就可以直接mount了。</p>

<p>至于为什么采用eMMC来代替NAND，摘录百度百科的一段话：</p>

<blockquote><p>eMMC目前是最当红的移动设备本地存储解决方案，目的在于简化手机存储器的设计，由于NAND Flash芯片的不同厂牌包括三星、KingMax、东芝(Toshiba)或海力士(Hynix)、美光(Micron)等，入时，都需要根据每家公司的产品和技术特性来重新设计，过去并没有哪个技术能够通用所有厂牌的NAND Flash芯片。</p>

<p>而每次NAND Flash制程技术改朝换代，包括70纳米演进至50纳米，再演进至40纳米或30纳米制程技术，手机客户也都要重新设计，但半导体产品每1年制程技术都会推陈出新，存储器问题也拖累手机新机种推出的速度，因此像eMMC这种把所有存储器和管理NAND Flash的控制芯片都包在1颗MCP上的概念，逐渐风行起来。</p>

<p>eMMC的设计概念，就是为了简化手机内存储器的使用，将NAND Flash芯片和控制芯片设计成1颗MCP芯片，手机客户只需要采购eMMC芯片，放进新手机中，不需处理其它繁复的NAND Flash兼容性和管理问题，最大优点是缩短新产品的上市周期和研发成本，加速产品的推陈出新速度。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[天语（k-touch） w619: Dump boot.img和system.img，然后做成recovery可用的刷机zip包]]></title>
    <link href="http://markzhang.cn/blog/2015/12/17/ktouch-w619-create-flash-package/"/>
    <updated>2015-12-17T11:08:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/12/17/ktouch-w619-create-flash-package</id>
    <content type="html"><![CDATA[<p>有的时候会有这样的问题：发现一个民间的刷机包很不错，但是就是缺少一些你想要的东西。这个时候，其实就可以尝试基于这个包自己做一些修改、添加，最终生成自己满意的系统包。</p>

<p>也有的时候，要给老人一部安卓机器来用，但是老人不擅长智能手机操作，经常会把一些APP误删除。这个时候其实可以自己制作刷机包，将必须的一些APP放到<code>system</code>下面，这样就不怕老人误删除APP了。</p>

<p>以下是我自己在天语w619的尝试：</p>

<!-- more -->


<ol>
<li><p>root手机</p></li>
<li><p>配置/etc/udev/rules.d/51-Android.conf，将手机的USB的vendor id/product id加进去。用lsusb可以看到这两个ID。</p></li>
<li><p>adb shell</p></li>
<li><p>su; cd /sdcard</p></li>
<li><p>tar czvf system.tar.gz /system</p></li>
<li><p>dd if=/dev/mtd/mtd0 of=/sdcard/boot.img  # 应该可以和system分区同样处理，用tar将/boot打包即可。dump整个分区有很多废数据产生</p></li>
<li><p>退出adb shell</p></li>
<li><p>在PC上：adb pull /sdcard/system.tar.gz</p></li>
<li><p>tar zxvf system.tar.gz</p></li>
<li><p>mkfs.yaffs2.x86 ./system system.img  # mkfs.yaffs2.x86在googlecode上下载</p></li>
<li><p>有了boot.img和system.img，就可以使用Android Kitchen来制作一个刷机包了。</p></li>
</ol>


<p>cat /proc/mtd可以看到所有的mtd分区和对应的名字，这样就可以知道boot分区是哪个设备文件了。</p>

<p>刷机时发现：</p>

<ol>
<li><p>Android kitchen做的刷机包，META-INF/com/google/android目录下的update-binary是不正确的，可以找一个别人制作的w619刷机包中的替代。不正确的update-binary的现象就是刷机出错：status 0（使用的是CWM recovery）</p></li>
<li><p>META-INF/com/google/android目录下的updater-script中也有几个问题：</p>

<ol type="a">
<li><p>文件行尾不能有\r\n，只能有\r，也就是说必须是unix格式的文本。刷机现象：status 6</p></li>
<li><p>format(&ldquo;MTD&rdquo;, &ldquo;system&rdquo;); &ndash;> format(&ldquo;yaffs2&rdquo;, &ldquo;MTD&rdquo;, &ldquo;system&rdquo;); 刷机现象：CWM recovery会提示format有三个参数</p></li>
<li><p>mount(&ldquo;MTD&rdquo;, &ldquo;system&rdquo;, &ldquo;/system&rdquo;); &ndash;> mount(&ldquo;yaffs2&rdquo;, &ldquo;MTD&rdquo;, &ldquo;system&rdquo;, &ldquo;/system&rdquo;); # 和format的现象一样</p></li>
</ol>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SSH client config Sample]]></title>
    <link href="http://markzhang.cn/blog/2015/12/17/ssh-config/"/>
    <updated>2015-12-17T11:01:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/12/17/ssh-config</id>
    <content type="html"><![CDATA[<p>man ssh_config，查看~/.ssh/config的语法。</p>

<p>Host可以使用通配符，当ssh的时候如果server的URL能match上这里Host指定的值，则Host下面指定的HostName将被作为最终URL使用。同时该Host下配置的User, Port都将被使用。</p>

<p>当然，User和Port都可以被命令行上指定的override。</p>

<p>附上目前的一份sample配置：</p>

<!-- more -->




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>Host chromium
</span><span class='line'>  HostName gerrit.chromium.org
</span><span class='line'>  User markz
</span><span class='line'>  Port 29418
</span><span class='line'>  PubkeyAuthentication yes
</span><span class='line'>  IdentityFile ~/.ssh/chromium
</span><span class='line'>Host bitbucket.*
</span><span class='line'>  HostName bitbucket.org
</span><span class='line'>  PubkeyAuthentication yes
</span><span class='line'>  IdentityFile ~/.ssh/bitbucket
</span><span class='line'>Host gitorious.*
</span><span class='line'>  HostName gitorious.org
</span><span class='line'>  PubkeyAuthentication yes
</span><span class='line'>  IdentityFile ~/.ssh/gitorious
</span><span class='line'>Host gitse
</span><span class='line'>  HostName gitse.nvidia.com
</span><span class='line'>  PubkeyAuthentication yes
</span><span class='line'>  IdentityFile ~/.ssh/gitse
</span><span class='line'>Host github.*
</span><span class='line'>  HostName github.com
</span><span class='line'>  PubkeyAuthentication yes
</span><span class='line'>  IdentityFile ~/.ssh/github
</span><span class='line'>Host *.cyanogenmod.*
</span><span class='line'>  HostName review.cyanogenmod.org
</span><span class='line'>  PubkeyAuthentication yes
</span><span class='line'>  IdentityFile ~/.ssh/cmreview
</span><span class='line'>Host *
</span><span class='line'>  PubkeyAuthentication no
</span></code></pre></td></tr></table></div></figure>


<p>在最末尾默认禁止Public key的验证方式，也就是说，优先采用password验证。否则有些ssh server就会登录不上，因为有些ssh server优先验证public key，而我们这里有很多public key，一个一个验证失败之后就会因为验证失败次数太多从而连不上server。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mmap: invalid argument & MAP_PRIVATE]]></title>
    <link href="http://markzhang.cn/blog/2015/12/17/mmap-invalid-arg/"/>
    <updated>2015-12-17T10:53:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/12/17/mmap-invalid-arg</id>
    <content type="html"><![CDATA[<p>mmap，使用PROT_READ | PROT_WRITE, MAP_SHARED，总是返回EINVAL。</p>

<p>最后发现是因为被mmap的文件是一个network filesystem上的文件。</p>

<!-- more -->


<p>Linux实现MAP_SHARED是通过share文件的page cache做到的。对于一个网络上的文件来说，Linux无法做到文件的某个部分被修改了，同时打开该文件的其他机器上的程序能立马看到。</p>

<p>所以自然就返回EINVAL了。</p>

<p>悲催的是mmap的manual上并没有提到这种情况，所以查了半天。</p>

<p>此外，MAP_PRIVATE其实就是当你修改了文件之后，会copy一个新的page出来，所以自然就无法跟其他进程共享你的修改了。</p>

<p>同时还需要注意的是，MAP_PRIVATE的时候，对文件进行的修改将不会被写到文件中去！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux kernel: How to debug mutex deadlock 如何调试mutex死锁]]></title>
    <link href="http://markzhang.cn/blog/2015/12/16/kernel-debug-deadlock/"/>
    <updated>2015-12-16T15:47:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/12/16/kernel-debug-deadlock</id>
    <content type="html"><![CDATA[<p>和userspace调试lock一样，主要是要：</p>

<ol>
<li><p>找到lock死锁的地方，打印出调用栈</p></li>
<li><p>找出这个mutex目前被谁占用了</p></li>
</ol>


<!-- more -->


<p>针对1：在kernel config中，Kernel Hacking这个大项中，enable跟lock/mutex相关的config，比如CONFIG_DEBUG_MUTEX，以及CONFIG_DETECT_HUNG_TASKS, 这样当死锁发生时，稍微等待一段时间（默认120秒），kernel就会检测到死锁，同时打印出调用栈。在kernel hacking里面，包含了大量的有利于调试的config，可以一项一项都看一遍，总有一款适合您。</p>

<p>针对2：来到代码中死锁的地方，在enable了CONFIG_DEBUG_MUTEX的情况下，添加这样的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">show_stack</span><span class="p">(</span><span class="o">&lt;</span><span class="n">lock</span><span class="o">&gt;</span><span class="p">.</span><span class="n">owner</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><lock>是你的mutex的变量名，.owner是一个struct task_struct *，利用show_stack函数就可以打印出该mutex被谁占用了，而且占用该mutex时的调用栈。非常cool。</p>

<p>此外可以看一下struct mutex的定义，有一些实用的东西，比如mutex的name。struct task_struct中也有一些实用的东西，比如pid等。</p>

<p>所以总结来说，kernel中目前可以打印调用栈的有：</p>

<p>dump_stack：打印当前的backtrace</p>

<p>show_stack：打印指定task_struct的backtrace</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chromium OS相比Chrome OS缩水的地方]]></title>
    <link href="http://markzhang.cn/blog/2015/12/16/chromiumos-chromeos/"/>
    <updated>2015-12-16T14:44:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/12/16/chromiumos-chromeos</id>
    <content type="html"><![CDATA[<p>关于两者的区别，下面是Google官方的解释：</p>

<!-- more -->


<ol>
<li>Chromium OS人人都可下载、修改，并且免费使用。Chrome OS只提供给品牌厂商的特定笔记本机型（也就是Chromebook）使用。</li>
<li>Chrome OS具有需验证的引导和轻松恢复功能，Chromium OS则没有（也没需要）。</li>
<li>Chrome OS具有自动更新功能，可以保持你的系统是最新状态，Chromium OS则没有，要想更新系统只有下载新版来重装。</li>
<li>Chrome OS针对具体的笔记本硬件有特别优化，运行时性能更高，也更稳定（这个笔者有深刻体会）；Chromium OS则只包含一些早已存在的开源硬件驱动。</li>
<li>Chrome OS由Google公司和笔记本品牌厂商提供技术支持，Chromium OS则由开源社区提供支持。</li>
<li>Chrome OS内置Flash、PDF和Netflix Instant插件，并且有Google Talk软件，支持3G网络，Chromium OS则没有以上特性（没有Flash插件最要命啊）。</li>
<li>图标不一样，Chrome OS的图标是红黄蓝绿四色，Chromium OS只有蓝色。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Raspberry Pi + ArchLinux：网络dhcp不稳定，经常无法获取IP地址]]></title>
    <link href="http://markzhang.cn/blog/2015/12/16/raspberrypi-dhcp-timeout/"/>
    <updated>2015-12-16T14:40:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/12/16/raspberrypi-dhcp-timeout</id>
    <content type="html"><![CDATA[<p>经常发现树莓派开机之后网络没有起来，最终发现是因为dhcpcd的-t参数，也就是等待dhcp server响应的timeout时间太短导致的。</p>

<p>默认是30秒，但是ArchLinux中配置的是10秒。</p>

<p>查看了脚本，调用dhcpcd的是netcfg，netcfg本身也是一个脚本，所以最终发现这个-t是在/usr/lib/network/connections/ethernet中设置的。</p>

<p>于是在这个文件的开头加上了：<code>DHCP_TIMEOUT=300</code></p>

<p>这样超时就变成了5分钟，足够了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to HACK CISCO anyconnect secure mobile client]]></title>
    <link href="http://markzhang.cn/blog/2015/08/31/hack-cisco-anyconnect/"/>
    <updated>2015-08-31T08:31:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/08/31/hack-cisco-anyconnect</id>
    <content type="html"><![CDATA[<p>本文参考了以下两篇文章：</p>

<p><a href="http://superuser.com/questions/284709/how-to-allow-local-lan-access-while-connected-to-cisco-vpn">http://superuser.com/questions/284709/how-to-allow-local-lan-access-while-connected-to-cisco-vpn</a></p>

<p><a href="https://github.com/jbalint/dnsmasq/blob/master/run.sh">https://github.com/jbalint/dnsmasq/blob/master/run.sh</a></p>

<!-- more -->


<p>CISCO anyconnect secure mobile client（以下简称anyconnect）是CISCO的一个VPN客户端，很多公司都在采用。但是如果你尝试在一台机器上运行anyconnect，其他机器想通过这台机器也能访问公司内网的话，你就发现这是不行的。这是因为anyconnect做了三件令人恶心的事情：</p>

<h2>监控路由表</h2>

<p>Anyconnect客户端启动并连接VPN成功之后，是会监控系统的路由表的。此时，你可以添加路由（但是不好意思这不管用，因为Anyconnect已经添加了一条默认路由），但是无法删除路由。你可以运行 <code>route del default</code>，命令也不会出错，但是之后你用 <code>route -n</code> 看一下，发现没有效果 &mdash; 这是因为Anyconnect把路由又添加回来了。</p>

<p>事实上，是Anyconnect的 <code>vpnagentd</code> 这个守护进程在监控系统路由表。为此，网上有这么一个解决方案，我测试了一下是OK的：</p>

<p>编写这样一个程序：</p>

<figure class='code'><figcaption><span>hack.c</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;sys/socket.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;linux/netlink.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">_ZN27CInterfaceRouteMonitorLinux20routeCallbackHandlerEv</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">fd</span><span class="o">=</span><span class="mi">50</span><span class="p">;</span>          <span class="c1">// max fd to try</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">8192</span><span class="p">];</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">sockaddr_nl</span> <span class="n">sa</span><span class="p">;</span>
</span><span class='line'>    <span class="n">socklen_t</span> <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sa</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>       <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">getsockname</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sa</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">if</span> <span class="p">(</span><span class="n">sa</span><span class="p">.</span><span class="n">nl_family</span> <span class="o">==</span> <span class="n">AF_NETLINK</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>             <span class="n">ssize_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">recv</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="n">MSG_DONTWAIT</span><span class="p">);</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>       <span class="p">}</span>
</span><span class='line'>       <span class="n">fd</span><span class="o">--</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后编译：<code>gcc -o libhack.so -shared -fPIC hack.c</code>，最后利用 <code>LD_PRELOAD</code> 将其装载：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">LD_PRELOAD</span><span class="o">=</span>/opt/cisco/anyconnect/lib/libhack.so /opt/cisco/anyconnect/bin/vpnagentd
</span></code></pre></td></tr></table></div></figure>


<p>你可以通过修改 <code>/etc/init.d/vpnagentd</code> 这个脚本，添加上面的 <code>LD_PRELOAD</code> 部分。</p>

<p>所以原理其实很简单，就是要修改anyconnect监控路由表的那个函数。在上面的代码中，这个函数是：<code>_ZN27CInterfaceRouteMonitorLinux20routeCallbackHandlerEv</code>，在anyconnect 3.1版本测试是OK的。</p>

<p>那如果找出这个函数呢？毕竟anyconnect还有MACOS版，windows版等各种不同版本。对于这个，原作者也有一个办法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo gdb --pid &lt;vpnagentd pid&gt;
</span><span class='line'><span class="nb">break </span>socket
</span><span class='line'><span class="k">continue</span>
</span><span class='line'>bt
</span></code></pre></td></tr></table></div></figure>


<p>也就是说attach上 <code>vpnagentd</code> 进程，然后在 <code>socket</code> 这个函数上设置断点，当你设置了断点之后，输入 <code>continue</code> 让 <code>vpnagentd</code> 继续运行，然后你就可以在命令行下去执行：<code>sudo route del default</code>，这样 <code>vpnagentd</code> 就会撞上我们设置的断点了，此时用bt就可以看到调用栈了。</p>

<p>得到调用栈之后，你能看到的是类似这样的东西：<code>CInterfaceRouteMonitorLinux::routeCallbackHandle</code>，这并不是真正的symbol，这是GDB帮我们解析过的函数名，所以，可以用 <code>nm</code>, <code>objdump</code> 这样的工具去dump这个函数所在的文件（在我的anyconnect 3.1上，这个文件是：<code>/opt/cisco/anyconnect/lib/libvpnagentutilities.so</code>），在dump出来的symbol中去grep这个函数，就可以得到真正的symbol名字了。</p>

<p>如果 <code>nm</code> / <code>objdump</code> 无法显示出symbol的话，那就是这个库或者可执行文件是strip过的，那这个时候我们就只能用 <code>hexedit</code> 这样的工具打开二进制文件，在其中搜索GDB中我们得到的函数名字了。</p>

<h2>监控 /etc/resolv.conf</h2>

<p>这是为了防止我们修改DNS，对于此，解决方案要简单一些，毕竟这是针对文件的修改，而Linux kernel有一些对 <code>inotify</code> 的设置，所以可以这样做：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># go to great lengths to rewrite resolv.conf</span>
</span><span class='line'><span class="c"># the vpnagentd watches it with inotify and rewrites it immediately after I change it</span>
</span><span class='line'><span class="c"># set inotify limit to 0, first rewrite, vpnagentd will fix it, but then wont be able to set the watch again....</span>
</span><span class='line'><span class="nv">INOTIFYLIMIT</span><span class="o">=</span><span class="sb">`</span>cat /proc/sys/fs/inotify/max_user_watches<span class="sb">`</span>
</span><span class='line'>sudo bash -c <span class="s2">&quot;echo 0 &gt; /proc/sys/fs/inotify/max_user_watches&quot;</span>
</span><span class='line'>sudo bash -c <span class="s2">&quot;echo nameserver 127.0.0.1 &gt; /etc/resolv.conf&quot;</span>
</span><span class='line'>sleep 1
</span><span class='line'>sudo bash -c <span class="s2">&quot;echo nameserver 127.0.0.1 &gt; /etc/resolv.conf&quot;</span>
</span><span class='line'>sudo bash -c <span class="s2">&quot;echo $INOTIFYLIMIT &gt; /proc/sys/fs/inotify/max_user_watches&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个方案我没有测试过，所以我不敢保证一定管用。列在这里只是想说明，对于一个进程监控某个文件这种事情，可以利用kernel的 <code>inotify</code> 的一些设置，从而来绕过进程的这种行为。</p>

<h2>设置iptables</h2>

<p>Anyconnect是有设置iptables rules的，运行：<code>sudo iptables -vnL</code>，就可以看到anyconnect设置的所有rules。</p>

<p>这些rules中，有一个很讨厌的地方就是，它会约束anyconnect只服务于来自本地的请求，也就是说，如果局域网内其他机器想通过拨了anyconnect的机器共享访问VPN资源的话，这是不行的。</p>

<p>解决方法倒是异常简单：<code>sudo iptables -F</code> 搞定，貌似anyconnect并没有监控iptables的修改。</p>

<h2>最后</h2>

<p>虽然anyconnect有上述三条类似木马病毒的行为，但是实事求是的说，它本身工作的还是很好的，而且它有适应不同操作系统的各种版本也很不错。</p>

<p>回到开头的话题，在我们搞定了上述三条之后，如果想让其他机器通过拨了anyconnect的机器共享访问VPN资源的话，只需要在拨了anyconnect的机器上再运行两条命令即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">echo </span>1 &gt; /proc/sys/net/ipv4/ip_forward
</span><span class='line'>iptables -t nat -A POSTROUTING -o cscotun0 -j MASQUERADE
</span></code></pre></td></tr></table></div></figure>


<p>你可以将上面两条命令添加到：<code>/etc/rc.local</code> 即可在开机时自动执行了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[电动直升机的油门锁定（THRU HOLD）和油门熄火（THRU CUT）]]></title>
    <link href="http://markzhang.cn/blog/2015/07/24/throttle-hold-and-throttle-cut/"/>
    <updated>2015-07-24T11:43:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/07/24/throttle-hold-and-throttle-cut</id>
    <content type="html"><![CDATA[<p><code>油门锁定</code> 和 <code>油门熄火</code> 是不太容易理解的两个东西，关键是他们俩有什么区别。5IMX上有一篇帖子挺精彩的：</p>

<p><a href="http://bbs.5imx.com/bbs/forum.php?mod=viewthread&amp;tid=544614&amp;page=1">http://bbs.5imx.com/bbs/forum.php?mod=viewthread&amp;tid=544614&amp;page=1</a></p>

<!-- more -->


<p>看了上面的帖子，又看了看14SG的说明书，其实这两个功能涉及到的东西都是油门和桨距（pitch）这两个东西。我是这么理解的：</p>

<p>有关油门锁定：</p>

<ul>
<li>在14SG中，油门锁定是一个 <code>condition</code>，跟 <code>normal</code>, <code>idle up1</code>, <code>idle up2</code>一样，可以用开关来切换</li>
<li>顾名思义，油门锁定启动后，油门（THROTTLE）的值将会被锁定在设定值上，但是桨距曲线依然管用，这就是为什么油门锁定被设计成一个 <code>condition</code></li>
<li>所以我的理解，油门锁定可以用于一些固定油门通道，只控制桨距的场景。比如自旋，降落</li>
</ul>


<p>有关油门熄火：</p>

<p>貌似这个概念是从油机过来的。由于现在大家都在玩电直，没有油直的背景，所以对这个东西的理解就很费劲。我也不太理解这个东西，我只是看了下14SG上这个功能的设置，有这么几个理解：</p>

<ul>
<li>油门熄火不是一种 <code>condition</code>，所以和油门锁定不同，你无法针对油门熄火这种情况设定桨距曲线，也就是说，当油门熄火启动时，桨距曲线将遵循油门熄火启动之前的设定</li>
<li>14SG中的油门熄火设置中，有一项 <code>THRO</code> 的百分比设置，这个设置跟油门熄火中的 <code>THRO</code> 设定不同，这里的 <code>THRO</code> 不是指当油门熄火启动时，要将油门设定到什么值。这个设定指的是，当当前油门值小于该设定值时，油门熄火功能启动 &mdash; 当然，有一个前提就是对应的油门熄火开关拨到了启动位置</li>
<li>所以14SG上，要启动油门熄火有两个条件：开关打开、当前油门值低于设定的 <code>THRO</code> 值</li>
<li>当油门熄火功能启动后（满足上述两个条件），14SG会把油门设成0</li>
<li>针对电直，我没想到特别适合油门熄火这个功能的场景。我现在是把这个当调试机器的一个功能来用。比如起飞前，我启动油门熄火功能，然后就可以用控来测试桨距、副翼、升降、方向等所有通道，而电机是不会转动的（因为油门是0）。当然你可以把电机线拔掉做同样的测试。</li>
</ul>


<p>其实可以自己在控上琢磨琢磨大概就能搞清楚这两个功能的区别，控上的 <code>Servo</code> 这个功能很实用，你做了任何设置都可以在这里看到各个通道的变化。所以当你设置油门锁定和油门熄火之后，在 <code>Servo</code> 这里就可以很方便的观察油门和桨距两个通道的变化了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NVIDIA Linux驱动在Ubuntu 12.04上的安装]]></title>
    <link href="http://markzhang.cn/blog/2015/06/03/nvidia-linux-driver-on-ubuntu/"/>
    <updated>2015-06-03T21:35:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/06/03/nvidia-linux-driver-on-ubuntu</id>
    <content type="html"><![CDATA[<p>在Ubuntu上安装显卡驱动不是一件容易的事情，安装不是Ubuntu官方认证过的NVIDIA自家的驱动就更是困难，而我选择在一个老的Ubuntu版本上安装显卡驱动，事情就变的更加麻烦起来。</p>

<p>其实一开始我也不想安装NVIDIA自家的驱动，首先想尝试用 <code>nouveau</code>，但是悲剧的发现Ubuntu 12.04上的nouveau无法驱动我的GTX970，可能需要新版本的Ubuntu才可以。所以，被迫选择安装NVIDIA自家的驱动。</p>

<!-- more -->


<p>安装和使用N卡驱动中途遇到了很多的问题，这里来个总结。</p>

<h2>第一次安装</h2>

<p>现在总结起来，可以按照如下步骤来：</p>

<ul>
<li>禁用nouveau和其他相关的module：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo vi /etc/modprobe.d/blacklist.conf
</span><span class='line'>
</span><span class='line'>添加：
</span><span class='line'>
</span><span class='line'>blacklist vga16fb
</span><span class='line'>blacklist nouveau
</span><span class='line'>blacklist rivafb
</span><span class='line'>blacklist nvidiafb
</span><span class='line'>blacklist rivatv
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>卸载nvidia相关的package，否则NVIDIA驱动安装的时候会报错：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>dpkg -l|grep nvidia
</span><span class='line'>sudo apt-get remove &lt;nvidia packages&gt;
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>安装一些常用的package，比如：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo apt-get install build-essential
</span><span class='line'>sudo apt-get install ia32-libs
</span></code></pre></td></tr></table></div></figure>


<p>这是因为NVIDIA驱动安装的时候，会编译kernel module（nvidia.ko），所以需要一些常用的开发用的package。</p>

<ul>
<li><p>NVIDIA驱动安装的时候，X server不能运行，所以我是这么做的：</p></li>
<li><p>重启系统，在grub界面选择进入 <code>Recovery</code> 模式</p></li>
<li>进入Recovery之后，选择 <code>Enable Network</code></li>
<li>重新返回到Recovery界面，选择 <code>Drop to root console</code></li>
<li>运行NVIDIA驱动安装包，按照提示操作即可</li>
</ul>


<p>之所以要做一次 <code>Enable Network</code> 是因为，这个选项会mount一些必要的文件系统，比如 <code>/tmp</code>，NVIDIA驱动安装的时候是需要 <code>/tmp</code> 的。</p>

<h2>Ubuntu更新kernel之后</h2>

<p>如果你使用了Ubuntu的 <code>Update Manager</code> 更新了package之后，一定要注意是否有升级kernel，如果升级了kernel，那么很可能你需要重新安装一次NVIDIA的驱动。</p>

<p>这是因为上面也提到了，<code>nvidia.ko</code> 需要重新编译。所以，如果你更新了kernel，发现X server起不来了，那么就可以尝试这么来：</p>

<ol>
<li>重启系统，在grub界面选择进入 <code>Recovery</code> 模式</li>
<li>进入Recovery之后，选择 <code>Enable Network</code></li>
<li>重新返回到Recovery界面，选择 <code>Drop to root console</code></li>
<li>运行 <code>nvidia-uninstall</code> 卸载当前的NVIDIA驱动</li>
<li>重新运行NVIDIA驱动安装包，再安装一遍驱动</li>
</ol>


<p>之前我尝试过不运行 <code>nvidia-uninstall</code>，直接再次安装一遍驱动，发现这样做的话，安装包也会提醒你说发现当前已经安装了驱动，说是否需要卸载再重新安装。然后我就选择OK，但是发现这样操作下来之后有的时候还是不行，所以还是自己手动uninstall，然后再安装吧。</p>

<h2>如何看出错日志</h2>

<p>主要就是要看两个东西：</p>

<ul>
<li>dmesg：这是kernel的log，看nvidia的内核驱动是否有什么错误，crash，如果有，就Google一下错误信息看是否有帮助</li>
</ul>


<p>这里提一下，看到这个信息是正常的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="o">[</span>    1.222765<span class="o">]</span> nvidia: module license <span class="s1">&#39;NVIDIA&#39;</span> taints kernel.
</span><span class='line'><span class="o">[</span>    1.225367<span class="o">]</span> nvidia: module verification failed: signature and/or  required key missing - tainting kernel
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>/var/log/Xorg.0.log：这里主要是看NVIDIA的X server driver（nvidia_drv.so）是否有错误，crash</li>
</ul>


<h2>万般无奈怎么办</h2>

<ul>
<li><p>去 <a href="http://www.geforce.com/drivers">http://www.geforce.com/drivers</a> 看看有没有BETA版本的驱动下载，有的话下载下来试试。再说一次，记得先uninstall当前的驱动再安装新的。</p></li>
<li><p>去NVIDIA的论坛报bug，我没这么干，因为本身我用的Ubuntu就是老版本了，估计NVIDIA也不会理我，如果去报告Ubuntu 14.04上的bug，可能NVIDIA会创建bug并派人fix。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编译out-of-tree的kernel模块]]></title>
    <link href="http://markzhang.cn/blog/2015/05/12/build-out-of-tree-kernel-module/"/>
    <updated>2015-05-12T10:51:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/05/12/build-out-of-tree-kernel-module</id>
    <content type="html"><![CDATA[<p>所谓 <code>out-of-tree</code> 的内核模块，指的是源代码不在kernel tree里面的模块，比如 <code>nouveau</code> 的tree。</p>

<p>熟悉nouveau的都知道，nouveau的maintainer是单独维护nouveau tree的，所以，一般来说，我们会把nouveau的代码直接放在一个目录下，然后将nouveau编译成一个模块（.ko），这样来编译运行测试就都比较简单。</p>

<!-- more -->


<p>所以关于如何编译一个 <code>out-of-tree</code> 的内核模块，其实内核是有官方文档的：</p>

<p><a href="https://www.kernel.org/doc/Documentation/kbuild/modules.txt">https://www.kernel.org/doc/Documentation/kbuild/modules.txt</a></p>

<p>我一般是这么编译的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>make <span class="nv">ARCH</span><span class="o">=</span>arm64 <span class="nv">CROSS_COMPILE</span><span class="o">=</span>&lt;your toolchain&gt; <span class="nv">INSTALL_MOD_PATH</span><span class="o">=</span>&lt;kernel module install path&gt; <span class="nv">M</span><span class="o">=</span>~/nouveau/drm/nouveau/ -C &lt;the kernel root directory&gt; -j4 modules
</span><span class='line'>make <span class="nv">ARCH</span><span class="o">=</span>arm64 <span class="nv">CROSS_COMPILE</span><span class="o">=</span>&lt;your toolchain&gt; <span class="nv">INSTALL_MOD_PATH</span><span class="o">=</span>&lt;kernel module install path&gt; <span class="nv">M</span><span class="o">=</span>~/nouveau/drm/nouveau/ -C &lt;the kernel root directory&gt; modules_install
</span></code></pre></td></tr></table></div></figure>


<p>一些注意点：</p>

<ul>
<li><p>所谓 <code>kernel root directory</code> 就是能找到.config文件的那个目录</p></li>
<li><p>使用 <code>M=</code> 来指定nouveau在哪里，注意这里要指到 <code>KBuild</code> 所在的那个目录</p></li>
<li><p>kernel本身也有nouveau driver（位与drivers/gpu/drm/nouveau），所以在编译我们的nouveau之前，要先在kernel config中设置编译nouveau为module，然后编译kernel，这样就会出现一个nouveau.ko（来自drivers/gpu/drm/nouveau），这个时候才可以开始用上面的命令行来编译我们自己的nouveau。而我们的nouveau编译完成，module_install的时候，会被安装到 <code>extra</code> 目录下，所以不会和原来的nouveau.ko冲突。但是为了避免困扰，我们可以将原来的nouveau.ko删掉。</p></li>
<li><p>如果你曾经使用 <code>O=&lt;dir&gt;</code> 设置了kernel编译的output dir，那么上面的命令行有可能会不work</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git am失败的时候怎么办]]></title>
    <link href="http://markzhang.cn/blog/2015/05/11/deal-with-git-am-failures/"/>
    <updated>2015-05-11T10:15:00+08:00</updated>
    <id>http://markzhang.cn/blog/2015/05/11/deal-with-git-am-failures</id>
    <content type="html"><![CDATA[<p>本文主要参考了以下文章:</p>

<p><a href="http://www.pizzhacks.com/bugdrome/2011/10/deal-with-git-am-failures/">http://www.pizzhacks.com/bugdrome/2011/10/deal-with-git-am-failures/</a></p>

<p><code>git am</code> 或 <code>git am -3</code> 打patch的时候经常会遇到fail，就是因为patch不apply。但是 <code>git am</code> 不像 <code>git cherry-pick</code> 一样会显示冲突的地方从而让我们可以修改，很多时候 <code>git am</code> 并不显示冲突，只是让我们修正冲突，这就产生了麻烦。</p>

<!-- more -->


<p>于是上面的文章就很好的解决了这个问题，因为一般产生冲突的时候，并不是所有的改动都有冲突，往往冲突是比较少的（<code>patch</code> 本身是可以智能的自动解决一些冲突的），所以我们就可以先用 <code>git apply</code> 来打patch，并将冲突存为一个单独的文件，最后查看冲突文件再手动将冲突修正就可以了。</p>

<p>引用上面文章中的内容，当 <code>git am</code> 失败的时候，可以这么做：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>git apply PATCH --reject
</span><span class='line'><span class="nv">$ </span>edit edit edit
</span><span class='line'><span class="nv">$ </span>git add FIXED_FILES
</span><span class='line'><span class="nv">$ </span>git am --resolved
</span></code></pre></td></tr></table></div></figure>


<p>当 <code>git am</code> 失败的时候，它会告诉你patch文件被它放在了一个路径下面，所有，你只需要直接去 <code>git apply --reject</code> 这个patch就好了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>The copy of the patch that failed is found in...
</span><span class='line'>        xxxxxx
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
</feed>
